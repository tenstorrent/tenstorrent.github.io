<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: tt::tt_metal::v1 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacett.html">tt</a></li><li class="navelem"><a class="el" href="namespacett_1_1tt__metal.html">tt_metal</a></li><li class="navelem"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html">v1</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tt::tt_metal::v1 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtt_1_1tt__metal_1_1v1_1_1CreateDeviceOptions.html">CreateDeviceOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeb98f79faee0fc2ac9492dd5d295d126"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> = v0::Program</td></tr>
<tr class="separator:aeb98f79faee0fc2ac9492dd5d295d126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41efe832ede2a68be6a45168f51dd5ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a> = tt::stl::Span&lt; const std::uint32_t &gt;</td></tr>
<tr class="separator:a41efe832ede2a68be6a45168f51dd5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4ff4aaaef152608a56467ac85d05a8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a4ff4aaaef152608a56467ac85d05a8d9">CreateBuffer</a> (InterleavedBufferConfig config)</td></tr>
<tr class="memdesc:a4ff4aaaef152608a56467ac85d05a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an interleaved DRAM or L1 buffer on the device.  <br /></td></tr>
<tr class="separator:a4ff4aaaef152608a56467ac85d05a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8878e4e772b19708f2ffb47aef88b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#ab8878e4e772b19708f2ffb47aef88b46">DeallocateBuffer</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer)</td></tr>
<tr class="memdesc:ab8878e4e772b19708f2ffb47aef88b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a buffer from the device.  <br /></td></tr>
<tr class="separator:ab8878e4e772b19708f2ffb47aef88b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdc03261b0164072b9e30fad9e36099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a9fdc03261b0164072b9e30fad9e36099">WriteToBuffer</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer, stl::Span&lt; const std::byte &gt; host_buffer)</td></tr>
<tr class="memdesc:a9fdc03261b0164072b9e30fad9e36099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a host buffer into the specified device buffer.  <br /></td></tr>
<tr class="separator:a9fdc03261b0164072b9e30fad9e36099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549dc0b0bd173491b5b67ec9efa599b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a549dc0b0bd173491b5b67ec9efa599b5">ReadFromBuffer</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer, stl::Span&lt; std::byte &gt; host_buffer, bool shard_order=false)</td></tr>
<tr class="memdesc:a549dc0b0bd173491b5b67ec9efa599b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a device buffer into a host buffer.  <br /></td></tr>
<tr class="separator:a549dc0b0bd173491b5b67ec9efa599b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44af81fe6c86b0d4f2e3c5cd414cf836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a44af81fe6c86b0d4f2e3c5cd414cf836">ReadFromShard</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer, stl::Span&lt; std::byte &gt; host_buffer, std::uint32_t core_id)</td></tr>
<tr class="memdesc:a44af81fe6c86b0d4f2e3c5cd414cf836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a specific shard of a device buffer into a host buffer.  <br /></td></tr>
<tr class="separator:a44af81fe6c86b0d4f2e3c5cd414cf836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104050cb8afe039d4b233e5fde691377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a104050cb8afe039d4b233e5fde691377">GetCommandQueue</a> (DeviceHandle device, std::uint8_t cq_id)</td></tr>
<tr class="memdesc:a104050cb8afe039d4b233e5fde691377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a command queue from the device for a given queue ID.  <br /></td></tr>
<tr class="separator:a104050cb8afe039d4b233e5fde691377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d776f4c482bfa8ff8d5ce8950a02f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a1d776f4c482bfa8ff8d5ce8950a02f82">GetDefaultCommandQueue</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a1d776f4c482bfa8ff8d5ce8950a02f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the default command queue for the given device.  <br /></td></tr>
<tr class="separator:a1d776f4c482bfa8ff8d5ce8950a02f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de050e4a431b4dbcbd8e29f2ccd0fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a3de050e4a431b4dbcbd8e29f2ccd0fa6">EnqueueReadBuffer</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer, std::byte *dst, bool blocking)</td></tr>
<tr class="memdesc:a3de050e4a431b4dbcbd8e29f2ccd0fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a buffer from the device.  <br /></td></tr>
<tr class="separator:a3de050e4a431b4dbcbd8e29f2ccd0fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175d287310173ef03a2e6bd2b1b0cfa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a175d287310173ef03a2e6bd2b1b0cfa3">EnqueueWriteBuffer</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer, const std::byte *src, bool blocking)</td></tr>
<tr class="memdesc:a175d287310173ef03a2e6bd2b1b0cfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to a buffer on the device.  <br /></td></tr>
<tr class="separator:a175d287310173ef03a2e6bd2b1b0cfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9787d7e5eaaeb6b838a9c6889c5626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a2e9787d7e5eaaeb6b838a9c6889c5626">EnqueueProgram</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq, <a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, bool blocking)</td></tr>
<tr class="memdesc:a2e9787d7e5eaaeb6b838a9c6889c5626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a program to the device and launches it.  <br /></td></tr>
<tr class="separator:a2e9787d7e5eaaeb6b838a9c6889c5626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4749871772050bc38af4887d3543328b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a4749871772050bc38af4887d3543328b">Finish</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="memdesc:a4749871772050bc38af4887d3543328b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until all previously dispatched commands on the device have completed.  <br /></td></tr>
<tr class="separator:a4749871772050bc38af4887d3543328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6688cd88bb6474148452821a821e8730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a6688cd88bb6474148452821a821e8730">SetLazyCommandQueueMode</a> (bool lazy)</td></tr>
<tr class="memdesc:a6688cd88bb6474148452821a821e8730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the command queue mode to lazy or immediate.  <br /></td></tr>
<tr class="separator:a6688cd88bb6474148452821a821e8730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec81775023e516ef4b34eb5e973da3c0"><td class="memItemLeft" align="right" valign="top">DeviceHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aec81775023e516ef4b34eb5e973da3c0">GetDevice</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq)</td></tr>
<tr class="memdesc:aec81775023e516ef4b34eb5e973da3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the device associated with the command queue.  <br /></td></tr>
<tr class="separator:aec81775023e516ef4b34eb5e973da3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f206a4436d4dd2b00feb80e362759a6"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a8f206a4436d4dd2b00feb80e362759a6">GetId</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq)</td></tr>
<tr class="memdesc:a8f206a4436d4dd2b00feb80e362759a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the ID of the command queue.  <br /></td></tr>
<tr class="separator:a8f206a4436d4dd2b00feb80e362759a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad490d6283121ce887c6209a0ca28265d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#ad490d6283121ce887c6209a0ca28265d">GetNumAvailableDevices</a> ()</td></tr>
<tr class="memdesc:ad490d6283121ce887c6209a0ca28265d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Tenstorrent devices that can be targeted.  <br /></td></tr>
<tr class="separator:ad490d6283121ce887c6209a0ca28265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea09ea2671460caa9fa47b65c8490ec9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aea09ea2671460caa9fa47b65c8490ec9">GetNumPCIeDevices</a> ()</td></tr>
<tr class="memdesc:aea09ea2671460caa9fa47b65c8490ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of Tenstorrent devices connected via PCIe.  <br /></td></tr>
<tr class="separator:aea09ea2671460caa9fa47b65c8490ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ecee1b9528084c6e7d4c3cf371f047"><td class="memItemLeft" align="right" valign="top">chip_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a05ecee1b9528084c6e7d4c3cf371f047">GetPCIeDeviceID</a> (chip_id_t device_id)</td></tr>
<tr class="memdesc:a05ecee1b9528084c6e7d4c3cf371f047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the PCIe device ID for a given device ID.  <br /></td></tr>
<tr class="separator:a05ecee1b9528084c6e7d4c3cf371f047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4414bf13ee2acb9b2c6b8c546ee6e"><td class="memItemLeft" align="right" valign="top">DeviceHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a4cd4414bf13ee2acb9b2c6b8c546ee6e">CreateDevice</a> (chip_id_t device_id, <a class="el" href="structtt_1_1tt__metal_1_1v1_1_1CreateDeviceOptions.html">CreateDeviceOptions</a> options={})</td></tr>
<tr class="memdesc:a4cd4414bf13ee2acb9b2c6b8c546ee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a Device object.  <br /></td></tr>
<tr class="separator:a4cd4414bf13ee2acb9b2c6b8c546ee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2631b7757fe06ad7c10b8ba599b1e074"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a2631b7757fe06ad7c10b8ba599b1e074">CloseDevice</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a2631b7757fe06ad7c10b8ba599b1e074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets and closes the device.  <br /></td></tr>
<tr class="separator:a2631b7757fe06ad7c10b8ba599b1e074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d62fcb4cb9f38f4bb66ac7ec545dd1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a7d62fcb4cb9f38f4bb66ac7ec545dd1d">DeallocateBuffers</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a7d62fcb4cb9f38f4bb66ac7ec545dd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates all buffers on the device.  <br /></td></tr>
<tr class="separator:a7d62fcb4cb9f38f4bb66ac7ec545dd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af2edef85ff9e04ef2a45eda2148f16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a6af2edef85ff9e04ef2a45eda2148f16">DumpDeviceProfileResults</a> (DeviceHandle device, const CoreRangeSet &amp;worker_cores, bool last_dump=false)</td></tr>
<tr class="memdesc:a6af2edef85ff9e04ef2a45eda2148f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps device-side profiler data to a CSV log.  <br /></td></tr>
<tr class="separator:a6af2edef85ff9e04ef2a45eda2148f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0244ed7bf2507b8299a555c2bbe3a0"><td class="memItemLeft" align="right" valign="top">ARCH&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#acd0244ed7bf2507b8299a555c2bbe3a0">GetArch</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:acd0244ed7bf2507b8299a555c2bbe3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the architecture of the device.  <br /></td></tr>
<tr class="separator:acd0244ed7bf2507b8299a555c2bbe3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecef2596d64d30b530d2013d69ee31c3"><td class="memItemLeft" align="right" valign="top">chip_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aecef2596d64d30b530d2013d69ee31c3">GetId</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:aecef2596d64d30b530d2013d69ee31c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the ID of the device.  <br /></td></tr>
<tr class="separator:aecef2596d64d30b530d2013d69ee31c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8191bd3eecb0dde06682e0beee93e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a6f8191bd3eecb0dde06682e0beee93e2">GetNumDramChannels</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a6f8191bd3eecb0dde06682e0beee93e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of DRAM channels on the device.  <br /></td></tr>
<tr class="separator:a6f8191bd3eecb0dde06682e0beee93e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868592eea2fb3cd50e4de99591b1812e"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a868592eea2fb3cd50e4de99591b1812e">GetL1SizePerCore</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a868592eea2fb3cd50e4de99591b1812e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the available L1 size per worker core on the device.  <br /></td></tr>
<tr class="separator:a868592eea2fb3cd50e4de99591b1812e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60255a3c8d626d836533ba15f6531aa0"><td class="memItemLeft" align="right" valign="top">CoreCoord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a60255a3c8d626d836533ba15f6531aa0">GetComputeWithStorageGridSize</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a60255a3c8d626d836533ba15f6531aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the storage grid size for the device.  <br /></td></tr>
<tr class="separator:a60255a3c8d626d836533ba15f6531aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41433cff493160e71b15c5d51e8898a1"><td class="memItemLeft" align="right" valign="top">CoreCoord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41433cff493160e71b15c5d51e8898a1">GetDramGridSize</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a41433cff493160e71b15c5d51e8898a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the DRAM grid size for the device.  <br /></td></tr>
<tr class="separator:a41433cff493160e71b15c5d51e8898a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987aad0700d6d5b2b80a48a2cb80bb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a987aad0700d6d5b2b80a48a2cb80bb6d">EnableProgramCache</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a987aad0700d6d5b2b80a48a2cb80bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the program cache on the device.  <br /></td></tr>
<tr class="separator:a987aad0700d6d5b2b80a48a2cb80bb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a74fef1f54b84399e622a704af37e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a52a74fef1f54b84399e622a704af37e5">DisableAndClearProgramCache</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a52a74fef1f54b84399e622a704af37e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables and clears the program cache on the device.  <br /></td></tr>
<tr class="separator:a52a74fef1f54b84399e622a704af37e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9295aee290efd2c2330317353546c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a0f9295aee290efd2c2330317353546c0">PushWork</a> (DeviceHandle device, std::function&lt; void()&gt; work, bool blocking=false)</td></tr>
<tr class="memdesc:a0f9295aee290efd2c2330317353546c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a work function onto the device's work queue.  <br /></td></tr>
<tr class="separator:a0f9295aee290efd2c2330317353546c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944a8406570b0998bcc7f92c4e3a352f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a944a8406570b0998bcc7f92c4e3a352f">Synchronize</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a944a8406570b0998bcc7f92c4e3a352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes operations on the given device.  <br /></td></tr>
<tr class="separator:a944a8406570b0998bcc7f92c4e3a352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5eb41116f1ba1dc14f8e74f11f47452"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CoreCoord &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#af5eb41116f1ba1dc14f8e74f11f47452">GetEthernetSockets</a> (DeviceHandle device, chip_id_t connected_chip_id)</td></tr>
<tr class="memdesc:af5eb41116f1ba1dc14f8e74f11f47452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a list of Ethernet socket coordinates connected to a specific chip ID.  <br /></td></tr>
<tr class="separator:af5eb41116f1ba1dc14f8e74f11f47452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abc4ac0e93f258cec1908730e4a1622"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a8abc4ac0e93f258cec1908730e4a1622">GetNumBanks</a> (DeviceHandle device, BufferType buffer_type)</td></tr>
<tr class="memdesc:a8abc4ac0e93f258cec1908730e4a1622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of banks for a specific buffer type on the device.  <br /></td></tr>
<tr class="separator:a8abc4ac0e93f258cec1908730e4a1622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d8dafe30fab56e5ff58b30e3e3629c"><td class="memItemLeft" align="right" valign="top">std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a17d8dafe30fab56e5ff58b30e3e3629c">GetBankOffset</a> (DeviceHandle device, BufferType buffer_type, std::uint32_t bank_id)</td></tr>
<tr class="memdesc:a17d8dafe30fab56e5ff58b30e3e3629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the offset of a specific bank for a buffer type on the device.  <br /></td></tr>
<tr class="separator:a17d8dafe30fab56e5ff58b30e3e3629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcaa64de792f41f8f88d66192e93824"><td class="memItemLeft" align="right" valign="top">stl::Span&lt; const std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aebcaa64de792f41f8f88d66192e93824">BankIdsFromLogicalCore</a> (DeviceHandle device, BufferType buffer_type, CoreCoord logical_core)</td></tr>
<tr class="memdesc:aebcaa64de792f41f8f88d66192e93824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves bank IDs associated with a logical core for a given buffer type.  <br /></td></tr>
<tr class="separator:aebcaa64de792f41f8f88d66192e93824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcadd9379349203f6344281fec38c109"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#afcadd9379349203f6344281fec38c109">GetSfpuEps</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:afcadd9379349203f6344281fec38c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the machine epsilon for the SFPU on the device.  <br /></td></tr>
<tr class="separator:afcadd9379349203f6344281fec38c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b48db93c5e56377e08242bc2ea406d5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a9b48db93c5e56377e08242bc2ea406d5">GetSfpuNan</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a9b48db93c5e56377e08242bc2ea406d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the representation of NaN for the SFPU on the device.  <br /></td></tr>
<tr class="separator:a9b48db93c5e56377e08242bc2ea406d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527a71d31e9903b85c772747b68b192"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a8527a71d31e9903b85c772747b68b192">GetSfpuInf</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a8527a71d31e9903b85c772747b68b192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the representation of infinity for the SFPU on the device.  <br /></td></tr>
<tr class="separator:a8527a71d31e9903b85c772747b68b192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfd296d42fffa2b911d130116273cf0"><td class="memItemLeft" align="right" valign="top">WorkExecutorMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a9cfd296d42fffa2b911d130116273cf0">GetWorkerMode</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a9cfd296d42fffa2b911d130116273cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current worker mode of the device.  <br /></td></tr>
<tr class="separator:a9cfd296d42fffa2b911d130116273cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8fd1c289715aad386c6ee40eda1638"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aff8fd1c289715aad386c6ee40eda1638">GetNumProgramCacheEntries</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:aff8fd1c289715aad386c6ee40eda1638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of entries in the program cache on the device.  <br /></td></tr>
<tr class="separator:aff8fd1c289715aad386c6ee40eda1638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac509df53069bbfb2423544bc4c1bda1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#ac509df53069bbfb2423544bc4c1bda1b">EnqueueRecordEvent</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq)</td></tr>
<tr class="memdesc:ac509df53069bbfb2423544bc4c1bda1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to record an event on the device.  <br /></td></tr>
<tr class="separator:ac509df53069bbfb2423544bc4c1bda1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf4017da0353e17f493d15b43292e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a75cf4017da0353e17f493d15b43292e8">EnqueueWaitForEvent</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a> event)</td></tr>
<tr class="memdesc:a75cf4017da0353e17f493d15b43292e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command to wait for an event to complete on the device.  <br /></td></tr>
<tr class="separator:a75cf4017da0353e17f493d15b43292e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0339728931f881b0642a8656e636f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a5f0339728931f881b0642a8656e636f4">EventSynchronize</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a> event)</td></tr>
<tr class="memdesc:a5f0339728931f881b0642a8656e636f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the host until the specified event has completed on the device.  <br /></td></tr>
<tr class="separator:a5f0339728931f881b0642a8656e636f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931a52a892ca8bb955ce8084425536a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a0931a52a892ca8bb955ce8084425536a">EventQuery</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a> event)</td></tr>
<tr class="memdesc:a0931a52a892ca8bb955ce8084425536a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the completion status of an event on the device.  <br /></td></tr>
<tr class="separator:a0931a52a892ca8bb955ce8084425536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88371fc86019f3020c265456c559929b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a88371fc86019f3020c265456c559929b">DeviceSynchronize</a> (DeviceHandle device)</td></tr>
<tr class="memdesc:a88371fc86019f3020c265456c559929b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the device with the host by waiting for all operations to complete.  <br /></td></tr>
<tr class="separator:a88371fc86019f3020c265456c559929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7859c7b14b4045333f51dea3f6fae966"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a7859c7b14b4045333f51dea3f6fae966">CommandQueueSynchronize</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq)</td></tr>
<tr class="memdesc:a7859c7b14b4045333f51dea3f6fae966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes the command queue with the host by waiting for all operations to complete.  <br /></td></tr>
<tr class="separator:a7859c7b14b4045333f51dea3f6fae966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee7734e47e504191e9c6711b40c5a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a5ee7734e47e504191e9c6711b40c5a1f">SetRuntimeArgs</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> kernel, const CoreRangeSet &amp;core_spec, <a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a> runtime_args)</td></tr>
<tr class="memdesc:a5ee7734e47e504191e9c6711b40c5a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets runtime arguments for a kernel.  <br /></td></tr>
<tr class="separator:a5ee7734e47e504191e9c6711b40c5a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eef8efccb83fbe44e2ded7b0cc2c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a18eef8efccb83fbe44e2ded7b0cc2c4f">SetCommonRuntimeArgs</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> kernel, <a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a> runtime_args)</td></tr>
<tr class="memdesc:a18eef8efccb83fbe44e2ded7b0cc2c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets common runtime arguments for a kernel, shared by all cores.  <br /></td></tr>
<tr class="separator:a18eef8efccb83fbe44e2ded7b0cc2c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e7981e6346f3d538520f614e753151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a87e7981e6346f3d538520f614e753151">GetRuntimeArgs</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> kernel, CoreCoord logical_core)</td></tr>
<tr class="memdesc:a87e7981e6346f3d538520f614e753151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the runtime arguments for a kernel.  <br /></td></tr>
<tr class="separator:a87e7981e6346f3d538520f614e753151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2909dc9be2ba6a1dc6011632e3444452"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a2909dc9be2ba6a1dc6011632e3444452">MAKE_ANY_RANGE</a> (SizedCircularBufferRange, stl::AnySizedInputRange&lt; <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>, stl::default_any_range_capacity, 24 &gt;)</td></tr>
<tr class="separator:a2909dc9be2ba6a1dc6011632e3444452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ed6e34eb04904fe348d2a7afa8bc4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a70ed6e34eb04904fe348d2a7afa8bc4c">MAKE_ANY_RANGE</a> (CircularBufferRange, stl::AnyInputRange&lt; <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>, 96, 32 &gt;)</td></tr>
<tr class="separator:a70ed6e34eb04904fe348d2a7afa8bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a5e549383bc80541272724fd1cf7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a00a5e549383bc80541272724fd1cf7e1">CreateProgram</a> ()</td></tr>
<tr class="memdesc:a00a5e549383bc80541272724fd1cf7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Program object, which bundles kernels, circular buffers, and semaphores for execution on the device.  <br /></td></tr>
<tr class="separator:a00a5e549383bc80541272724fd1cf7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b6ebd539e126b2795faaf14ecf0728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a14b6ebd539e126b2795faaf14ecf0728">CreateKernel</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, std::string_view file_name, const CoreRangeSet &amp;core_spec, const DataMovementConfig &amp;config)</td></tr>
<tr class="memdesc:a14b6ebd539e126b2795faaf14ecf0728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data movement or compute kernel and adds it to the program.  <br /></td></tr>
<tr class="separator:a14b6ebd539e126b2795faaf14ecf0728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad4c0f98293c089f29e2264be6479c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a8ad4c0f98293c089f29e2264be6479c4">CreateKernel</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, std::string_view file_name, const CoreRangeSet &amp;core_spec, const ComputeConfig &amp;config)</td></tr>
<tr class="memdesc:a8ad4c0f98293c089f29e2264be6479c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data movement or compute kernel and adds it to the program.  <br /></td></tr>
<tr class="separator:a8ad4c0f98293c089f29e2264be6479c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38764f3b0cb2ace3685c134171f6b0fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a38764f3b0cb2ace3685c134171f6b0fc">CreateKernel</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, std::string_view file_name, const CoreRangeSet &amp;core_spec, const EthernetConfig &amp;config)</td></tr>
<tr class="memdesc:a38764f3b0cb2ace3685c134171f6b0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data movement or compute kernel and adds it to the program.  <br /></td></tr>
<tr class="separator:a38764f3b0cb2ace3685c134171f6b0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e43c40425409e8e18798ca4de93b71"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#ad5e43c40425409e8e18798ca4de93b71">CreateSemaphore</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, const CoreRangeSet &amp;core_spec, std::uint32_t initial_value, CoreType core_type=CoreType::WORKER)</td></tr>
<tr class="memdesc:ad5e43c40425409e8e18798ca4de93b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a semaphore on specified cores.  <br /></td></tr>
<tr class="separator:ad5e43c40425409e8e18798ca4de93b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb08329677f6e2f130a0381f5646b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a3beb08329677f6e2f130a0381f5646b6">CreateCircularBuffer</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, const CoreRangeSet &amp;core_spec, const CircularBufferConfig &amp;config)</td></tr>
<tr class="memdesc:a3beb08329677f6e2f130a0381f5646b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Circular Buffer in L1 memory of specified cores and adds it to the program.  <br /></td></tr>
<tr class="separator:a3beb08329677f6e2f130a0381f5646b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac21dc897d96d19e4aad97d1efcb239"><td class="memItemLeft" align="right" valign="top">const CircularBufferConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a6ac21dc897d96d19e4aad97d1efcb239">GetCircularBufferConfig</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a> cb_handle)</td></tr>
<tr class="memdesc:a6ac21dc897d96d19e4aad97d1efcb239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the configuration of a circular buffer.  <br /></td></tr>
<tr class="separator:a6ac21dc897d96d19e4aad97d1efcb239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a64ba780bddf2bd64b16748ee602b"><td class="memItemLeft" align="right" valign="top">SizedCircularBufferRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a063a64ba780bddf2bd64b16748ee602b">GetCircularBuffers</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program)</td></tr>
<tr class="memdesc:a063a64ba780bddf2bd64b16748ee602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the circular buffers associated with the program.  <br /></td></tr>
<tr class="separator:a063a64ba780bddf2bd64b16748ee602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a552dea5d7227a7805d72fb658f3d49"><td class="memItemLeft" align="right" valign="top">CircularBufferRange&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a5a552dea5d7227a7805d72fb658f3d49">GetCircularBuffersOnCoreRange</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, CoreRange cr)</td></tr>
<tr class="memdesc:a5a552dea5d7227a7805d72fb658f3d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the circular buffers associated with the program on a specific core range.  <br /></td></tr>
<tr class="separator:a5a552dea5d7227a7805d72fb658f3d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94866d5212ee53e90bbf8108e481011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#af94866d5212ee53e90bbf8108e481011">UpdateCircularBufferTotalSize</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a> cb_handle, std::uint32_t total_size)</td></tr>
<tr class="memdesc:af94866d5212ee53e90bbf8108e481011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the total size of a circular buffer.  <br /></td></tr>
<tr class="separator:af94866d5212ee53e90bbf8108e481011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa514298587d69bf5490a52ed4ca04d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aa514298587d69bf5490a52ed4ca04d77">UpdateDynamicCircularBufferAddress</a> (<a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;program, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a> cb_handle, <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> buffer)</td></tr>
<tr class="memdesc:aa514298587d69bf5490a52ed4ca04d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the address of a dynamic circular buffer.  <br /></td></tr>
<tr class="separator:aa514298587d69bf5490a52ed4ca04d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbe074ea7eb58ae2debf7d51fa0234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a19dbe074ea7eb58ae2debf7d51fa0234">GetCommandQueue</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> trace)</td></tr>
<tr class="memdesc:a19dbe074ea7eb58ae2debf7d51fa0234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the associated command queue from a given trace handle.  <br /></td></tr>
<tr class="separator:a19dbe074ea7eb58ae2debf7d51fa0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c346d8491a7e2162a74e827633802c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a35c346d8491a7e2162a74e827633802c">BeginTraceCapture</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> cq)</td></tr>
<tr class="memdesc:a35c346d8491a7e2162a74e827633802c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins capture on a trace. Captured commands will have their execution delayed until the trace is replayed.  <br /></td></tr>
<tr class="separator:a35c346d8491a7e2162a74e827633802c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82f80c6f857daa6981e44e4c51c28c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#af82f80c6f857daa6981e44e4c51c28c6">EndTraceCapture</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> trace)</td></tr>
<tr class="memdesc:af82f80c6f857daa6981e44e4c51c28c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends capture on a trace. The trace can be replayed on the same device command queue.  <br /></td></tr>
<tr class="separator:af82f80c6f857daa6981e44e4c51c28c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a658a690031902c1a8ecd1f0810902"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a25a658a690031902c1a8ecd1f0810902">ReplayTrace</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> trace, bool blocking)</td></tr>
<tr class="memdesc:a25a658a690031902c1a8ecd1f0810902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replays a captured trace on the device.  <br /></td></tr>
<tr class="separator:a25a658a690031902c1a8ecd1f0810902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d79e634d906f2aa3a474224b60609fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a8d79e634d906f2aa3a474224b60609fa">ReleaseTrace</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> trace)</td></tr>
<tr class="memdesc:a8d79e634d906f2aa3a474224b60609fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a previously captured trace, deallocating associated resources.  <br /></td></tr>
<tr class="separator:a8d79e634d906f2aa3a474224b60609fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52db18e0d55921f7e31df14444bac2da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a52db18e0d55921f7e31df14444bac2da">EnqueueTrace</a> (<a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> trace, bool blocking)</td></tr>
<tr class="memdesc:a52db18e0d55921f7e31df14444bac2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a trace for execution on the device.  <br /></td></tr>
<tr class="separator:a52db18e0d55921f7e31df14444bac2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aeb98f79faee0fc2ac9492dd5d295d126" name="aeb98f79faee0fc2ac9492dd5d295d126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb98f79faee0fc2ac9492dd5d295d126">&#9670;&#160;</a></span>ProgramHandle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">tt::tt_metal::v1::ProgramHandle</a> = typedef v0::Program</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41efe832ede2a68be6a45168f51dd5ae" name="a41efe832ede2a68be6a45168f51dd5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41efe832ede2a68be6a45168f51dd5ae">&#9670;&#160;</a></span>RuntimeArgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">tt::tt_metal::v1::RuntimeArgs</a> = typedef tt::stl::Span&lt;const std::uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aebcaa64de792f41f8f88d66192e93824" name="aebcaa64de792f41f8f88d66192e93824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcaa64de792f41f8f88d66192e93824">&#9670;&#160;</a></span>BankIdsFromLogicalCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stl::Span&lt; const std::uint32_t &gt; tt::tt_metal::v1::BankIdsFromLogicalCore </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType&#160;</td>
          <td class="paramname"><em>buffer_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreCoord&#160;</td>
          <td class="paramname"><em>logical_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves bank IDs associated with a logical core for a given buffer type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>The type of buffer. </td></tr>
    <tr><td class="paramname">logical_core</td><td>The logical core coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>span of const bank IDs. </dd></dl>

</div>
</div>
<a id="a35c346d8491a7e2162a74e827633802c" name="a35c346d8491a7e2162a74e827633802c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c346d8491a7e2162a74e827633802c">&#9670;&#160;</a></span>BeginTraceCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a> tt::tt_metal::v1::BeginTraceCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins capture on a trace. Captured commands will have their execution delayed until the trace is replayed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue associated with the trace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trace handle. </dd></dl>

</div>
</div>
<a id="a2631b7757fe06ad7c10b8ba599b1e074" name="a2631b7757fe06ad7c10b8ba599b1e074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2631b7757fe06ad7c10b8ba599b1e074">&#9670;&#160;</a></span>CloseDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tt::tt_metal::v1::CloseDevice </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets and closes the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Handle to the device to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the device was successfully closed; otherwise, false. </dd></dl>

</div>
</div>
<a id="a7859c7b14b4045333f51dea3f6fae966" name="a7859c7b14b4045333f51dea3f6fae966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7859c7b14b4045333f51dea3f6fae966">&#9670;&#160;</a></span>CommandQueueSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::CommandQueueSynchronize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronizes the command queue with the host by waiting for all operations to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>command queue to synchronize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff4aaaef152608a56467ac85d05a8d9" name="a4ff4aaaef152608a56467ac85d05a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff4aaaef152608a56467ac85d05a8d9">&#9670;&#160;</a></span>CreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a> tt::tt_metal::v1::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">InterleavedBufferConfig&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an interleaved DRAM or L1 buffer on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Configuration for the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Buffer handle to the allocated buffer. </dd></dl>

</div>
</div>
<a id="a3beb08329677f6e2f130a0381f5646b6" name="a3beb08329677f6e2f130a0381f5646b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3beb08329677f6e2f130a0381f5646b6">&#9670;&#160;</a></span>CreateCircularBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a> tt::tt_metal::v1::CreateCircularBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CircularBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Circular Buffer in L1 memory of specified cores and adds it to the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to which the buffer will be added. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Specifies the cores where the circular buffer will be configured. </td></tr>
    <tr><td class="paramname">config</td><td>Configuration for the circular buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CBHandle representing the Circular Buffer ID. </dd></dl>

</div>
</div>
<a id="a4cd4414bf13ee2acb9b2c6b8c546ee6e" name="a4cd4414bf13ee2acb9b2c6b8c546ee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd4414bf13ee2acb9b2c6b8c546ee6e">&#9670;&#160;</a></span>CreateDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeviceHandle tt::tt_metal::v1::CreateDevice </td>
          <td>(</td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtt_1_1tt__metal_1_1v1_1_1CreateDeviceOptions.html">CreateDeviceOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a Device object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Configuration parameter for requested device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device handle to the created device. </dd></dl>

</div>
</div>
<a id="a8ad4c0f98293c089f29e2264be6479c4" name="a8ad4c0f98293c089f29e2264be6479c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad4c0f98293c089f29e2264be6479c4">&#9670;&#160;</a></span>CreateKernel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> tt::tt_metal::v1::CreateKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComputeConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data movement or compute kernel and adds it to the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to which this kernel will be added. </td></tr>
    <tr><td class="paramname">file_name</td><td>Path to the kernel source file. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Specifies the cores on which the kernel will be placed. </td></tr>
    <tr><td class="paramname">config</td><td>ComputeConfig for the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </dd></dl>

</div>
</div>
<a id="a14b6ebd539e126b2795faaf14ecf0728" name="a14b6ebd539e126b2795faaf14ecf0728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b6ebd539e126b2795faaf14ecf0728">&#9670;&#160;</a></span>CreateKernel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> tt::tt_metal::v1::CreateKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataMovementConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data movement or compute kernel and adds it to the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to which this kernel will be added. </td></tr>
    <tr><td class="paramname">file_name</td><td>Path to the kernel source file. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Specifies the cores on which the kernel will be placed. </td></tr>
    <tr><td class="paramname">config</td><td>DataMovementConfig for the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </dd></dl>

</div>
</div>
<a id="a38764f3b0cb2ace3685c134171f6b0fc" name="a38764f3b0cb2ace3685c134171f6b0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38764f3b0cb2ace3685c134171f6b0fc">&#9670;&#160;</a></span>CreateKernel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> tt::tt_metal::v1::CreateKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EthernetConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data movement or compute kernel and adds it to the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to which this kernel will be added. </td></tr>
    <tr><td class="paramname">file_name</td><td>Path to the kernel source file. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Specifies the cores on which the kernel will be placed. </td></tr>
    <tr><td class="paramname">config</td><td>EthernetConfig for the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </dd></dl>

</div>
</div>
<a id="a00a5e549383bc80541272724fd1cf7e1" name="a00a5e549383bc80541272724fd1cf7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a5e549383bc80541272724fd1cf7e1">&#9670;&#160;</a></span>CreateProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> tt::tt_metal::v1::CreateProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Program object, which bundles kernels, circular buffers, and semaphores for execution on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>Program handle to the created program. </dd></dl>

</div>
</div>
<a id="ad5e43c40425409e8e18798ca4de93b71" name="ad5e43c40425409e8e18798ca4de93b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e43c40425409e8e18798ca4de93b71">&#9670;&#160;</a></span>CreateSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tt::tt_metal::v1::CreateSemaphore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreType&#160;</td>
          <td class="paramname"><em>core_type</em> = <code>CoreType::WORKER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a semaphore on specified cores. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to which the semaphore will be added. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Range of cores using the semaphore. </td></tr>
    <tr><td class="paramname">initial_value</td><td>Initial value of the semaphore. </td></tr>
    <tr><td class="paramname">core_type</td><td>Core type on which to create the semaphore (default: CoreType::WORKER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Semaphore address as a uint32_t. </dd></dl>

</div>
</div>
<a id="ab8878e4e772b19708f2ffb47aef88b46" name="ab8878e4e772b19708f2ffb47aef88b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8878e4e772b19708f2ffb47aef88b46">&#9670;&#160;</a></span>DeallocateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::DeallocateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates a buffer from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to deallocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d62fcb4cb9f38f4bb66ac7ec545dd1d" name="a7d62fcb4cb9f38f4bb66ac7ec545dd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d62fcb4cb9f38f4bb66ac7ec545dd1d">&#9670;&#160;</a></span>DeallocateBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::DeallocateBuffers </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates all buffers on the device. </p>

</div>
</div>
<a id="a88371fc86019f3020c265456c559929b" name="a88371fc86019f3020c265456c559929b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88371fc86019f3020c265456c559929b">&#9670;&#160;</a></span>DeviceSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::DeviceSynchronize </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronizes the device with the host by waiting for all operations to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to synchronize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52a74fef1f54b84399e622a704af37e5" name="a52a74fef1f54b84399e622a704af37e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a74fef1f54b84399e622a704af37e5">&#9670;&#160;</a></span>DisableAndClearProgramCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::DisableAndClearProgramCache </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables and clears the program cache on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to modify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6af2edef85ff9e04ef2a45eda2148f16" name="a6af2edef85ff9e04ef2a45eda2148f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af2edef85ff9e04ef2a45eda2148f16">&#9670;&#160;</a></span>DumpDeviceProfileResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::DumpDeviceProfileResults </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>worker_cores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last_dump</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps device-side profiler data to a CSV log. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device holding the program being profiled. </td></tr>
    <tr><td class="paramname">worker_cores</td><td>CoreRangeSet of worker cores being profiled. </td></tr>
    <tr><td class="paramname">last_dump</td><td>If true, indicates the last dump before process termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a987aad0700d6d5b2b80a48a2cb80bb6d" name="a987aad0700d6d5b2b80a48a2cb80bb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987aad0700d6d5b2b80a48a2cb80bb6d">&#9670;&#160;</a></span>EnableProgramCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnableProgramCache </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the program cache on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to modify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af82f80c6f857daa6981e44e4c51c28c6" name="af82f80c6f857daa6981e44e4c51c28c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82f80c6f857daa6981e44e4c51c28c6">&#9670;&#160;</a></span>EndTraceCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EndTraceCapture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends capture on a trace. The trace can be replayed on the same device command queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The trace handle returned by BeginTraceCapture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e9787d7e5eaaeb6b838a9c6889c5626" name="a2e9787d7e5eaaeb6b838a9c6889c5626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9787d7e5eaaeb6b838a9c6889c5626">&#9670;&#160;</a></span>EnqueueProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnqueueProgram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a program to the device and launches it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue used to dispatch the command. </td></tr>
    <tr><td class="paramname">program</td><td>The program to execute on the device. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation is blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de050e4a431b4dbcbd8e29f2ccd0fa6" name="a3de050e4a431b4dbcbd8e29f2ccd0fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de050e4a431b4dbcbd8e29f2ccd0fa6">&#9670;&#160;</a></span>EnqueueReadBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a buffer from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue used to dispatch the command. </td></tr>
    <tr><td class="paramname">buffer</td><td>The device buffer to read from. </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to the destination memory where data will be stored. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation is blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac509df53069bbfb2423544bc4c1bda1b" name="ac509df53069bbfb2423544bc4c1bda1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac509df53069bbfb2423544bc4c1bda1b">&#9670;&#160;</a></span>EnqueueRecordEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a> tt::tt_metal::v1::EnqueueRecordEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to record an event on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue used to dispatch the command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the recorded Event object. </dd></dl>

</div>
</div>
<a id="a52db18e0d55921f7e31df14444bac2da" name="a52db18e0d55921f7e31df14444bac2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db18e0d55921f7e31df14444bac2da">&#9670;&#160;</a></span>EnqueueTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnqueueTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a trace for execution on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The Trace to enqueue. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation is blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75cf4017da0353e17f493d15b43292e8" name="a75cf4017da0353e17f493d15b43292e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf4017da0353e17f493d15b43292e8">&#9670;&#160;</a></span>EnqueueWaitForEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnqueueWaitForEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a command to wait for an event to complete on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue that will wait for the event. </td></tr>
    <tr><td class="paramname">event</td><td>Handle to the Event object to wait on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175d287310173ef03a2e6bd2b1b0cfa3" name="a175d287310173ef03a2e6bd2b1b0cfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175d287310173ef03a2e6bd2b1b0cfa3">&#9670;&#160;</a></span>EnqueueWriteBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EnqueueWriteBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::byte *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data to a buffer on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue used to dispatch the command. </td></tr>
    <tr><td class="paramname">buffer</td><td>The device buffer to write to. </td></tr>
    <tr><td class="paramname">src</td><td>Source data vector to write to the device. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation is blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0931a52a892ca8bb955ce8084425536a" name="a0931a52a892ca8bb955ce8084425536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0931a52a892ca8bb955ce8084425536a">&#9670;&#160;</a></span>EventQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tt::tt_metal::v1::EventQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the completion status of an event on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Handle to the Event object to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the event is completed; otherwise, false. </dd></dl>

</div>
</div>
<a id="a5f0339728931f881b0642a8656e636f4" name="a5f0339728931f881b0642a8656e636f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0339728931f881b0642a8656e636f4">&#9670;&#160;</a></span>EventSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::EventSynchronize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1EventHandle.html">EventHandle</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the host until the specified event has completed on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Handle to the Event object to synchronize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4749871772050bc38af4887d3543328b" name="a4749871772050bc38af4887d3543328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4749871772050bc38af4887d3543328b">&#9670;&#160;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::Finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until all previously dispatched commands on the device have completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue to wait on. </td></tr>
    <tr><td class="paramname">sub_device_ids</td><td>The sub-device ids to wait for completion on. If empty, waits for all sub-devices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd0244ed7bf2507b8299a555c2bbe3a0" name="acd0244ed7bf2507b8299a555c2bbe3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0244ed7bf2507b8299a555c2bbe3a0">&#9670;&#160;</a></span>GetArch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ARCH tt::tt_metal::v1::GetArch </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the architecture of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARCH representing the device architecture. </dd></dl>

</div>
</div>
<a id="a17d8dafe30fab56e5ff58b30e3e3629c" name="a17d8dafe30fab56e5ff58b30e3e3629c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d8dafe30fab56e5ff58b30e3e3629c">&#9670;&#160;</a></span>GetBankOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int32_t tt::tt_metal::v1::GetBankOffset </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType&#160;</td>
          <td class="paramname"><em>buffer_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>bank_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the offset of a specific bank for a buffer type on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>The type of buffer. </td></tr>
    <tr><td class="paramname">bank_id</td><td>The ID of the bank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset of the bank. </dd></dl>

</div>
</div>
<a id="a6ac21dc897d96d19e4aad97d1efcb239" name="a6ac21dc897d96d19e4aad97d1efcb239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac21dc897d96d19e4aad97d1efcb239">&#9670;&#160;</a></span>GetCircularBufferConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CircularBufferConfig &amp; tt::tt_metal::v1::GetCircularBufferConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>&#160;</td>
          <td class="paramname"><em>cb_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the configuration of a circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the circular buffer. </td></tr>
    <tr><td class="paramname">cb_handle</td><td>Handle of the circular buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the CircularBufferConfig. </dd></dl>

</div>
</div>
<a id="a063a64ba780bddf2bd64b16748ee602b" name="a063a64ba780bddf2bd64b16748ee602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063a64ba780bddf2bd64b16748ee602b">&#9670;&#160;</a></span>GetCircularBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SizedCircularBufferRange tt::tt_metal::v1::GetCircularBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the circular buffers associated with the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sized input range of <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>. </dd></dl>

</div>
</div>
<a id="a5a552dea5d7227a7805d72fb658f3d49" name="a5a552dea5d7227a7805d72fb658f3d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a552dea5d7227a7805d72fb658f3d49">&#9670;&#160;</a></span>GetCircularBuffersOnCoreRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CircularBufferRange tt::tt_metal::v1::GetCircularBuffersOnCoreRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreRange&#160;</td>
          <td class="paramname"><em>cr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the circular buffers associated with the program on a specific core range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to query. </td></tr>
    <tr><td class="paramname">cr</td><td>The core range to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An input range of <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a> on the given core range. </dd></dl>

</div>
</div>
<a id="a104050cb8afe039d4b233e5fde691377" name="a104050cb8afe039d4b233e5fde691377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104050cb8afe039d4b233e5fde691377">&#9670;&#160;</a></span>GetCommandQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> tt::tt_metal::v1::GetCommandQueue </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>cq_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a command queue from the device for a given queue ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
    <tr><td class="paramname">cq_id</td><td>The command queue ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CommandQueue handle. </dd></dl>

</div>
</div>
<a id="a19dbe074ea7eb58ae2debf7d51fa0234" name="a19dbe074ea7eb58ae2debf7d51fa0234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dbe074ea7eb58ae2debf7d51fa0234">&#9670;&#160;</a></span>GetCommandQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> tt::tt_metal::v1::GetCommandQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the associated command queue from a given trace handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The trace handle returned by BeginTraceCapture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Command queue handle. </dd></dl>

</div>
</div>
<a id="a60255a3c8d626d836533ba15f6531aa0" name="a60255a3c8d626d836533ba15f6531aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60255a3c8d626d836533ba15f6531aa0">&#9670;&#160;</a></span>GetComputeWithStorageGridSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoreCoord tt::tt_metal::v1::GetComputeWithStorageGridSize </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the storage grid size for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CoreCoord representing the storage grid size. </dd></dl>

</div>
</div>
<a id="a1d776f4c482bfa8ff8d5ce8950a02f82" name="a1d776f4c482bfa8ff8d5ce8950a02f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d776f4c482bfa8ff8d5ce8950a02f82">&#9670;&#160;</a></span>GetDefaultCommandQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a> tt::tt_metal::v1::GetDefaultCommandQueue </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the default command queue for the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CommandQueue handle. </dd></dl>

</div>
</div>
<a id="aec81775023e516ef4b34eb5e973da3c0" name="aec81775023e516ef4b34eb5e973da3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec81775023e516ef4b34eb5e973da3c0">&#9670;&#160;</a></span>GetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeviceHandle tt::tt_metal::v1::GetDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the device associated with the command queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device handle associated with the command queue. </dd></dl>

</div>
</div>
<a id="a41433cff493160e71b15c5d51e8898a1" name="a41433cff493160e71b15c5d51e8898a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41433cff493160e71b15c5d51e8898a1">&#9670;&#160;</a></span>GetDramGridSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoreCoord tt::tt_metal::v1::GetDramGridSize </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the DRAM grid size for the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CoreCoord representing the DRAM grid size. </dd></dl>

</div>
</div>
<a id="af5eb41116f1ba1dc14f8e74f11f47452" name="af5eb41116f1ba1dc14f8e74f11f47452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5eb41116f1ba1dc14f8e74f11f47452">&#9670;&#160;</a></span>GetEthernetSockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; CoreCoord &gt; tt::tt_metal::v1::GetEthernetSockets </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>connected_chip_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a list of Ethernet socket coordinates connected to a specific chip ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
    <tr><td class="paramname">connected_chip_id</td><td>The connected chip ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of CoreCoord representing Ethernet socket coordinates. </dd></dl>

</div>
</div>
<a id="a8f206a4436d4dd2b00feb80e362759a6" name="a8f206a4436d4dd2b00feb80e362759a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f206a4436d4dd2b00feb80e362759a6">&#9670;&#160;</a></span>GetId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t tt::tt_metal::v1::GetId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CommandQueueHandle.html">CommandQueueHandle</a>&#160;</td>
          <td class="paramname"><em>cq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the ID of the command queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cq</td><td>The command queue to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the command queue. </dd></dl>

</div>
</div>
<a id="aecef2596d64d30b530d2013d69ee31c3" name="aecef2596d64d30b530d2013d69ee31c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecef2596d64d30b530d2013d69ee31c3">&#9670;&#160;</a></span>GetId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chip_id_t tt::tt_metal::v1::GetId </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the ID of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chip ID of the device. </dd></dl>

</div>
</div>
<a id="a868592eea2fb3cd50e4de99591b1812e" name="a868592eea2fb3cd50e4de99591b1812e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868592eea2fb3cd50e4de99591b1812e">&#9670;&#160;</a></span>GetL1SizePerCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t tt::tt_metal::v1::GetL1SizePerCore </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the available L1 size per worker core on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L1 size per core in bytes. </dd></dl>

</div>
</div>
<a id="ad490d6283121ce887c6209a0ca28265d" name="ad490d6283121ce887c6209a0ca28265d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad490d6283121ce887c6209a0ca28265d">&#9670;&#160;</a></span>GetNumAvailableDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tt::tt_metal::v1::GetNumAvailableDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of Tenstorrent devices that can be targeted. </p>
<dl class="section return"><dt>Returns</dt><dd>Size_t representing the number of available devices. </dd></dl>

</div>
</div>
<a id="a8abc4ac0e93f258cec1908730e4a1622" name="a8abc4ac0e93f258cec1908730e4a1622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abc4ac0e93f258cec1908730e4a1622">&#9670;&#160;</a></span>GetNumBanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t tt::tt_metal::v1::GetNumBanks </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType&#160;</td>
          <td class="paramname"><em>buffer_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of banks for a specific buffer type on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
    <tr><td class="paramname">buffer_type</td><td>The type of buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of banks. </dd></dl>

</div>
</div>
<a id="a6f8191bd3eecb0dde06682e0beee93e2" name="a6f8191bd3eecb0dde06682e0beee93e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8191bd3eecb0dde06682e0beee93e2">&#9670;&#160;</a></span>GetNumDramChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tt::tt_metal::v1::GetNumDramChannels </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of DRAM channels on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of DRAM channels. </dd></dl>

</div>
</div>
<a id="aea09ea2671460caa9fa47b65c8490ec9" name="aea09ea2671460caa9fa47b65c8490ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea09ea2671460caa9fa47b65c8490ec9">&#9670;&#160;</a></span>GetNumPCIeDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tt::tt_metal::v1::GetNumPCIeDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of Tenstorrent devices connected via PCIe. </p>
<dl class="section return"><dt>Returns</dt><dd>Size_t representing the number of PCIe devices. </dd></dl>

</div>
</div>
<a id="aff8fd1c289715aad386c6ee40eda1638" name="aff8fd1c289715aad386c6ee40eda1638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8fd1c289715aad386c6ee40eda1638">&#9670;&#160;</a></span>GetNumProgramCacheEntries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tt::tt_metal::v1::GetNumProgramCacheEntries </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of entries in the program cache on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of program cache entries. </dd></dl>

</div>
</div>
<a id="a05ecee1b9528084c6e7d4c3cf371f047" name="a05ecee1b9528084c6e7d4c3cf371f047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ecee1b9528084c6e7d4c3cf371f047">&#9670;&#160;</a></span>GetPCIeDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chip_id_t tt::tt_metal::v1::GetPCIeDeviceID </td>
          <td>(</td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>device_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the PCIe device ID for a given device ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_id</td><td>ID of the device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chip ID of the PCIe device. </dd></dl>

</div>
</div>
<a id="a87e7981e6346f3d538520f614e753151" name="a87e7981e6346f3d538520f614e753151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e7981e6346f3d538520f614e753151">&#9670;&#160;</a></span>GetRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a> tt::tt_metal::v1::GetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreCoord&#160;</td>
          <td class="paramname"><em>logical_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the runtime arguments for a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the kernel. </td></tr>
    <tr><td class="paramname">kernel</td><td><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </td></tr>
    <tr><td class="paramname">logical_core</td><td>The logical core coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Span of runtime arguments. </dd></dl>

</div>
</div>
<a id="afcadd9379349203f6344281fec38c109" name="afcadd9379349203f6344281fec38c109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcadd9379349203f6344281fec38c109">&#9670;&#160;</a></span>GetSfpuEps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float tt::tt_metal::v1::GetSfpuEps </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the machine epsilon for the SFPU on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SFPU machine epsilon. </dd></dl>

</div>
</div>
<a id="a8527a71d31e9903b85c772747b68b192" name="a8527a71d31e9903b85c772747b68b192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8527a71d31e9903b85c772747b68b192">&#9670;&#160;</a></span>GetSfpuInf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float tt::tt_metal::v1::GetSfpuInf </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the representation of infinity for the SFPU on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SFPU infinity value. </dd></dl>

</div>
</div>
<a id="a9b48db93c5e56377e08242bc2ea406d5" name="a9b48db93c5e56377e08242bc2ea406d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b48db93c5e56377e08242bc2ea406d5">&#9670;&#160;</a></span>GetSfpuNan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float tt::tt_metal::v1::GetSfpuNan </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the representation of NaN for the SFPU on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SFPU NaN value. </dd></dl>

</div>
</div>
<a id="a9cfd296d42fffa2b911d130116273cf0" name="a9cfd296d42fffa2b911d130116273cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfd296d42fffa2b911d130116273cf0">&#9670;&#160;</a></span>GetWorkerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WorkExecutorMode tt::tt_metal::v1::GetWorkerMode </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current worker mode of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WorkExecutorMode representing the current worker mode. </dd></dl>

</div>
</div>
<a id="a70ed6e34eb04904fe348d2a7afa8bc4c" name="a70ed6e34eb04904fe348d2a7afa8bc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ed6e34eb04904fe348d2a7afa8bc4c">&#9670;&#160;</a></span>MAKE_ANY_RANGE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tt::tt_metal::v1::MAKE_ANY_RANGE </td>
          <td>(</td>
          <td class="paramtype">CircularBufferRange&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::AnyInputRange&lt; <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>, 96, 32 &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2909dc9be2ba6a1dc6011632e3444452" name="a2909dc9be2ba6a1dc6011632e3444452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2909dc9be2ba6a1dc6011632e3444452">&#9670;&#160;</a></span>MAKE_ANY_RANGE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tt::tt_metal::v1::MAKE_ANY_RANGE </td>
          <td>(</td>
          <td class="paramtype">SizedCircularBufferRange&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::AnySizedInputRange&lt; <a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>, stl::default_any_range_capacity, 24 &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f9295aee290efd2c2330317353546c0" name="a0f9295aee290efd2c2330317353546c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9295aee290efd2c2330317353546c0">&#9670;&#160;</a></span>PushWork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::PushWork </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a work function onto the device's work queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to which the work will be pushed. </td></tr>
    <tr><td class="paramname">work</td><td>The work function to execute. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation should be blocking (default: false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a549dc0b0bd173491b5b67ec9efa599b5" name="a549dc0b0bd173491b5b67ec9efa599b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549dc0b0bd173491b5b67ec9efa599b5">&#9670;&#160;</a></span>ReadFromBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::ReadFromBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::Span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>host_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shard_order</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a device buffer into a host buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to read data from. </td></tr>
    <tr><td class="paramname">host_buffer</td><td>Host buffer to copy data into. </td></tr>
    <tr><td class="paramname">shard_order</td><td>If true, reads data in shard order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44af81fe6c86b0d4f2e3c5cd414cf836" name="a44af81fe6c86b0d4f2e3c5cd414cf836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44af81fe6c86b0d4f2e3c5cd414cf836">&#9670;&#160;</a></span>ReadFromShard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::ReadFromShard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::Span&lt; std::byte &gt;&#160;</td>
          <td class="paramname"><em>host_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>core_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a specific shard of a device buffer into a host buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to read data from. </td></tr>
    <tr><td class="paramname">host_buffer</td><td>Host buffer to copy data into. </td></tr>
    <tr><td class="paramname">core_id</td><td>ID of the core shard to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d79e634d906f2aa3a474224b60609fa" name="a8d79e634d906f2aa3a474224b60609fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d79e634d906f2aa3a474224b60609fa">&#9670;&#160;</a></span>ReleaseTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::ReleaseTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a previously captured trace, deallocating associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The trace to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25a658a690031902c1a8ecd1f0810902" name="a25a658a690031902c1a8ecd1f0810902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a658a690031902c1a8ecd1f0810902">&#9670;&#160;</a></span>ReplayTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::ReplayTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1TraceHandle.html">TraceHandle</a>&#160;</td>
          <td class="paramname"><em>trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replays a captured trace on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trace</td><td>The trace to replay. </td></tr>
    <tr><td class="paramname">blocking</td><td>Indicates whether the operation is blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18eef8efccb83fbe44e2ded7b0cc2c4f" name="a18eef8efccb83fbe44e2ded7b0cc2c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18eef8efccb83fbe44e2ded7b0cc2c4f">&#9670;&#160;</a></span>SetCommonRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::SetCommonRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a>&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets common runtime arguments for a kernel, shared by all cores. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the kernel. </td></tr>
    <tr><td class="paramname">kernel</td><td><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </td></tr>
    <tr><td class="paramname">runtime_args</td><td>The runtime arguments to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6688cd88bb6474148452821a821e8730" name="a6688cd88bb6474148452821a821e8730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6688cd88bb6474148452821a821e8730">&#9670;&#160;</a></span>SetLazyCommandQueueMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::SetLazyCommandQueueMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lazy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the command queue mode to lazy or immediate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lazy</td><td>If true, sets the command queue to lazy mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ee7734e47e504191e9c6711b40c5a1f" name="a5ee7734e47e504191e9c6711b40c5a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee7734e47e504191e9c6711b40c5a1f">&#9670;&#160;</a></span>SetRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::SetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a>&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#a41efe832ede2a68be6a45168f51dd5ae">RuntimeArgs</a>&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets runtime arguments for a kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the kernel. </td></tr>
    <tr><td class="paramname">kernel</td><td><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1KernelHandle.html">KernelHandle</a> representing the kernel ID. </td></tr>
    <tr><td class="paramname">core_spec</td><td>Specifies the cores where the runtime arguments will be set. </td></tr>
    <tr><td class="paramname">runtime_args</td><td>The runtime arguments to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a944a8406570b0998bcc7f92c4e3a352f" name="a944a8406570b0998bcc7f92c4e3a352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944a8406570b0998bcc7f92c4e3a352f">&#9670;&#160;</a></span>Synchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::Synchronize </td>
          <td>(</td>
          <td class="paramtype">DeviceHandle&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronizes operations on the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to synchronize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af94866d5212ee53e90bbf8108e481011" name="af94866d5212ee53e90bbf8108e481011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94866d5212ee53e90bbf8108e481011">&#9670;&#160;</a></span>UpdateCircularBufferTotalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::UpdateCircularBufferTotalSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>&#160;</td>
          <td class="paramname"><em>cb_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the total size of a circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the circular buffer. </td></tr>
    <tr><td class="paramname">cb_handle</td><td>Handle of the circular buffer. </td></tr>
    <tr><td class="paramname">total_size</td><td>New total size of the circular buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa514298587d69bf5490a52ed4ca04d77" name="aa514298587d69bf5490a52ed4ca04d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa514298587d69bf5490a52ed4ca04d77">&#9670;&#160;</a></span>UpdateDynamicCircularBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::UpdateDynamicCircularBufferAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacett_1_1tt__metal_1_1v1.html#aeb98f79faee0fc2ac9492dd5d295d126">ProgramHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1CircularBufferHandle.html">CircularBufferHandle</a>&#160;</td>
          <td class="paramname"><em>cb_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the address of a dynamic circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program containing the circular buffer. </td></tr>
    <tr><td class="paramname">cb_handle</td><td>Handle of the circular buffer. </td></tr>
    <tr><td class="paramname">buffer</td><td>Dynamically allocated L1 buffer that shares address space with the circular buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fdc03261b0164072b9e30fad9e36099" name="a9fdc03261b0164072b9e30fad9e36099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdc03261b0164072b9e30fad9e36099">&#9670;&#160;</a></span>WriteToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v1::WriteToBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtt_1_1tt__metal_1_1v1_1_1BufferHandle.html">BufferHandle</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::Span&lt; const std::byte &gt;&#160;</td>
          <td class="paramname"><em>host_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from a host buffer into the specified device buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to write data into. </td></tr>
    <tr><td class="paramname">host_buffer</td><td>Host buffer containing data to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
