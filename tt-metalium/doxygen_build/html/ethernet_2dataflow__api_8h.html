<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: tt_metal/hw/inc/ethernet/dataflow_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4fb3d687a4ff02ddb63514ccf23d36f6.html">tt_metal</a></li><li class="navelem"><a class="el" href="dir_07501e64483735e0a95f07c3cb2b524b.html">hw</a></li><li class="navelem"><a class="el" href="dir_61791e9474c0a658d41561dafd5664de.html">inc</a></li><li class="navelem"><a class="el" href="dir_3d024d48631c84625a34f9c87ec54b97.html">ethernet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dataflow_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;risc_common.h&quot;</code><br />
<code>#include &quot;dev_msgs.h&quot;</code><br />
<code>#include &quot;eth_l1_address_map.h&quot;</code><br />
<code>#include &quot;tt_eth_api.h&quot;</code><br />
<code>#include &quot;erisc.h&quot;</code><br />
<code>#include &quot;tools/profiler/kernel_profiler.hpp&quot;</code><br />
<code>#include &quot;noc_nonblocking_api.h&quot;</code><br />
<code>#include &quot;<a class="el" href="dataflow__api_8h_source.html">../dataflow_api.h</a>&quot;</code><br />
<code>#include &quot;tunneling.h&quot;</code><br />
</div>
<p><a href="ethernet_2dataflow__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d454f81bcb8875f528a900fa9326bc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a9d454f81bcb8875f528a900fa9326bc6">eth_txq_is_busy</a> ()</td></tr>
<tr class="separator:a9d454f81bcb8875f528a900fa9326bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e015fbc27db86a39aeab1eea57958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a651e015fbc27db86a39aeab1eea57958">wait_for_eth_txq_cmd_space</a> (uint32_t wait_min=0)</td></tr>
<tr class="separator:a651e015fbc27db86a39aeab1eea57958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0921cad600041ff9a1eff295697d3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#afe0921cad600041ff9a1eff295697d3b">eth_noc_semaphore_wait</a> (volatile uint32_t *sem_addr, uint32_t val, uint32_t wait_min=0)</td></tr>
<tr class="separator:afe0921cad600041ff9a1eff295697d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743b107f28868db5a3af175957fd2fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a743b107f28868db5a3af175957fd2fa2">eth_noc_semaphore_wait_min</a> (volatile uint32_t *sem_addr, uint32_t val, uint32_t wait_min=0)</td></tr>
<tr class="separator:a743b107f28868db5a3af175957fd2fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23f90aed9456576bb85b298a1ce877b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#ae23f90aed9456576bb85b298a1ce877b">eth_noc_async_read_barrier</a> ()</td></tr>
<tr class="separator:ae23f90aed9456576bb85b298a1ce877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47f0940202285a7f23982692e20f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a9d47f0940202285a7f23982692e20f59">eth_noc_async_write_barrier</a> ()</td></tr>
<tr class="separator:a9d47f0940202285a7f23982692e20f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57f8d14c6a15d3680d7284582a786c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a5b57f8d14c6a15d3680d7284582a786c">eth_send_bytes</a> (uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</td></tr>
<tr class="separator:a5b57f8d14c6a15d3680d7284582a786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb3e75736223670aaf5dcbc23d91471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a5cb3e75736223670aaf5dcbc23d91471">eth_send_bytes_over_channel_payload_only</a> (uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</td></tr>
<tr class="separator:a5cb3e75736223670aaf5dcbc23d91471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912b2c36c968ad797b313fa3468666f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a912b2c36c968ad797b313fa3468666f9">eth_send_bytes_over_channel_payload_only_unsafe</a> (uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</td></tr>
<tr class="separator:a912b2c36c968ad797b313fa3468666f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781562a3dd147fc9d9430ce037a1e3da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a781562a3dd147fc9d9430ce037a1e3da">eth_send_payload_complete_signal_over_channel</a> (uint32_t channel, uint32_t num_bytes)</td></tr>
<tr class="separator:a781562a3dd147fc9d9430ce037a1e3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a3f69ac60c29d201771f16f6498cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#af8a3f69ac60c29d201771f16f6498cda">eth_send_bytes_over_channel</a> (uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t channel, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</td></tr>
<tr class="separator:af8a3f69ac60c29d201771f16f6498cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae485db00b351232851e5e43f5cbd0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#aae485db00b351232851e5e43f5cbd0f8">eth_write_remote_reg</a> (uint32_t reg_addr, uint32_t value)</td></tr>
<tr class="separator:aae485db00b351232851e5e43f5cbd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d73eaaa1ed9d986a96a7bef2c9531f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a48d73eaaa1ed9d986a96a7bef2c9531f">eth_wait_for_receiver_done</a> (uint32_t wait_min=0)</td></tr>
<tr class="separator:a48d73eaaa1ed9d986a96a7bef2c9531f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02966d06f690ca2d85533b5e6ce80809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a02966d06f690ca2d85533b5e6ce80809">eth_is_receiver_channel_send_acked</a> (uint32_t channel)</td></tr>
<tr class="separator:a02966d06f690ca2d85533b5e6ce80809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a37dd512972c4e57bbe6e0b198a3941"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a1a37dd512972c4e57bbe6e0b198a3941">eth_is_receiver_channel_send_done</a> (uint32_t channel)</td></tr>
<tr class="separator:a1a37dd512972c4e57bbe6e0b198a3941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff986b2dd8f65e01aca7867bb166e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a3ff986b2dd8f65e01aca7867bb166e96">eth_wait_for_receiver_channel_done</a> (uint32_t channel)</td></tr>
<tr class="separator:a3ff986b2dd8f65e01aca7867bb166e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b56aac8ce0c479e1e5e1009908f7a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a18b56aac8ce0c479e1e5e1009908f7a2">eth_wait_receiver_done</a> (uint32_t wait_min=0)</td></tr>
<tr class="separator:a18b56aac8ce0c479e1e5e1009908f7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5544279ed9fdd9fe6ce2f4d2315e0072"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a5544279ed9fdd9fe6ce2f4d2315e0072">eth_wait_for_bytes</a> (uint32_t num_bytes, uint32_t wait_min=0)</td></tr>
<tr class="separator:a5544279ed9fdd9fe6ce2f4d2315e0072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af738caa9901266b6b58f0fa0b5ee779f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#af738caa9901266b6b58f0fa0b5ee779f">eth_bytes_are_available_on_channel</a> (uint8_t channel)</td></tr>
<tr class="separator:af738caa9901266b6b58f0fa0b5ee779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedc3100f41c4d1fca3f2ef234985bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#adedc3100f41c4d1fca3f2ef234985bda">eth_wait_for_bytes_on_channel_sync_addr</a> (uint32_t num_bytes, volatile eth_channel_sync_t *eth_channel_syncs, uint32_t wait_min=1000000)</td></tr>
<tr class="separator:adedc3100f41c4d1fca3f2ef234985bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0026b0696cbbada2f46119c30c850af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#aa0026b0696cbbada2f46119c30c850af">eth_wait_for_bytes_on_channel</a> (uint32_t num_bytes, uint8_t channel, uint32_t wait_min=1000000)</td></tr>
<tr class="separator:aa0026b0696cbbada2f46119c30c850af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27bb42b34afb388a0994da0f2b73c54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#af27bb42b34afb388a0994da0f2b73c54">eth_receiver_done</a> ()</td></tr>
<tr class="separator:af27bb42b34afb388a0994da0f2b73c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1583ac42a8f9f11794a096506d954a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#ae1583ac42a8f9f11794a096506d954a6">send_eth_receiver_channel_done</a> (volatile eth_channel_sync_t *channel_sync)</td></tr>
<tr class="separator:ae1583ac42a8f9f11794a096506d954a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd35fe4c1c09f60fc53d21a4bccbb71e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#acd35fe4c1c09f60fc53d21a4bccbb71e">eth_receiver_channel_done</a> (uint32_t channel)</td></tr>
<tr class="separator:acd35fe4c1c09f60fc53d21a4bccbb71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1ef34f66d78ba3934c321595ff40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a32a1ef34f66d78ba3934c321595ff40d">eth_clear_sender_channel_ack</a> (uint32_t channel)</td></tr>
<tr class="separator:a32a1ef34f66d78ba3934c321595ff40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff4de9ce3be69c64f017b1b1facc090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a4ff4de9ce3be69c64f017b1b1facc090">eth_receiver_channel_ack</a> (uint32_t channel, uint32_t eth_transaction_ack_word_addr)</td></tr>
<tr class="separator:a4ff4de9ce3be69c64f017b1b1facc090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d550f7bf6d486b386ddea8c81ad0a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a5d550f7bf6d486b386ddea8c81ad0a82">eth_receiver_acknowledge</a> (uint8_t channel=0)</td></tr>
<tr class="separator:a5d550f7bf6d486b386ddea8c81ad0a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1763214451d751d920191f201b2e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ethernet_2dataflow__api_8h.html#a4f1763214451d751d920191f201b2e1f">eth_wait_receiver_acknowledge</a> (uint8_t channel=0)</td></tr>
<tr class="separator:a4f1763214451d751d920191f201b2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af738caa9901266b6b58f0fa0b5ee779f" name="af738caa9901266b6b58f0fa0b5ee779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af738caa9901266b6b58f0fa0b5ee779f">&#9670;&#160;</a></span>eth_bytes_are_available_on_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eth_bytes_are_available_on_channel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be receiver side. This call will tell the receiver whether or not there is payload data to in the local buffer</p>
<p>Non-blocking</p>
<p>Return value: bool: True if payload data was sent (and not yet cleared) on the channel</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to check | uint32_t | 0..7 | True | </p>

</div>
</div>
<a id="a32a1ef34f66d78ba3934c321595ff40d" name="a32a1ef34f66d78ba3934c321595ff40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a1ef34f66d78ba3934c321595ff40d">&#9670;&#160;</a></span>eth_clear_sender_channel_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_clear_sender_channel_ack </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be sender side. This clears the local first level ack field. Useful when resetting on sender side in preparation for next send</p>
<p>Non-blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to check | uint32_t | 0..7 | True | </p>

</div>
</div>
<a id="a02966d06f690ca2d85533b5e6ce80809" name="a02966d06f690ca2d85533b5e6ce80809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02966d06f690ca2d85533b5e6ce80809">&#9670;&#160;</a></span>eth_is_receiver_channel_send_acked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eth_is_receiver_channel_send_acked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be sender side. Indicates to caller that the receiver has received the last payload sent, and that the local sender buffer can be cleared safely</p>
<p>Non-blocking</p>
<p>Return value: bool: true if the receiver has acked</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to check. Corresponds to | uint32_t | 0..7 | True | | | channels in erisc_info_t | | | | </p>

</div>
</div>
<a id="a1a37dd512972c4e57bbe6e0b198a3941" name="a1a37dd512972c4e57bbe6e0b198a3941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a37dd512972c4e57bbe6e0b198a3941">&#9670;&#160;</a></span>eth_is_receiver_channel_send_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eth_is_receiver_channel_send_done </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be sender side. Tells caller that the receiver has both received the last payload sent, and also that it has cleared it to its consumers. If true, indicates that caller (sender) send safely send more data.</p>
<p>Non-blocking</p>
<p>Return value: bool: true if the receiver has acked and forwarded the payload.</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to check. Corresponds to | uint32_t | 0..7 | True | | | channels in erisc_info_t | | | | </p>

</div>
</div>
<a id="ae23f90aed9456576bb85b298a1ce877b" name="ae23f90aed9456576bb85b298a1ce877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23f90aed9456576bb85b298a1ce877b">&#9670;&#160;</a></span>eth_noc_async_read_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_noc_async_read_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_read</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_read</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="a9d47f0940202285a7f23982692e20f59" name="a9d47f0940202285a7f23982692e20f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d47f0940202285a7f23982692e20f59">&#9670;&#160;</a></span>eth_noc_async_write_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_noc_async_write_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_write</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="afe0921cad600041ff9a1eff295697d3b" name="afe0921cad600041ff9a1eff295697d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0921cad600041ff9a1eff295697d3b">&#9670;&#160;</a></span>eth_noc_semaphore_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_noc_semaphore_wait </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | sem_addr | Semaphore address in local L1 memory | uint32_t | 0..1MB | True | | val | The target value of the semaphore | uint32_t | Any uint32_t value | True | | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
<a id="a743b107f28868db5a3af175957fd2fa2" name="a743b107f28868db5a3af175957fd2fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743b107f28868db5a3af175957fd2fa2">&#9670;&#160;</a></span>eth_noc_semaphore_wait_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_noc_semaphore_wait_min </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | sem_addr | Semaphore address in local L1 memory | uint32_t | 0..1MB | True | | val | The target value of the semaphore | uint32_t | Any uint32_t value | True | | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
<a id="a5d550f7bf6d486b386ddea8c81ad0a82" name="a5d550f7bf6d486b386ddea8c81ad0a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d550f7bf6d486b386ddea8c81ad0a82">&#9670;&#160;</a></span>eth_receiver_acknowledge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_receiver_acknowledge </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ff4de9ce3be69c64f017b1b1facc090" name="a4ff4de9ce3be69c64f017b1b1facc090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff4de9ce3be69c64f017b1b1facc090">&#9670;&#160;</a></span>eth_receiver_channel_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_receiver_channel_ack </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eth_transaction_ack_word_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be receiver side. This sends the first level ack to sender, indicating that the last payload sent on the channel was received and that sender is free to clear its buffer</p>
<p>Non-blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |----------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to ack | uint32_t | 0..7 | True | | eth_transaction_ack_word_addr | Address of 16B memory (also 16B aligned) segment with | uint32_t | L1 address | True | | | to send the eth_channel_sync_t to sender for first level| uint32_t | L1 address | True | | | ack. Must <em>not</em> alias erisc_info-&gt;channels[channel] | uint32_t | L1 address | True | </p>

</div>
</div>
<a id="acd35fe4c1c09f60fc53d21a4bccbb71e" name="acd35fe4c1c09f60fc53d21a4bccbb71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd35fe4c1c09f60fc53d21a4bccbb71e">&#9670;&#160;</a></span>eth_receiver_channel_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_receiver_channel_done </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af27bb42b34afb388a0994da0f2b73c54" name="af27bb42b34afb388a0994da0f2b73c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27bb42b34afb388a0994da0f2b73c54">&#9670;&#160;</a></span>eth_receiver_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_receiver_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous call from receiver ethernet core to tell remote sender ethernet core that data sent via eth_send_bytes is no longer being used. Also, see <em>eth_wait_for_receiver_done</em>. Sends over channel 0</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| </p>

</div>
</div>
<a id="a5b57f8d14c6a15d3680d7284582a786c" name="a5b57f8d14c6a15d3680d7284582a786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57f8d14c6a15d3680d7284582a786c">&#9670;&#160;</a></span>eth_send_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_send_bytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send_word_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the local ethernet core to L1 of the connected remote ethernet core. Also, see <em>eth_wait_for_receiver_done</em> and <em>eth_wait_for_bytes</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_addr   </td><td class="markdownTableBodyNone">Source address in local eth core L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..256kB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_addr   </td><td class="markdownTableBodyNone">Destination address in remote eth core L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..256kB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_bytes   </td><td class="markdownTableBodyNone">Size of data transfer in bytes, must be multiple of 16   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..256kB   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af8a3f69ac60c29d201771f16f6498cda" name="af8a3f69ac60c29d201771f16f6498cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a3f69ac60c29d201771f16f6498cda">&#9670;&#160;</a></span>eth_send_bytes_over_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_send_bytes_over_channel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send_word_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cb3e75736223670aaf5dcbc23d91471" name="a5cb3e75736223670aaf5dcbc23d91471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb3e75736223670aaf5dcbc23d91471">&#9670;&#160;</a></span>eth_send_bytes_over_channel_payload_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_send_bytes_over_channel_payload_only </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send_word_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the local ethernet core to L1 of the connected remote ethernet core. However, this is only the first half of the sender's part of then transaction. It does not include the sending of the write completion signature to the receiver.</p>
<p>Non-blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | src_addr | Source address in local eth core L1 memory | uint32_t | 0..256kB | True | | dst_addr | Destination address in remote eth core L1 memory | uint32_t | 0..256kB | True | | num_bytes | Size of data transfer in bytes, must be multiple of 16 | uint32_t | 0..256kB | True | | channel | Which transaction channel to use. Corresponds to | uint32_t | 0..7 | True | | | channels in erisc_info_t | | | | | num_bytes_per_send | Number of bytes to send per packet | uint32_t | 16..1MB | False | | num_bytes_per_send_word_size| num_bytes_per_send shifted right 4 | uint32_t | 1..256kB | False | </p>

</div>
</div>
<a id="a912b2c36c968ad797b313fa3468666f9" name="a912b2c36c968ad797b313fa3468666f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912b2c36c968ad797b313fa3468666f9">&#9670;&#160;</a></span>eth_send_bytes_over_channel_payload_only_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_send_bytes_over_channel_payload_only_unsafe </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes_per_send_word_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a781562a3dd147fc9d9430ce037a1e3da" name="a781562a3dd147fc9d9430ce037a1e3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781562a3dd147fc9d9430ce037a1e3da">&#9670;&#160;</a></span>eth_send_payload_complete_signal_over_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_send_payload_complete_signal_over_channel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d454f81bcb8875f528a900fa9326bc6" name="a9d454f81bcb8875f528a900fa9326bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d454f81bcb8875f528a900fa9326bc6">&#9670;&#160;</a></span>eth_txq_is_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eth_txq_is_busy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if the ethernet transaction queue is busy ingesting a command at this moment,</p>
<p>Return value: bool: true if the queue is ingesting a command and cannot accept a new one at this specific moment </p>

</div>
</div>
<a id="a5544279ed9fdd9fe6ce2f4d2315e0072" name="a5544279ed9fdd9fe6ce2f4d2315e0072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5544279ed9fdd9fe6ce2f4d2315e0072">&#9670;&#160;</a></span>eth_wait_for_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_for_bytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for num_bytes of data to be sent from the remote sender ethernet core using any number of eth_send_byte. User must ensure that num_bytes is equal to the total number of bytes sent. Example 1: eth_send_bytes(32), eth_wait_for_bytes(32). Example 2: eth_send_bytes(16), eth_send_bytes(32), eth_wait_for_bytes(48).</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |---------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | num_bytes | Size of data transfer in bytes, must be multiple of 16 | uint32_t | 0..256kB | True | | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
<a id="aa0026b0696cbbada2f46119c30c850af" name="aa0026b0696cbbada2f46119c30c850af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0026b0696cbbada2f46119c30c850af">&#9670;&#160;</a></span>eth_wait_for_bytes_on_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_for_bytes_on_channel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>1000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adedc3100f41c4d1fca3f2ef234985bda" name="adedc3100f41c4d1fca3f2ef234985bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedc3100f41c4d1fca3f2ef234985bda">&#9670;&#160;</a></span>eth_wait_for_bytes_on_channel_sync_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_for_bytes_on_channel_sync_addr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile eth_channel_sync_t *&#160;</td>
          <td class="paramname"><em>eth_channel_syncs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>1000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be receiver side. This call block until there is payload data in the local buffer associated with the channel</p>
<p>Blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | num_bytes | Number of bytes to receive before returning to caller | uint32_t | 0..1MB | True | | channel | Which transaction channel to check | uint32_t | 0..7 | True | </p>

</div>
</div>
<a id="a3ff986b2dd8f65e01aca7867bb166e96" name="a3ff986b2dd8f65e01aca7867bb166e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff986b2dd8f65e01aca7867bb166e96">&#9670;&#160;</a></span>eth_wait_for_receiver_channel_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_for_receiver_channel_done </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be sender side. This call will block until receiver sends both levels of ack</p>
<p>Blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to block on | uint32_t | 0..7 | True | </p>

</div>
</div>
<a id="a48d73eaaa1ed9d986a96a7bef2c9531f" name="a48d73eaaa1ed9d986a96a7bef2c9531f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d73eaaa1ed9d986a96a7bef2c9531f">&#9670;&#160;</a></span>eth_wait_for_receiver_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_for_receiver_done </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for receiver to acknowledge that all data sent with eth_send_bytes since the last reset_erisc_info call is no longer being used. Also, see <em><a class="el" href="ethernet_2dataflow__api_8h.html#af27bb42b34afb388a0994da0f2b73c54">eth_receiver_done()</a></em>.</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |---------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
<a id="a4f1763214451d751d920191f201b2e1f" name="a4f1763214451d751d920191f201b2e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1763214451d751d920191f201b2e1f">&#9670;&#160;</a></span>eth_wait_receiver_acknowledge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_receiver_acknowledge </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18b56aac8ce0c479e1e5e1009908f7a2" name="a18b56aac8ce0c479e1e5e1009908f7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b56aac8ce0c479e1e5e1009908f7a2">&#9670;&#160;</a></span>eth_wait_receiver_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_wait_receiver_done </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be sender side. This call will block until receiver sends both levels of ack</p>
<p>Blocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |-------------------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | channel | Which transaction channel to block on | uint32_t | 0..7 | True | | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
<a id="aae485db00b351232851e5e43f5cbd0f8" name="aae485db00b351232851e5e43f5cbd0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae485db00b351232851e5e43f5cbd0f8">&#9670;&#160;</a></span>eth_write_remote_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eth_write_remote_reg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from the local ethernet core to a register of the connected remote ethernet core.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reg_addr   </td><td class="markdownTableBodyNone">Destination address in remote eth core reg space   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0xFF000000+   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">value   </td><td class="markdownTableBodyNone">Value to be written   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae1583ac42a8f9f11794a096506d954a6" name="ae1583ac42a8f9f11794a096506d954a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1583ac42a8f9f11794a096506d954a6">&#9670;&#160;</a></span>send_eth_receiver_channel_done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_eth_receiver_channel_done </td>
          <td>(</td>
          <td class="paramtype">volatile eth_channel_sync_t *&#160;</td>
          <td class="paramname"><em>channel_sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller is expected to be receiver side. This call sends the second (and first) level ack to sender, indicating that the receiver flushed its buffer and is able to accept more data</p>
<p>Non-nlocking</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------------------------&mdash;|------------------------------------------------------&mdash;|-------&mdash;|----------&mdash;|-------&mdash;| | channel | Which transaction channel to ack | uint32_t | 0..7 | True | </p>

</div>
</div>
<a id="a651e015fbc27db86a39aeab1eea57958" name="a651e015fbc27db86a39aeab1eea57958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651e015fbc27db86a39aeab1eea57958">&#9670;&#160;</a></span>wait_for_eth_txq_cmd_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_for_eth_txq_cmd_space </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wait_min</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait until the ethernet transaction queue is no longer busy ingesting a command</p>
<p>Return value: None</p>
<p>| Argument | Description | Type | Valid Range | Required | |--------&mdash;|-------------------------------------------------------------&mdash;|-------&mdash;|-----------------&mdash;|-------&mdash;| | wait_min | The number of cycles to wait before performing run_routing() | uint32_t | Any uint32_t value | False | </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
