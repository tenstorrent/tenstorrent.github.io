<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: tt_metal/hw/inc/dataflow_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4fb3d687a4ff02ddb63514ccf23d36f6.html">tt_metal</a></li><li class="navelem"><a class="el" href="dir_07501e64483735e0a95f07c3cb2b524b.html">hw</a></li><li class="navelem"><a class="el" href="dir_61791e9474c0a658d41561dafd5664de.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">dataflow_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;core_config.h&quot;</code><br />
<code>#include &quot;circular_buffer.h&quot;</code><br />
<code>#include &quot;debug/sanitize_noc.h&quot;</code><br />
<code>#include &quot;debug/waypoint.h&quot;</code><br />
<code>#include &quot;eth_l1_address_map.h&quot;</code><br />
<code>#include &quot;hostdevcommon/common_values.hpp&quot;</code><br />
<code>#include &quot;risc_attribs.h&quot;</code><br />
<code>#include &quot;third_party/umd/device/tt_silicon_driver_common.hpp&quot;</code><br />
<code>#include &quot;debug/assert.h&quot;</code><br />
<code>#include &quot;dev_msgs.h&quot;</code><br />
</div>
<p><a href="dataflow__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedPow2AddrGen.html">InterleavedPow2AddrGen&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast&lt; DRAM, tile_hw &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedPow2AddrGenFast.html">InterleavedPow2AddrGenFast&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinterleaved__addr__gen"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinterleaved__addr__gen.html">interleaved_addr_gen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a56cf50350ff87477df00fb899480ff2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a56cf50350ff87477df00fb899480ff2d">NOC_UNICAST_WRITE_VC</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a56cf50350ff87477df00fb899480ff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb39d71d6c419e9ad7aa0f43e5a91d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a5fb39d71d6c419e9ad7aa0f43e5a91d8">NOC_MULTICAST_WRITE_VC</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a5fb39d71d6c419e9ad7aa0f43e5a91d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49104913a904db0ef5c642d10a33c923"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a49104913a904db0ef5c642d10a33c923">NOC_DISPATCH_MULTICAST_WRITE_VC</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a49104913a904db0ef5c642d10a33c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf0e2f602d799115bb67b144ae7e3f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#afdf0e2f602d799115bb67b144ae7e3f7">EXCLUDE_ENABLED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afdf0e2f602d799115bb67b144ae7e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a8a64d9844a79b222a12e5ddf42028"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a21a8a64d9844a79b222a12e5ddf42028">EXCLUDE_ENABLED_OFFSET</a>&#160;&#160;&#160;22</td></tr>
<tr class="separator:a21a8a64d9844a79b222a12e5ddf42028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fae11f46cf5042340264e92008ef07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ad0fae11f46cf5042340264e92008ef07">EXCLUDE_DIRECTION_Y_OFFSET</a>&#160;&#160;&#160;21</td></tr>
<tr class="separator:ad0fae11f46cf5042340264e92008ef07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3426d319a63d0c7ba70305b4e1dfe31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa3426d319a63d0c7ba70305b4e1dfe31">EXCLUDE_DIRECTION_X_OFFSET</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:aa3426d319a63d0c7ba70305b4e1dfe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdfe0cbd91a7e89ec5f265be58d2046"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a3cdfe0cbd91a7e89ec5f265be58d2046">EXCLUDE_START_Y_OFFSET</a>&#160;&#160;&#160;14</td></tr>
<tr class="separator:a3cdfe0cbd91a7e89ec5f265be58d2046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa0dd89473ba937f0a6f07ab69fe7dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a5fa0dd89473ba937f0a6f07ab69fe7dc">EXCLUDE_START_X_OFFSET</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a5fa0dd89473ba937f0a6f07ab69fe7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0d59e125c87ff2f8fe0c9a394626c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a25a0d59e125c87ff2f8fe0c9a394626c">DYNAMIC_NOC_DIRECTION</a>(noc,  direction)&#160;&#160;&#160;(noc == 1 ? 1 - direction : direction)</td></tr>
<tr class="separator:a25a0d59e125c87ff2f8fe0c9a394626c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f9dbfbb4150cb324f21520b8e6cfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab97f9dbfbb4150cb324f21520b8e6cfe">get_compile_time_arg_val</a>(arg_idx)&#160;&#160;&#160;KERNEL_COMPILE_TIME_ARG_##arg_idx</td></tr>
<tr class="separator:ab97f9dbfbb4150cb324f21520b8e6cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4752c4d9a07974ce99aaa671a675fe2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ac4752c4d9a07974ce99aaa671a675fe2">align</a> (uint32_t addr, uint32_t alignment)</td></tr>
<tr class="separator:ac4752c4d9a07974ce99aaa671a675fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4018be9d6302207fdc0dac085663e184"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a4018be9d6302207fdc0dac085663e184"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinterleaved__addr__gen.html#a4018be9d6302207fdc0dac085663e184">interleaved_addr_gen::get_bank_offset_index</a> (uint32_t id)</td></tr>
<tr class="separator:a4018be9d6302207fdc0dac085663e184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63194c761e19c2a9d096f91c9e9be63c"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a63194c761e19c2a9d096f91c9e9be63c"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinterleaved__addr__gen.html#a63194c761e19c2a9d096f91c9e9be63c">interleaved_addr_gen::get_bank_index</a> (uint32_t id, uint32_t bank_offset_index)</td></tr>
<tr class="separator:a63194c761e19c2a9d096f91c9e9be63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9ecce3a6a35846d19425e4b193d37e"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a5a9ecce3a6a35846d19425e4b193d37e"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinterleaved__addr__gen.html#a5a9ecce3a6a35846d19425e4b193d37e">interleaved_addr_gen::get_noc_xy</a> (uint32_t bank_index, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a5a9ecce3a6a35846d19425e4b193d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinterleaved__addr__gen.html#a593eecf4e9f53608d0c5c82e54b36b03">interleaved_addr_gen::get_bank_offset</a> (uint32_t bank_index)</td></tr>
<tr class="separator:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a6a5074e8cd2732fcecab57fced3ebd1f">get_arg_val</a> (int arg_idx)</td></tr>
<tr class="separator:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba486e3732fb5ea715651f92234e60a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abba486e3732fb5ea715651f92234e60a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#abba486e3732fb5ea715651f92234e60a">get_common_arg_val</a> (int arg_idx)</td></tr>
<tr class="separator:abba486e3732fb5ea715651f92234e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81357224b88562601b42833eec676ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a81357224b88562601b42833eec676ffb">cb_push_back</a> (const int32_t operand, const int32_t num_pages)</td></tr>
<tr class="separator:a81357224b88562601b42833eec676ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3daf8e5e7299140cf2607be1a8656b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa3daf8e5e7299140cf2607be1a8656b0">cb_pop_front</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:aa3daf8e5e7299140cf2607be1a8656b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a1a9478a83ad216d826dc5f783d1f8"><td class="memItemLeft" align="right" valign="top">constexpr std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af4a1a9478a83ad216d826dc5f783d1f8">get_tile_size</a> (const std::int32_t operand)</td></tr>
<tr class="separator:af4a1a9478a83ad216d826dc5f783d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccecfafffbcaa5ab433f25cec7fbd72"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a8ccecfafffbcaa5ab433f25cec7fbd72">get_tile_hw</a> (const std::int32_t operand)</td></tr>
<tr class="separator:a8ccecfafffbcaa5ab433f25cec7fbd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cc2ffdf430e95ad915cca719f5fa2a"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a84cc2ffdf430e95ad915cca719f5fa2a">get_tile_num_faces</a> (const std::int32_t operand)</td></tr>
<tr class="separator:a84cc2ffdf430e95ad915cca719f5fa2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae214b6c2f978e745f9c24d397dad906d"><td class="memItemLeft" align="right" valign="top">constexpr DataFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae214b6c2f978e745f9c24d397dad906d">get_dataformat</a> (const std::int32_t operand)</td></tr>
<tr class="separator:ae214b6c2f978e745f9c24d397dad906d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593e43aff0c85e4b3f86d13f1d7350dd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a593e43aff0c85e4b3f86d13f1d7350dd">get_write_ptr</a> (uint32_t operand)</td></tr>
<tr class="separator:a593e43aff0c85e4b3f86d13f1d7350dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a31715a14cea1a63cbdca8c99b0827"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a66a31715a14cea1a63cbdca8c99b0827">get_read_ptr</a> (uint32_t operand)</td></tr>
<tr class="separator:a66a31715a14cea1a63cbdca8c99b0827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2384f3c7d9784e3e662093136cbed25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af2384f3c7d9784e3e662093136cbed25">wait_for_sync_register_value</a> (uint32_t addr, int32_t val)</td></tr>
<tr class="separator:af2384f3c7d9784e3e662093136cbed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa465b4c6c7d0c83c7d27823ef3f97199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa465b4c6c7d0c83c7d27823ef3f97199">cb_pages_reservable_at_back</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:aa465b4c6c7d0c83c7d27823ef3f97199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29521dee07b0070674a988f66c01ffed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a29521dee07b0070674a988f66c01ffed">cb_reserve_back</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:a29521dee07b0070674a988f66c01ffed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e354d124dd292ebf624551fb6f6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a579e354d124dd292ebf624551fb6f6cf">cb_pages_available_at_front</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:a579e354d124dd292ebf624551fb6f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8057bd05a650c3501c5208f7d9f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af6d8057bd05a650c3501c5208f7d9f8a">cb_wait_front</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:af6d8057bd05a650c3501c5208f7d9f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404b93ad6dbb9393b882bbf936a75d9"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af404b93ad6dbb9393b882bbf936a75d9">get_noc_multicast_addr</a> (std::uint32_t noc_x_start, std::uint32_t noc_y_start, std::uint32_t noc_x_end, std::uint32_t noc_y_end, std::uint32_t addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:af404b93ad6dbb9393b882bbf936a75d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec74feed8e1fce53c5561c28021eb63"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aeec74feed8e1fce53c5561c28021eb63">get_noc_addr</a> (std::uint32_t noc_x, std::uint32_t noc_y, std::uint32_t addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:aeec74feed8e1fce53c5561c28021eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa850145f50aafa428c0d257cfed4fb8c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa850145f50aafa428c0d257cfed4fb8c">get_noc_addr_helper</a> (std::uint32_t noc_xy, std::uint32_t addr)</td></tr>
<tr class="separator:aa850145f50aafa428c0d257cfed4fb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e59d5056ed48344b94e314fa8bd92c"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae8e59d5056ed48344b94e314fa8bd92c">get_noc_exclude_region</a> (std::uint32_t exclude_start_x, std::uint32_t exclude_start_y, std::uint32_t exclude_dir_x, std::uint32_t exclude_dir_y, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ae8e59d5056ed48344b94e314fa8bd92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cc2abf3ea7ef206891ca06b1174122"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae6cc2abf3ea7ef206891ca06b1174122">get_dram_noc_addr</a> (const uint32_t id, const uint32_t page_size, const uint32_t bank_base_address, const uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ae6cc2abf3ea7ef206891ca06b1174122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2b40a6884c495ec14250c528a4dd7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a31a2b40a6884c495ec14250c528a4dd7">get_l1_noc_addr</a> (const uint32_t id, const uint32_t page_size, const uint32_t bank_base_address, const uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a31a2b40a6884c495ec14250c528a4dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9291a1484765db08b61bb0be52135c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#abe9291a1484765db08b61bb0be52135c">get_system_memory_noc_addr</a> (const uint32_t id, const uint32_t page_size, const uint32_t base_addr, const uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:abe9291a1484765db08b61bb0be52135c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e17f34cbfaaf63b2479e4f755aaa12c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a9e17f34cbfaaf63b2479e4f755aaa12c">get_noc_addr</a> (std::uint32_t addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a9e17f34cbfaaf63b2479e4f755aaa12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa390aaa2b1facb57041e9a2c48cfbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a0fa390aaa2b1facb57041e9a2c48cfbf">noc_async_read</a> (std::uint64_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a0fa390aaa2b1facb57041e9a2c48cfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef5fd38ffe71fe3ec4a453aa39053b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a8aef5fd38ffe71fe3ec4a453aa39053b">noc_async_read_one_packet</a> (std::uint64_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a8aef5fd38ffe71fe3ec4a453aa39053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3070e5dc8b9ed311b89d154643c4f8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a3070e5dc8b9ed311b89d154643c4f8fd">noc_async_read_one_packet_set_state</a> (std::uint64_t src_noc_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a3070e5dc8b9ed311b89d154643c4f8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4031bdbfa690ceee630ad17f8ca99fdb"><td class="memTemplParams" colspan="2">template&lt;bool inc_num_issued = true&gt; </td></tr>
<tr class="memitem:a4031bdbfa690ceee630ad17f8ca99fdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a4031bdbfa690ceee630ad17f8ca99fdb">noc_async_read_one_packet_with_state</a> (std::uint32_t src_noc_addr, std::uint32_t dst_local_l1_addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a4031bdbfa690ceee630ad17f8ca99fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8bc61e237ad566538149901b548ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a60d8bc61e237ad566538149901b548ad">noc_async_read_set_state</a> (std::uint64_t src_noc_addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a60d8bc61e237ad566538149901b548ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa006454ec0ae734836c80ecc0a4cfe18"><td class="memTemplParams" colspan="2">template&lt;bool inc_num_issued = true&gt; </td></tr>
<tr class="memitem:aa006454ec0ae734836c80ecc0a4cfe18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa006454ec0ae734836c80ecc0a4cfe18">noc_async_read_with_state</a> (std::uint32_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:aa006454ec0ae734836c80ecc0a4cfe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8894085f35db86f5dd1b884d5168c166"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a8894085f35db86f5dd1b884d5168c166">noc_async_read_inc_num_issued</a> (std::uint32_t num_issued_reads_inc, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a8894085f35db86f5dd1b884d5168c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff80388ddc749f68da0a8e72320a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a0fff80388ddc749f68da0a8e72320a89">noc_async_write_one_packet</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a0fff80388ddc749f68da0a8e72320a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99484885c567e016e23899f0408bd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae99484885c567e016e23899f0408bd57">noc_async_write_multicast_one_packet</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ae99484885c567e016e23899f0408bd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107fbfba5c58e08da38918af048c8bc7"><td class="memTemplParams" colspan="2">template&lt;bool non_posted = true&gt; </td></tr>
<tr class="memitem:a107fbfba5c58e08da38918af048c8bc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a107fbfba5c58e08da38918af048c8bc7">noc_async_write_one_packet_set_state</a> (std::uint64_t dst_noc_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>, uint8_t vc=<a class="el" href="dataflow__api_8h.html#a56cf50350ff87477df00fb899480ff2d">NOC_UNICAST_WRITE_VC</a>)</td></tr>
<tr class="separator:a107fbfba5c58e08da38918af048c8bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47736387eba0f8f4d5523a504508636d"><td class="memTemplParams" colspan="2">template&lt;bool non_posted = true&gt; </td></tr>
<tr class="memitem:a47736387eba0f8f4d5523a504508636d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a47736387eba0f8f4d5523a504508636d">noc_async_write_one_packet_with_state</a> (std::uint32_t src_local_l1_addr, std::uint32_t dst_noc_addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a47736387eba0f8f4d5523a504508636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41af911427b28e8d8e87869679f27c4"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:ac41af911427b28e8d8e87869679f27c4"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ac41af911427b28e8d8e87869679f27c4">get_noc_addr</a> (const uint32_t id, const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;s, uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ac41af911427b28e8d8e87869679f27c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c97b5ef900963ae9c3a5d87a7ef1ff"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:ae6c97b5ef900963ae9c3a5d87a7ef1ff"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae6c97b5ef900963ae9c3a5d87a7ef1ff">get_noc_addr</a> (const uint32_t id, const <a class="el" href="structInterleavedPow2AddrGen.html">InterleavedPow2AddrGen</a>&lt; DRAM &gt; &amp;s, uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ae6c97b5ef900963ae9c3a5d87a7ef1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2101cd8c2aec4bec53247d732a956c"><td class="memTemplParams" colspan="2">template&lt;bool DRAM, uint32_t tile_hw&gt; </td></tr>
<tr class="memitem:a6c2101cd8c2aec4bec53247d732a956c"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a6c2101cd8c2aec4bec53247d732a956c">get_noc_addr</a> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;s, uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a6c2101cd8c2aec4bec53247d732a956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4948036d7191e294716b03d68b9d8a"><td class="memTemplParams" colspan="2">template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a3a4948036d7191e294716b03d68b9d8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a3a4948036d7191e294716b03d68b9d8a">noc_async_read_page</a> (const uint32_t id, const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;s, std::uint32_t dst_local_l1_addr, uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a3a4948036d7191e294716b03d68b9d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f6b951ebf9742b2bea80741ff47d27"><td class="memTemplParams" colspan="2">template&lt;bool DRAM, uint32_t tile_hw&gt; </td></tr>
<tr class="memitem:a94f6b951ebf9742b2bea80741ff47d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a94f6b951ebf9742b2bea80741ff47d27">noc_async_read_tile</a> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;s, std::uint32_t dst_local_l1_addr, uint32_t offset=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a94f6b951ebf9742b2bea80741ff47d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188eeb8f8c1f14b173ebe8c406133600"><td class="memTemplParams" colspan="2">template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </td></tr>
<tr class="memitem:a188eeb8f8c1f14b173ebe8c406133600"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a188eeb8f8c1f14b173ebe8c406133600">noc_async_write</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr, std::uint32_t size, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a188eeb8f8c1f14b173ebe8c406133600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b5afaf9a9f9f4d9692dcd59fc62a0"><td class="memTemplParams" colspan="2">template&lt;bool DRAM, uint32_t tile_hw&gt; </td></tr>
<tr class="memitem:a4f6b5afaf9a9f9f4d9692dcd59fc62a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a4f6b5afaf9a9f9f4d9692dcd59fc62a0">noc_async_write_tile</a> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;s, std::uint32_t src_local_l1_addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a4f6b5afaf9a9f9f4d9692dcd59fc62a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memTemplParams" colspan="2">template&lt;ProgrammableCoreType type = ProgrammableCoreType::TENSIX&gt; </td></tr>
<tr class="memitem:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aad24ffd7fc05b797ce38e6072c2f0eab">get_semaphore</a> (uint32_t semaphore_id)</td></tr>
<tr class="separator:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85bbb469e6f0aaeabed92f4aeb6fc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa85bbb469e6f0aaeabed92f4aeb6fc71">noc_semaphore_set_remote</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:aa85bbb469e6f0aaeabed92f4aeb6fc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abf4783385b9983021c773f47e3874"><td class="memTemplParams" colspan="2">template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </td></tr>
<tr class="memitem:ab5abf4783385b9983021c773f47e3874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab5abf4783385b9983021c773f47e3874">noc_async_write_multicast</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ab5abf4783385b9983021c773f47e3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125909749e0596744b6b27c288d566ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a125909749e0596744b6b27c288d566ce">noc_semaphore_set_multicast</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a125909749e0596744b6b27c288d566ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0375e12b7323fe5f3e8c25a800b7882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ac0375e12b7323fe5f3e8c25a800b7882">noc_semaphore_set_multicast_loopback_src</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ac0375e12b7323fe5f3e8c25a800b7882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378aa2e8c1468ef8ef71ad74c70315a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a378aa2e8c1468ef8ef71ad74c70315a9">noc_async_write_multicast_loopback_src</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a378aa2e8c1468ef8ef71ad74c70315a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2326e9e29ea607bc865e50b614f197dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a2326e9e29ea607bc865e50b614f197dd">noc_async_read_barrier</a> (uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a2326e9e29ea607bc865e50b614f197dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f29294fed4616943f1592452706467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a57f29294fed4616943f1592452706467">noc_async_write_barrier</a> (uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a57f29294fed4616943f1592452706467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7075995d85a7119a04ad734bd34a4bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a7075995d85a7119a04ad734bd34a4bf5">noc_async_writes_flushed</a> (uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a7075995d85a7119a04ad734bd34a4bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a74d46d62931d19a406414db103c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a13a74d46d62931d19a406414db103c4b">noc_async_atomic_barrier</a> (uint8_t noc_idx=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a13a74d46d62931d19a406414db103c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f714cc4a08a2eaac5e3f7fae9d1383a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a4f714cc4a08a2eaac5e3f7fae9d1383a">noc_semaphore_wait</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:a4f714cc4a08a2eaac5e3f7fae9d1383a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a965a61b65152c42835f35dca007af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a84a965a61b65152c42835f35dca007af">noc_semaphore_wait_min</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:a84a965a61b65152c42835f35dca007af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02a9af640679b00da874318535aa397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af02a9af640679b00da874318535aa397">noc_semaphore_set</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:af02a9af640679b00da874318535aa397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f779ea1675acf61c46613048ce96e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab5f779ea1675acf61c46613048ce96e1">noc_inline_dw_write</a> (uint64_t addr, uint32_t val, uint8_t be=0xF, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:ab5f779ea1675acf61c46613048ce96e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962d804ce21d1d26ccb4241e2eb6ac9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a962d804ce21d1d26ccb4241e2eb6ac9f">noc_semaphore_inc</a> (uint64_t addr, uint32_t incr, uint8_t noc_id=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a962d804ce21d1d26ccb4241e2eb6ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9618b5b64ed1ae0d0a747ac0f10745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a9e9618b5b64ed1ae0d0a747ac0f10745">RISC_POST_HEARTBEAT</a> (uint32_t &amp;heartbeat)</td></tr>
<tr class="separator:a9e9618b5b64ed1ae0d0a747ac0f10745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bd290aaee1b41529717b029dc14952"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a29bd290aaee1b41529717b029dc14952">min</a> (uint32_t a, uint32_t b)</td></tr>
<tr class="separator:a29bd290aaee1b41529717b029dc14952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009e28764f70f39d1a2ccaaba8681973"><td class="memTemplParams" colspan="2">template&lt;bool use_vc&gt; </td></tr>
<tr class="memitem:a009e28764f70f39d1a2ccaaba8681973"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a009e28764f70f39d1a2ccaaba8681973">noc_async_read_tile_dram_sharded_set_state</a> (uint32_t bank_base_address, uint32_t page_size, uint32_t bank_id=0, const uint32_t vc=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a009e28764f70f39d1a2ccaaba8681973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cf808450c0213bcdc180a038aac523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a61cf808450c0213bcdc180a038aac523">noc_async_read_tile_dram_sharded_with_state</a> (uint32_t src_base_addr, uint32_t src_addr, uint32_t dest_addr, uint32_t trid=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a61cf808450c0213bcdc180a038aac523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ff412712df6c4f9f4e557ace59c1ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a10ff412712df6c4f9f4e557ace59c1ec">noc_async_read_tile_dram_sharded_with_state_with_trid</a> (uint32_t src_base_addr, uint32_t src_addr, uint32_t dest_addr, uint32_t trid=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a10ff412712df6c4f9f4e557ace59c1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905d1234815d8abd8aa72460d34386ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a905d1234815d8abd8aa72460d34386ed">noc_async_read_tile_dram_sharded_set_trid</a> (uint32_t trid=0, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a905d1234815d8abd8aa72460d34386ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98abddb8e88027a5299d2124b3953d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a98abddb8e88027a5299d2124b3953d19">noc_async_read_barrier_with_trid</a> (uint32_t trid, uint8_t noc=<a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a>)</td></tr>
<tr class="separator:a98abddb8e88027a5299d2124b3953d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a58bc3a01e945dbd421fce21906e94441"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></td></tr>
<tr class="separator:a58bc3a01e945dbd421fce21906e94441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbb1273e3f29964043f4660b5c5bc1d"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#abfbb1273e3f29964043f4660b5c5bc1d">noc_mode</a> = DM_DEDICATED_NOC</td></tr>
<tr class="separator:abfbb1273e3f29964043f4660b5c5bc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2366e9251332058fa1fa368903d1d760"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a2366e9251332058fa1fa368903d1d760">rta_l1_base</a></td></tr>
<tr class="separator:a2366e9251332058fa1fa368903d1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5ca11f2fb15c25af4a74db732a5fc"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a74c5ca11f2fb15c25af4a74db732a5fc">crta_l1_base</a></td></tr>
<tr class="separator:a74c5ca11f2fb15c25af4a74db732a5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237705982b987907cbfca699e32a9c64"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a237705982b987907cbfca699e32a9c64">sem_l1_base</a> []</td></tr>
<tr class="separator:a237705982b987907cbfca699e32a9c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5a15ba6d1a0359eb8270daa81f6e1a"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#afa5a15ba6d1a0359eb8270daa81f6e1a">read_cmd_buf</a> = NCRISC_RD_CMD_BUF</td></tr>
<tr class="separator:afa5a15ba6d1a0359eb8270daa81f6e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53f3d62ad6a9eeabe5f4604e3e9b13f"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae53f3d62ad6a9eeabe5f4604e3e9b13f">write_cmd_buf</a> = NCRISC_WR_CMD_BUF</td></tr>
<tr class="separator:ae53f3d62ad6a9eeabe5f4604e3e9b13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c97896ab8cfddde7d4951cd6f947e0f"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a6c97896ab8cfddde7d4951cd6f947e0f">write_reg_cmd_buf</a> = NCRISC_WR_REG_CMD_BUF</td></tr>
<tr class="separator:a6c97896ab8cfddde7d4951cd6f947e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c097a6b6c3174e4b39fa61e1aed761"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a27c097a6b6c3174e4b39fa61e1aed761">write_at_cmd_buf</a> = NCRISC_AT_CMD_BUF</td></tr>
<tr class="separator:a27c097a6b6c3174e4b39fa61e1aed761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a25a0d59e125c87ff2f8fe0c9a394626c" name="a25a0d59e125c87ff2f8fe0c9a394626c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a0d59e125c87ff2f8fe0c9a394626c">&#9670;&#160;</a></span>DYNAMIC_NOC_DIRECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DYNAMIC_NOC_DIRECTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">noc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">direction&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(noc == 1 ? 1 - direction : direction)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3426d319a63d0c7ba70305b4e1dfe31" name="aa3426d319a63d0c7ba70305b4e1dfe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3426d319a63d0c7ba70305b4e1dfe31">&#9670;&#160;</a></span>EXCLUDE_DIRECTION_X_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_DIRECTION_X_OFFSET&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0fae11f46cf5042340264e92008ef07" name="ad0fae11f46cf5042340264e92008ef07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fae11f46cf5042340264e92008ef07">&#9670;&#160;</a></span>EXCLUDE_DIRECTION_Y_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_DIRECTION_Y_OFFSET&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdf0e2f602d799115bb67b144ae7e3f7" name="afdf0e2f602d799115bb67b144ae7e3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf0e2f602d799115bb67b144ae7e3f7">&#9670;&#160;</a></span>EXCLUDE_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_ENABLED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a8a64d9844a79b222a12e5ddf42028" name="a21a8a64d9844a79b222a12e5ddf42028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a8a64d9844a79b222a12e5ddf42028">&#9670;&#160;</a></span>EXCLUDE_ENABLED_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_ENABLED_OFFSET&#160;&#160;&#160;22</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fa0dd89473ba937f0a6f07ab69fe7dc" name="a5fa0dd89473ba937f0a6f07ab69fe7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa0dd89473ba937f0a6f07ab69fe7dc">&#9670;&#160;</a></span>EXCLUDE_START_X_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_START_X_OFFSET&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cdfe0cbd91a7e89ec5f265be58d2046" name="a3cdfe0cbd91a7e89ec5f265be58d2046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdfe0cbd91a7e89ec5f265be58d2046">&#9670;&#160;</a></span>EXCLUDE_START_Y_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXCLUDE_START_Y_OFFSET&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab97f9dbfbb4150cb324f21520b8e6cfe" name="ab97f9dbfbb4150cb324f21520b8e6cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f9dbfbb4150cb324f21520b8e6cfe">&#9670;&#160;</a></span>get_compile_time_arg_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_compile_time_arg_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg_idx</td><td>)</td>
          <td>&#160;&#160;&#160;KERNEL_COMPILE_TIME_ARG_##arg_idx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of a constexpr argument from kernel_compile_time_args array provided during kernel creation using CreateKernel calls.</p>
<p>Return value: constexpr uint32_t</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">The index of the argument   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a49104913a904db0ef5c642d10a33c923" name="a49104913a904db0ef5c642d10a33c923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49104913a904db0ef5c642d10a33c923">&#9670;&#160;</a></span>NOC_DISPATCH_MULTICAST_WRITE_VC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOC_DISPATCH_MULTICAST_WRITE_VC&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fb39d71d6c419e9ad7aa0f43e5a91d8" name="a5fb39d71d6c419e9ad7aa0f43e5a91d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb39d71d6c419e9ad7aa0f43e5a91d8">&#9670;&#160;</a></span>NOC_MULTICAST_WRITE_VC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOC_MULTICAST_WRITE_VC&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56cf50350ff87477df00fb899480ff2d" name="a56cf50350ff87477df00fb899480ff2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cf50350ff87477df00fb899480ff2d">&#9670;&#160;</a></span>NOC_UNICAST_WRITE_VC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NOC_UNICAST_WRITE_VC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac4752c4d9a07974ce99aaa671a675fe2" name="ac4752c4d9a07974ce99aaa671a675fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4752c4d9a07974ce99aaa671a675fe2">&#9670;&#160;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t align </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579e354d124dd292ebf624551fb6f6cf" name="a579e354d124dd292ebf624551fb6f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579e354d124dd292ebf624551fb6f6cf">&#9670;&#160;</a></span>cb_pages_available_at_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cb_pages_available_at_front </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A non-blocking call that tells the caller if the specified number of pages are available in the specified circular buffer (CB). This call is used by the consumer of the CB to see if the prodcuers has fill the CB with at least the specified number of tiles. Important note: in case multiple calls of cb_wait_front(n) are issued without a paired <a class="el" href="dataflow__api_8h.html#aa3daf8e5e7299140cf2607be1a8656b0">cb_pop_front()</a> call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example: 4 calls of cb_wait_front(8) followed by a cb_pop_front(32) would produce incorrect behavior. Instead 4 calls of <a class="el" href="dataflow__api_8h.html#af6d8057bd05a650c3501c5208f7d9f8a">cb_wait_front()</a> waiting on 8, 16, 24, 32 tiles should be issued.</p>
<p>Important note: number of tiles used in all cb_* calls must evenly divide the cb size and must be the same number in all cb_wait_front calls in the same kernel. Example 1: cb_wait_front(32), cb_wait_front(40), cb_pop_front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2: cb_wait_front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.</p>
<p>Important note: CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to check for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone"></td></tr>
</table>

</div>
</div>
<a id="aa465b4c6c7d0c83c7d27823ef3f97199" name="aa465b4c6c7d0c83c7d27823ef3f97199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa465b4c6c7d0c83c7d27823ef3f97199">&#9670;&#160;</a></span>cb_pages_reservable_at_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cb_pages_reservable_at_back </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A non-blocking call that checks if the specified number of pages are available for reservation at the back of the circular buffer. This call is used by the producer to see if the consumer has freed up the desired space (in pages).</p>
<p>CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: true if the specified number of pages are available</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of free tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa3daf8e5e7299140cf2607be1a8656b0" name="aa3daf8e5e7299140cf2607be1a8656b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3daf8e5e7299140cf2607be1a8656b0">&#9670;&#160;</a></span>cb_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_pop_front </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops a specified number of tiles from the front of the specified CB. This also frees this number of tiles in the circular buffer. This call is used by the consumer to free up the space in the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of reading of the tile data from the CB does not free up the space in the CB. Waiting on available tiles and popping them is separated in order to allow the consumer to: 1) read the tile data from the CB via multiple reads of sub-tiles 2) access the tiles (or their sub-tiles) that are visible to the consumer by random access of the valid section of the CB</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to be popped   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a81357224b88562601b42833eec676ffb" name="a81357224b88562601b42833eec676ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81357224b88562601b42833eec676ffb">&#9670;&#160;</a></span>cb_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_push_back </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a given number of tiles in the back of the specified CB’s queue. Decreases the available space in the circular buffer by this number of tiles. This call is used by the producer to make the tiles visible to the consumer of the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of writing the tile data into the CB does not make the tiles visible to the consumer. Writing of the tiles and pushing is separated to allow the producer to: 1) write the tile data to the CB via multiple writes of sub-tiles 2) modify tiles (or sub-tiles) by random access of the valid section of the CB</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to be pushed   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a29521dee07b0070674a988f66c01ffed" name="a29521dee07b0070674a988f66c01ffed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29521dee07b0070674a988f66c01ffed">&#9670;&#160;</a></span>cb_reserve_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_reserve_back </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be free in the specified circular buffer. This call is used by the producer to wait for the consumer to consume (ie. free up) the specified number of tiles.</p>
<p>CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of free tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af6d8057bd05a650c3501c5208f7d9f8a" name="af6d8057bd05a650c3501c5208f7d9f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d8057bd05a650c3501c5208f7d9f8a">&#9670;&#160;</a></span>cb_wait_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_wait_front </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be available in the specified circular buffer (CB). This call is used by the consumer of the CB to wait for the producer to fill the CB with at least the specified number of tiles. Important note: in case multiple calls of cb_wait_front(n) are issued without a paired <a class="el" href="dataflow__api_8h.html#aa3daf8e5e7299140cf2607be1a8656b0">cb_pop_front()</a> call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example: 4 calls of cb_wait_front(8) followed by a cb_pop_front(32) would produce incorrect behavior. Instead 4 calls of <a class="el" href="dataflow__api_8h.html#af6d8057bd05a650c3501c5208f7d9f8a">cb_wait_front()</a> waiting on 8, 16, 24, 32 tiles should be issued.</p>
<p>Important note: number of tiles used in all cb_* calls must evenly divide the cb size and must be the same number in all cb_wait_front calls in the same kernel. Example 1: cb_wait_front(32), cb_wait_front(40), cb_pop_front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2: cb_wait_front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.</p>
<p>Important note: CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone"></td></tr>
</table>

</div>
</div>
<a id="a6a5074e8cd2732fcecab57fced3ebd1f" name="a6a5074e8cd2732fcecab57fced3ebd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5074e8cd2732fcecab57fced3ebd1f">&#9670;&#160;</a></span>get_arg_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_arg_val </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a given runtime argument index for unique (per-core) runtime arguments set via SetRuntimeArgs() API.</p>
<p>Return value: The value associated with the unique runtime argument index</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">Unique Runtime argument index   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 255   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">T (template argument)   </td><td class="markdownTableBodyNone">Data type of the returned argument   </td><td class="markdownTableBodyNone">Any 4-byte sized type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="abba486e3732fb5ea715651f92234e60a" name="abba486e3732fb5ea715651f92234e60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba486e3732fb5ea715651f92234e60a">&#9670;&#160;</a></span>get_common_arg_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_common_arg_val </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a given runtime argument index for common (all cores) runtime arguments set via SetCommonRuntimeArgs() API.</p>
<p>Return value: The value associated with the common runtime argument index</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">Common Runtime argument index   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 255   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">T (template argument)   </td><td class="markdownTableBodyNone">Data type of the returned argument   </td><td class="markdownTableBodyNone">Any 4-byte sized type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae214b6c2f978e745f9c24d397dad906d" name="ae214b6c2f978e745f9c24d397dad906d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae214b6c2f978e745f9c24d397dad906d">&#9670;&#160;</a></span>get_dataformat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr DataFormat get_dataformat </td>
          <td>(</td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6cc2abf3ea7ef206891ca06b1174122" name="ae6cc2abf3ea7ef206891ca06b1174122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cc2abf3ea7ef206891ca06b1174122">&#9670;&#160;</a></span>get_dram_noc_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_dram_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>bank_base_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a2b40a6884c495ec14250c528a4dd7" name="a31a2b40a6884c495ec14250c528a4dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a2b40a6884c495ec14250c528a4dd7">&#9670;&#160;</a></span>get_l1_noc_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_l1_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>bank_base_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac41af911427b28e8d8e87869679f27c4" name="ac41af911427b28e8d8e87869679f27c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41af911427b28e8d8e87869679f27c4">&#9670;&#160;</a></span>get_noc_addr() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c2101cd8c2aec4bec53247d732a956c" name="a6c2101cd8c2aec4bec53247d732a956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2101cd8c2aec4bec53247d732a956c">&#9670;&#160;</a></span>get_noc_addr() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM, uint32_t tile_hw&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6c97b5ef900963ae9c3a5d87a7ef1ff" name="ae6c97b5ef900963ae9c3a5d87a7ef1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c97b5ef900963ae9c3a5d87a7ef1ff">&#9670;&#160;</a></span>get_noc_addr() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedPow2AddrGen.html">InterleavedPow2AddrGen</a>&lt; DRAM &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e17f34cbfaaf63b2479e4f755aaa12c" name="a9e17f34cbfaaf63b2479e4f755aaa12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e17f34cbfaaf63b2479e4f755aaa12c">&#9670;&#160;</a></span>get_noc_addr() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeec74feed8e1fce53c5561c28021eb63" name="aeec74feed8e1fce53c5561c28021eb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec74feed8e1fce53c5561c28021eb63">&#9670;&#160;</a></span>get_noc_addr() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa850145f50aafa428c0d257cfed4fb8c" name="aa850145f50aafa428c0d257cfed4fb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa850145f50aafa428c0d257cfed4fb8c">&#9670;&#160;</a></span>get_noc_addr_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_addr_helper </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_xy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8e59d5056ed48344b94e314fa8bd92c" name="ae8e59d5056ed48344b94e314fa8bd92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e59d5056ed48344b94e314fa8bd92c">&#9670;&#160;</a></span>get_noc_exclude_region()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t get_noc_exclude_region </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>exclude_start_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>exclude_start_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>exclude_dir_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>exclude_dir_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af404b93ad6dbb9393b882bbf936a75d9" name="af404b93ad6dbb9393b882bbf936a75d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af404b93ad6dbb9393b882bbf936a75d9">&#9670;&#160;</a></span>get_noc_multicast_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t get_noc_multicast_addr </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_x_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_y_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_x_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>noc_y_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a31715a14cea1a63cbdca8c99b0827" name="a66a31715a14cea1a63cbdca8c99b0827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a31715a14cea1a63cbdca8c99b0827">&#9670;&#160;</a></span>get_read_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_read_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of a memory block previously received by cb_wait_front. Note that this call is only valid between calls to cb_wait_front and cb_pop_front. The amount of valid memory is equal to the number of tiles requested in a prior cb_wait_front call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">operand   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aad24ffd7fc05b797ce38e6072c2f0eab" name="aad24ffd7fc05b797ce38e6072c2f0eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad24ffd7fc05b797ce38e6072c2f0eab">&#9670;&#160;</a></span>get_semaphore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ProgrammableCoreType type = ProgrammableCoreType::TENSIX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_semaphore </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>semaphore_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe9291a1484765db08b61bb0be52135c" name="abe9291a1484765db08b61bb0be52135c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9291a1484765db08b61bb0be52135c">&#9670;&#160;</a></span>get_system_memory_noc_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t get_system_memory_noc_addr </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ccecfafffbcaa5ab433f25cec7fbd72" name="a8ccecfafffbcaa5ab433f25cec7fbd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccecfafffbcaa5ab433f25cec7fbd72">&#9670;&#160;</a></span>get_tile_hw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t get_tile_hw </td>
          <td>(</td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84cc2ffdf430e95ad915cca719f5fa2a" name="a84cc2ffdf430e95ad915cca719f5fa2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cc2ffdf430e95ad915cca719f5fa2a">&#9670;&#160;</a></span>get_tile_num_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t get_tile_num_faces </td>
          <td>(</td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a1a9478a83ad216d826dc5f783d1f8" name="af4a1a9478a83ad216d826dc5f783d1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a1a9478a83ad216d826dc5f783d1f8">&#9670;&#160;</a></span>get_tile_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int32_t get_tile_size </td>
          <td>(</td>
          <td class="paramtype">const std::int32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a593e43aff0c85e4b3f86d13f1d7350dd" name="a593e43aff0c85e4b3f86d13f1d7350dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593e43aff0c85e4b3f86d13f1d7350dd">&#9670;&#160;</a></span>get_write_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_write_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of a memory block previously reserved by cb_reserve_back. Note that this call is only valid between calls to cb_reserve_back and cb_push_back. The amount of valid memory is equal to the number of tiles requested in a prior cb_reserve_back call.</p>
<p>CB total size must be an even multiple of this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">operand   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a29bd290aaee1b41529717b029dc14952" name="a29bd290aaee1b41529717b029dc14952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bd290aaee1b41529717b029dc14952">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t min </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13a74d46d62931d19a406414db103c4b" name="a13a74d46d62931d19a406414db103c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a74d46d62931d19a406414db103c4b">&#9670;&#160;</a></span>noc_async_atomic_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_atomic_barrier </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc_idx</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_write</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="a0fa390aaa2b1facb57041e9a2c48cfbf" name="a0fa390aaa2b1facb57041e9a2c48cfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa390aaa2b1facb57041e9a2c48cfbf">&#9670;&#160;</a></span>noc_async_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous read from a specified source node located at NOC coordinates (x,y) at a local address (encoded as a uint64_t using <em>get_noc_addr</em> function). The destination is in L1 memory on the Tensix core executing this function call. Also, see <em>noc_async_read_barrier</em>.</p>
<p>The source node can be either a DRAM bank, a Tensix core or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Data type   </th><th class="markdownTableHeadNone">Valid range   </th><th class="markdownTableHeadNone">required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_noc_addr   </td><td class="markdownTableBodyNone">Encoding of the source NOC location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(ref to explain valid coords)   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_local_l1_addr   </td><td class="markdownTableBodyNone">Address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a2326e9e29ea607bc865e50b614f197dd" name="a2326e9e29ea607bc865e50b614f197dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2326e9e29ea607bc865e50b614f197dd">&#9670;&#160;</a></span>noc_async_read_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_barrier </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to an L-shaped destination which is defined by a grid and an exclusion zone. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. Also, <em>see noc_async_write_barrier</em>. Similarly, the exclusion zone is specified using uint32_t encoding referencing an on-chip core and directions relative to it created using <em>get_noc_exclude_region</em> function.</p>
<p>The destination nodes can only be a set of Tensix cores + L1 memory address. The destination nodes must form an L-shaped grid (where dst_noc_addr_multicast defines a grid and exclude_region define a subgrid to exclude, the inner part of the L). The destination L1 memory address must be the same on all destination nodes.</p>
<p>With this API, the multicast sender cannot be part of the multicast destinations.</p>
<p>Note: The number of destinations needs to be non-zero. Besides that, there is no restriction on the number of destinations, i.e. the multicast destinations can span the full chip. However, as mentioned previously, the multicast source cannot be part of the destinations. So, the maximum number of destinations is number of cores - 1.</p>
<p>Return value: None</p>
<p>NOTE: only supported on Blackhole</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..(number of cores - 1)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">exclude_region   </td><td class="markdownTableBodyNone">Encoding of the excluded regin (x_start,y_start,x_direction,y_direction)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_read</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_read</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="a98abddb8e88027a5299d2124b3953d19" name="a98abddb8e88027a5299d2124b3953d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98abddb8e88027a5299d2124b3953d19">&#9670;&#160;</a></span>noc_async_read_barrier_with_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_barrier_with_trid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8894085f35db86f5dd1b884d5168c166" name="a8894085f35db86f5dd1b884d5168c166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8894085f35db86f5dd1b884d5168c166">&#9670;&#160;</a></span>noc_async_read_inc_num_issued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_inc_num_issued </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_issued_reads_inc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aef5fd38ffe71fe3ec4a453aa39053b" name="a8aef5fd38ffe71fe3ec4a453aa39053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aef5fd38ffe71fe3ec4a453aa39053b">&#9670;&#160;</a></span>noc_async_read_one_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_one_packet </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3070e5dc8b9ed311b89d154643c4f8fd" name="a3070e5dc8b9ed311b89d154643c4f8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3070e5dc8b9ed311b89d154643c4f8fd">&#9670;&#160;</a></span>noc_async_read_one_packet_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_one_packet_set_state </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4031bdbfa690ceee630ad17f8ca99fdb" name="a4031bdbfa690ceee630ad17f8ca99fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4031bdbfa690ceee630ad17f8ca99fdb">&#9670;&#160;</a></span>noc_async_read_one_packet_with_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inc_num_issued = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_one_packet_with_state </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a4948036d7191e294716b03d68b9d8a" name="a3a4948036d7191e294716b03d68b9d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4948036d7191e294716b03d68b9d8a">&#9670;&#160;</a></span>noc_async_read_page()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_page </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d8bc61e237ad566538149901b548ad" name="a60d8bc61e237ad566538149901b548ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8bc61e237ad566538149901b548ad">&#9670;&#160;</a></span>noc_async_read_set_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_set_state </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94f6b951ebf9742b2bea80741ff47d27" name="a94f6b951ebf9742b2bea80741ff47d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f6b951ebf9742b2bea80741ff47d27">&#9670;&#160;</a></span>noc_async_read_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM, uint32_t tile_hw&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_tile </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a009e28764f70f39d1a2ccaaba8681973" name="a009e28764f70f39d1a2ccaaba8681973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009e28764f70f39d1a2ccaaba8681973">&#9670;&#160;</a></span>noc_async_read_tile_dram_sharded_set_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_vc&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t noc_async_read_tile_dram_sharded_set_state </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank_base_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bank_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>vc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a905d1234815d8abd8aa72460d34386ed" name="a905d1234815d8abd8aa72460d34386ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905d1234815d8abd8aa72460d34386ed">&#9670;&#160;</a></span>noc_async_read_tile_dram_sharded_set_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_tile_dram_sharded_set_trid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61cf808450c0213bcdc180a038aac523" name="a61cf808450c0213bcdc180a038aac523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cf808450c0213bcdc180a038aac523">&#9670;&#160;</a></span>noc_async_read_tile_dram_sharded_with_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_tile_dram_sharded_with_state </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10ff412712df6c4f9f4e557ace59c1ec" name="a10ff412712df6c4f9f4e557ace59c1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ff412712df6c4f9f4e557ace59c1ec">&#9670;&#160;</a></span>noc_async_read_tile_dram_sharded_with_state_with_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_tile_dram_sharded_with_state_with_trid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa006454ec0ae734836c80ecc0a4cfe18" name="aa006454ec0ae734836c80ecc0a4cfe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa006454ec0ae734836c80ecc0a4cfe18">&#9670;&#160;</a></span>noc_async_read_with_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool inc_num_issued = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_with_state </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a188eeb8f8c1f14b173ebe8c406133600" name="a188eeb8f8c1f14b173ebe8c406133600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188eeb8f8c1f14b173ebe8c406133600">&#9670;&#160;</a></span>noc_async_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call. The destination is specified using a uint64_t encoding referencing an on-chip node located at NOC coordinates (x,y) and a local address created using get_noc_addr function. Also, see <em>noc_async_write_barrier</em>.</p>
<p>The destination node can be either a DRAM bank, Tensix core+L1 memory address or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr   </td><td class="markdownTableBodyNone">Encoding of the destination NOC location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a57f29294fed4616943f1592452706467" name="a57f29294fed4616943f1592452706467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f29294fed4616943f1592452706467">&#9670;&#160;</a></span>noc_async_write_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_barrier </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_write</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="ab5abf4783385b9983021c773f47e3874" name="ab5abf4783385b9983021c773f47e3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5abf4783385b9983021c773f47e3874">&#9670;&#160;</a></span>noc_async_write_multicast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_multicast </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. Also, <em>see noc_async_write_barrier</em>.</p>
<p>The destination nodes can only be a set of Tensix cores + L1 memory address. The destination nodes must form a rectangular grid. The destination L1 memory address must be the same on all destination nodes.</p>
<p>With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.e. must perform a local L1 write), the other API variant <em>noc_async_write_multicast_loopback_src</em> can be used.</p>
<p>Note: The number of destinations needs to be non-zero. Besides that, there is no restriction on the number of destinations, i.e. the multicast destinations can span the full chip. However, as mentioned previously, the multicast source cannot be part of the destinations. So, the maximum number of destinations is number of cores - 1.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..(number of cores -1)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a378aa2e8c1468ef8ef71ad74c70315a9" name="a378aa2e8c1468ef8ef71ad74c70315a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378aa2e8c1468ef8ef71ad74c70315a9">&#9670;&#160;</a></span>noc_async_write_multicast_loopback_src()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_multicast_loopback_src </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99484885c567e016e23899f0408bd57" name="ae99484885c567e016e23899f0408bd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99484885c567e016e23899f0408bd57">&#9670;&#160;</a></span>noc_async_write_multicast_one_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_multicast_one_packet </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fff80388ddc749f68da0a8e72320a89" name="a0fff80388ddc749f68da0a8e72320a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fff80388ddc749f68da0a8e72320a89">&#9670;&#160;</a></span>noc_async_write_one_packet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_one_packet </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a107fbfba5c58e08da38918af048c8bc7" name="a107fbfba5c58e08da38918af048c8bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107fbfba5c58e08da38918af048c8bc7">&#9670;&#160;</a></span>noc_async_write_one_packet_set_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool non_posted = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_one_packet_set_state </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>vc</em> = <code><a class="el" href="dataflow__api_8h.html#a56cf50350ff87477df00fb899480ff2d">NOC_UNICAST_WRITE_VC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47736387eba0f8f4d5523a504508636d" name="a47736387eba0f8f4d5523a504508636d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47736387eba0f8f4d5523a504508636d">&#9670;&#160;</a></span>noc_async_write_one_packet_with_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool non_posted = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_one_packet_with_state </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f6b5afaf9a9f9f4d9692dcd59fc62a0" name="a4f6b5afaf9a9f9f4d9692dcd59fc62a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6b5afaf9a9f9f4d9692dcd59fc62a0">&#9670;&#160;</a></span>noc_async_write_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool DRAM, uint32_t tile_hw&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_tile </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM, tile_hw &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7075995d85a7119a04ad734bd34a4bf5" name="a7075995d85a7119a04ad734bd34a4bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7075995d85a7119a04ad734bd34a4bf5">&#9670;&#160;</a></span>noc_async_writes_flushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_writes_flushed </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to depart, but will not wait for them to complete </p>

</div>
</div>
<a id="ab5f779ea1675acf61c46613048ce96e1" name="ab5f779ea1675acf61c46613048ce96e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f779ea1675acf61c46613048ce96e1">&#9670;&#160;</a></span>noc_inline_dw_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_inline_dw_write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>be</em> = <code>0xF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write of a 32-bit value to a NOC destination. Typically used for writing registers, but can be used for memory locations as well. The destination is specified as a 64-bit NOC address (see <em>noc_async_write</em>). The advantage over using <em>noc_async_write</em> is that we don't a Tensix L1 memory source location; the write value is written directly into a register. Unlike using <em>noc_async_write</em>, there are also no address alignment concerns. Also, see <em>noc_async_write_barrier</em>.</p>
<p>The destination node can be either a DRAM bank, Tensix core+L1 memory address or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addr   </td><td class="markdownTableBodyNone">Encoding of the destination location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The value to be written   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">be   </td><td class="markdownTableBodyNone">Byte-enable   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone">0x1-0xF   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a962d804ce21d1d26ccb4241e2eb6ac9f" name="a962d804ce21d1d26ccb4241e2eb6ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962d804ce21d1d26ccb4241e2eb6ac9f">&#9670;&#160;</a></span>noc_semaphore_inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_inc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>incr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc_id</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Tensix core executing this function call initiates an atomic increment (with 32-bit wrap) of a remote Tensix core L1 memory address. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addr   </td><td class="markdownTableBodyNone">Encoding of the destination location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">incr   </td><td class="markdownTableBodyNone">The value to increment by   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af02a9af640679b00da874318535aa397" name="af02a9af640679b00da874318535aa397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02a9af640679b00da874318535aa397">&#9670;&#160;</a></span>noc_semaphore_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of a local L1 memory address on the Tensix core executing this function to a specific value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_wait</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">Value to set the semaphore to   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a125909749e0596744b6b27c288d566ce" name="a125909749e0596744b6b27c288d566ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125909749e0596744b6b27c288d566ce">&#9670;&#160;</a></span>noc_semaphore_set_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set_multicast </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as <em>noc_async_write_multicast</em> with preset size of 4 Bytes.</p>
<p>With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.e. must perform a local L1 write), the other API variant <em>noc_semaphore_set_multicast_loopback_src</em> can be used.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..(number of cores - 1)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ac0375e12b7323fe5f3e8c25a800b7882" name="ac0375e12b7323fe5f3e8c25a800b7882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0375e12b7323fe5f3e8c25a800b7882">&#9670;&#160;</a></span>noc_semaphore_set_multicast_loopback_src()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set_multicast_loopback_src </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as <em>noc_async_write_multicast</em> with preset size of 4 Bytes.</p>
<p>Note: With this API, sending data only to the source node (when num_dests is 1) may result in unexpected behaviour. For some parameters, hangs have been observed. For some other parameters, nothing may happen. Consider using regular non multicast operations such as <em>noc_async_write</em> in this case.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..(number of cores)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa85bbb469e6f0aaeabed92f4aeb6fc71" name="aa85bbb469e6f0aaeabed92f4aeb6fc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85bbb469e6f0aaeabed92f4aeb6fc71">&#9670;&#160;</a></span>noc_semaphore_set_remote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set_remote </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc</em> = <code><a class="el" href="dataflow__api_8h.html#a58bc3a01e945dbd421fce21906e94441">noc_index</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f714cc4a08a2eaac5e3f7fae9d1383a" name="a4f714cc4a08a2eaac5e3f7fae9d1383a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f714cc4a08a2eaac5e3f7fae9d1383a">&#9670;&#160;</a></span>noc_semaphore_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_wait </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The target value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a84a965a61b65152c42835f35dca007af" name="a84a965a61b65152c42835f35dca007af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a965a61b65152c42835f35dca007af">&#9670;&#160;</a></span>noc_semaphore_wait_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_wait_min </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The target value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a9e9618b5b64ed1ae0d0a747ac0f10745" name="a9e9618b5b64ed1ae0d0a747ac0f10745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9618b5b64ed1ae0d0a747ac0f10745">&#9670;&#160;</a></span>RISC_POST_HEARTBEAT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RISC_POST_HEARTBEAT </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>heartbeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2384f3c7d9784e3e662093136cbed25" name="af2384f3c7d9784e3e662093136cbed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2384f3c7d9784e3e662093136cbed25">&#9670;&#160;</a></span>wait_for_sync_register_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wait_for_sync_register_value </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a74c5ca11f2fb15c25af4a74db732a5fc" name="a74c5ca11f2fb15c25af4a74db732a5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c5ca11f2fb15c25af4a74db732a5fc">&#9670;&#160;</a></span>crta_l1_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t* crta_l1_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58bc3a01e945dbd421fce21906e94441" name="a58bc3a01e945dbd421fce21906e94441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bc3a01e945dbd421fce21906e94441">&#9670;&#160;</a></span>noc_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t noc_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfbb1273e3f29964043f4660b5c5bc1d" name="abfbb1273e3f29964043f4660b5c5bc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbb1273e3f29964043f4660b5c5bc1d">&#9670;&#160;</a></span>noc_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t noc_mode = DM_DEDICATED_NOC</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa5a15ba6d1a0359eb8270daa81f6e1a" name="afa5a15ba6d1a0359eb8270daa81f6e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5a15ba6d1a0359eb8270daa81f6e1a">&#9670;&#160;</a></span>read_cmd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t read_cmd_buf = NCRISC_RD_CMD_BUF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2366e9251332058fa1fa368903d1d760" name="a2366e9251332058fa1fa368903d1d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2366e9251332058fa1fa368903d1d760">&#9670;&#160;</a></span>rta_l1_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t* rta_l1_base</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237705982b987907cbfca699e32a9c64" name="a237705982b987907cbfca699e32a9c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237705982b987907cbfca699e32a9c64">&#9670;&#160;</a></span>sem_l1_base</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t* sem_l1_base[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27c097a6b6c3174e4b39fa61e1aed761" name="a27c097a6b6c3174e4b39fa61e1aed761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c097a6b6c3174e4b39fa61e1aed761">&#9670;&#160;</a></span>write_at_cmd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t write_at_cmd_buf = NCRISC_AT_CMD_BUF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae53f3d62ad6a9eeabe5f4604e3e9b13f" name="ae53f3d62ad6a9eeabe5f4604e3e9b13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53f3d62ad6a9eeabe5f4604e3e9b13f">&#9670;&#160;</a></span>write_cmd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t write_cmd_buf = NCRISC_WR_CMD_BUF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c97896ab8cfddde7d4951cd6f947e0f" name="a6c97896ab8cfddde7d4951cd6f947e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c97896ab8cfddde7d4951cd6f947e0f">&#9670;&#160;</a></span>write_reg_cmd_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t write_reg_cmd_buf = NCRISC_WR_REG_CMD_BUF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
