<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: tt_metal/hw/inc/dataflow_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4fb3d687a4ff02ddb63514ccf23d36f6.html">tt_metal</a></li><li class="navelem"><a class="el" href="dir_07501e64483735e0a95f07c3cb2b524b.html">hw</a></li><li class="navelem"><a class="el" href="dir_61791e9474c0a658d41561dafd5664de.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">dataflow_api.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;core_config.h&quot;</code><br />
<code>#include &quot;circular_buffer.h&quot;</code><br />
<code>#include &quot;debug/sanitize_noc.h&quot;</code><br />
<code>#include &quot;debug/waypoint.h&quot;</code><br />
<code>#include &quot;eth_l1_address_map.h&quot;</code><br />
<code>#include &quot;hostdevcommon/common_runtime_address_map.h&quot;</code><br />
<code>#include &quot;hostdevcommon/common_values.hpp&quot;</code><br />
<code>#include &quot;risc_attribs.h&quot;</code><br />
<code>#include &quot;third_party/umd/device/tt_silicon_driver_common.hpp&quot;</code><br />
<code>#include &quot;debug/assert.h&quot;</code><br />
<code>#include &quot;dev_msgs.h&quot;</code><br />
</div>
<p><a href="dataflow__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedPow2AddrGen.html">InterleavedPow2AddrGen&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterleavedPow2AddrGenFast.html">InterleavedPow2AddrGenFast&lt; DRAM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a56cf50350ff87477df00fb899480ff2d"><td class="memItemLeft" align="right" valign="top"><a id="a56cf50350ff87477df00fb899480ff2d" name="a56cf50350ff87477df00fb899480ff2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOC_UNICAST_WRITE_VC</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a56cf50350ff87477df00fb899480ff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb39d71d6c419e9ad7aa0f43e5a91d8"><td class="memItemLeft" align="right" valign="top"><a id="a5fb39d71d6c419e9ad7aa0f43e5a91d8" name="a5fb39d71d6c419e9ad7aa0f43e5a91d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOC_MULTICAST_WRITE_VC</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a5fb39d71d6c419e9ad7aa0f43e5a91d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49104913a904db0ef5c642d10a33c923"><td class="memItemLeft" align="right" valign="top"><a id="a49104913a904db0ef5c642d10a33c923" name="a49104913a904db0ef5c642d10a33c923"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOC_DISPATCH_MULTICAST_WRITE_VC</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a49104913a904db0ef5c642d10a33c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f9dbfbb4150cb324f21520b8e6cfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab97f9dbfbb4150cb324f21520b8e6cfe">get_compile_time_arg_val</a>(arg_idx)&#160;&#160;&#160;KERNEL_COMPILE_TIME_ARG_##arg_idx</td></tr>
<tr class="separator:ab97f9dbfbb4150cb324f21520b8e6cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac4752c4d9a07974ce99aaa671a675fe2"><td class="memItemLeft" align="right" valign="top"><a id="ac4752c4d9a07974ce99aaa671a675fe2" name="ac4752c4d9a07974ce99aaa671a675fe2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (uint32_t addr, uint32_t alignment)</td></tr>
<tr class="separator:ac4752c4d9a07974ce99aaa671a675fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4018be9d6302207fdc0dac085663e184"><td class="memTemplParams" colspan="2"><a id="a4018be9d6302207fdc0dac085663e184" name="a4018be9d6302207fdc0dac085663e184"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a4018be9d6302207fdc0dac085663e184"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interleaved_addr_gen::get_bank_offset_index</b> (uint32_t id)</td></tr>
<tr class="separator:a4018be9d6302207fdc0dac085663e184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63194c761e19c2a9d096f91c9e9be63c"><td class="memTemplParams" colspan="2"><a id="a63194c761e19c2a9d096f91c9e9be63c" name="a63194c761e19c2a9d096f91c9e9be63c"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a63194c761e19c2a9d096f91c9e9be63c"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interleaved_addr_gen::get_bank_index</b> (uint32_t id, uint32_t bank_offset_index)</td></tr>
<tr class="separator:a63194c761e19c2a9d096f91c9e9be63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7581885ee418929f06551a5e8f9649c2"><td class="memTemplParams" colspan="2"><a id="a7581885ee418929f06551a5e8f9649c2" name="a7581885ee418929f06551a5e8f9649c2"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a7581885ee418929f06551a5e8f9649c2"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interleaved_addr_gen::get_noc_xy</b> (uint32_t bank_index)</td></tr>
<tr class="separator:a7581885ee418929f06551a5e8f9649c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memTemplParams" colspan="2"><a id="a593eecf4e9f53608d0c5c82e54b36b03" name="a593eecf4e9f53608d0c5c82e54b36b03"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>interleaved_addr_gen::get_bank_offset</b> (uint32_t bank_index)</td></tr>
<tr class="separator:a593eecf4e9f53608d0c5c82e54b36b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a6a5074e8cd2732fcecab57fced3ebd1f">get_arg_val</a> (int arg_idx)</td></tr>
<tr class="separator:a6a5074e8cd2732fcecab57fced3ebd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba486e3732fb5ea715651f92234e60a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abba486e3732fb5ea715651f92234e60a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#abba486e3732fb5ea715651f92234e60a">get_common_arg_val</a> (int arg_idx)</td></tr>
<tr class="separator:abba486e3732fb5ea715651f92234e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81357224b88562601b42833eec676ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a81357224b88562601b42833eec676ffb">cb_push_back</a> (const int32_t operand, const int32_t num_pages)</td></tr>
<tr class="separator:a81357224b88562601b42833eec676ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3daf8e5e7299140cf2607be1a8656b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aa3daf8e5e7299140cf2607be1a8656b0">cb_pop_front</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:aa3daf8e5e7299140cf2607be1a8656b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a1a9478a83ad216d826dc5f783d1f8"><td class="memItemLeft" align="right" valign="top"><a id="af4a1a9478a83ad216d826dc5f783d1f8" name="af4a1a9478a83ad216d826dc5f783d1f8"></a>
constexpr std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_tile_size</b> (const std::int32_t operand)</td></tr>
<tr class="separator:af4a1a9478a83ad216d826dc5f783d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae214b6c2f978e745f9c24d397dad906d"><td class="memItemLeft" align="right" valign="top"><a id="ae214b6c2f978e745f9c24d397dad906d" name="ae214b6c2f978e745f9c24d397dad906d"></a>
constexpr DataFormat&#160;</td><td class="memItemRight" valign="bottom"><b>get_dataformat</b> (const std::int32_t operand)</td></tr>
<tr class="separator:ae214b6c2f978e745f9c24d397dad906d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593e43aff0c85e4b3f86d13f1d7350dd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a593e43aff0c85e4b3f86d13f1d7350dd">get_write_ptr</a> (uint32_t operand)</td></tr>
<tr class="separator:a593e43aff0c85e4b3f86d13f1d7350dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a31715a14cea1a63cbdca8c99b0827"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a66a31715a14cea1a63cbdca8c99b0827">get_read_ptr</a> (uint32_t operand)</td></tr>
<tr class="separator:a66a31715a14cea1a63cbdca8c99b0827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2384f3c7d9784e3e662093136cbed25"><td class="memItemLeft" align="right" valign="top"><a id="af2384f3c7d9784e3e662093136cbed25" name="af2384f3c7d9784e3e662093136cbed25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait_for_sync_register_value</b> (uint32_t addr, int32_t val)</td></tr>
<tr class="separator:af2384f3c7d9784e3e662093136cbed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29521dee07b0070674a988f66c01ffed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a29521dee07b0070674a988f66c01ffed">cb_reserve_back</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:a29521dee07b0070674a988f66c01ffed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8057bd05a650c3501c5208f7d9f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af6d8057bd05a650c3501c5208f7d9f8a">cb_wait_front</a> (int32_t operand, int32_t num_pages)</td></tr>
<tr class="separator:af6d8057bd05a650c3501c5208f7d9f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4374fb8ab97c23045cf3f9dd8e1615f"><td class="memItemLeft" align="right" valign="top"><a id="ae4374fb8ab97c23045cf3f9dd8e1615f" name="ae4374fb8ab97c23045cf3f9dd8e1615f"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_noc_multicast_addr</b> (std::uint32_t noc_x_start, std::uint32_t noc_y_start, std::uint32_t noc_x_end, std::uint32_t noc_y_end, std::uint32_t addr)</td></tr>
<tr class="separator:ae4374fb8ab97c23045cf3f9dd8e1615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6080fdaa08b51535164a0b439599c2b2"><td class="memItemLeft" align="right" valign="top"><a id="a6080fdaa08b51535164a0b439599c2b2" name="a6080fdaa08b51535164a0b439599c2b2"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_noc_addr</b> (std::uint32_t noc_x, std::uint32_t noc_y, std::uint32_t addr)</td></tr>
<tr class="separator:a6080fdaa08b51535164a0b439599c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa850145f50aafa428c0d257cfed4fb8c"><td class="memItemLeft" align="right" valign="top"><a id="aa850145f50aafa428c0d257cfed4fb8c" name="aa850145f50aafa428c0d257cfed4fb8c"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_noc_addr_helper</b> (std::uint32_t noc_xy, std::uint32_t addr)</td></tr>
<tr class="separator:aa850145f50aafa428c0d257cfed4fb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0d056dcf68dc0d8745c6eb6d6b36ef"><td class="memItemLeft" align="right" valign="top"><a id="aba0d056dcf68dc0d8745c6eb6d6b36ef" name="aba0d056dcf68dc0d8745c6eb6d6b36ef"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_dram_noc_addr</b> (const uint32_t id, const uint32_t page_size, const uint32_t bank_base_address, const uint32_t offset=0)</td></tr>
<tr class="separator:aba0d056dcf68dc0d8745c6eb6d6b36ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcec950f39f40599c5c01a66d1055e1"><td class="memItemLeft" align="right" valign="top"><a id="aefcec950f39f40599c5c01a66d1055e1" name="aefcec950f39f40599c5c01a66d1055e1"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_l1_noc_addr</b> (const uint32_t id, const uint32_t page_size, const uint32_t bank_base_address, const uint32_t offset=0)</td></tr>
<tr class="separator:aefcec950f39f40599c5c01a66d1055e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cea6159b23fc89dcfb5daa668439d1c"><td class="memItemLeft" align="right" valign="top"><a id="a6cea6159b23fc89dcfb5daa668439d1c" name="a6cea6159b23fc89dcfb5daa668439d1c"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_system_memory_noc_addr</b> (const uint32_t id, const uint32_t page_size, const uint32_t base_addr, const uint32_t offset=0)</td></tr>
<tr class="separator:a6cea6159b23fc89dcfb5daa668439d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2336f9ac51bfd90b0393665f608785f"><td class="memItemLeft" align="right" valign="top"><a id="ab2336f9ac51bfd90b0393665f608785f" name="ab2336f9ac51bfd90b0393665f608785f"></a>
std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_noc_addr</b> (std::uint32_t addr)</td></tr>
<tr class="separator:ab2336f9ac51bfd90b0393665f608785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97e89d297b36a2143d7f57011dd7ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab97e89d297b36a2143d7f57011dd7ec5">noc_async_read</a> (std::uint64_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size)</td></tr>
<tr class="separator:ab97e89d297b36a2143d7f57011dd7ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2263fe3188c0629cc6c40c30ad8dc27"><td class="memItemLeft" align="right" valign="top"><a id="ad2263fe3188c0629cc6c40c30ad8dc27" name="ad2263fe3188c0629cc6c40c30ad8dc27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_one_packet</b> (std::uint64_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size)</td></tr>
<tr class="separator:ad2263fe3188c0629cc6c40c30ad8dc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dd39896c00012bcafdbff681f456be"><td class="memItemLeft" align="right" valign="top"><a id="aa5dd39896c00012bcafdbff681f456be" name="aa5dd39896c00012bcafdbff681f456be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_one_packet_set_state</b> (std::uint64_t src_noc_addr, std::uint32_t size)</td></tr>
<tr class="separator:aa5dd39896c00012bcafdbff681f456be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf12fff178e5ec0115fcd9c503835bfe"><td class="memTemplParams" colspan="2"><a id="abf12fff178e5ec0115fcd9c503835bfe" name="abf12fff178e5ec0115fcd9c503835bfe"></a>
template&lt;bool inc_num_issued = true&gt; </td></tr>
<tr class="memitem:abf12fff178e5ec0115fcd9c503835bfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_read_one_packet_with_state</b> (std::uint32_t src_noc_addr, std::uint32_t dst_local_l1_addr)</td></tr>
<tr class="separator:abf12fff178e5ec0115fcd9c503835bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc73bc75c5461bec168e308cc4dac463"><td class="memItemLeft" align="right" valign="top"><a id="abc73bc75c5461bec168e308cc4dac463" name="abc73bc75c5461bec168e308cc4dac463"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_set_state</b> (std::uint64_t src_noc_addr)</td></tr>
<tr class="separator:abc73bc75c5461bec168e308cc4dac463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0190364ed02bd2ebd4ad9dcaf66606"><td class="memTemplParams" colspan="2"><a id="a5f0190364ed02bd2ebd4ad9dcaf66606" name="a5f0190364ed02bd2ebd4ad9dcaf66606"></a>
template&lt;bool inc_num_issued = true&gt; </td></tr>
<tr class="memitem:a5f0190364ed02bd2ebd4ad9dcaf66606"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_read_with_state</b> (std::uint32_t src_noc_addr, std::uint32_t dst_local_l1_addr, std::uint32_t size)</td></tr>
<tr class="separator:a5f0190364ed02bd2ebd4ad9dcaf66606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258a390cad1838db7970453230d3f20"><td class="memItemLeft" align="right" valign="top"><a id="a4258a390cad1838db7970453230d3f20" name="a4258a390cad1838db7970453230d3f20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_inc_num_issued</b> (std::uint32_t num_issued_reads_inc)</td></tr>
<tr class="separator:a4258a390cad1838db7970453230d3f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2e10391566bc043956841d26c2b96a"><td class="memItemLeft" align="right" valign="top"><a id="ace2e10391566bc043956841d26c2b96a" name="ace2e10391566bc043956841d26c2b96a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_write_one_packet</b> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr, std::uint32_t size)</td></tr>
<tr class="separator:ace2e10391566bc043956841d26c2b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243f72eb0de9e7694030ecabbdd55441"><td class="memItemLeft" align="right" valign="top"><a id="a243f72eb0de9e7694030ecabbdd55441" name="a243f72eb0de9e7694030ecabbdd55441"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_write_multicast_one_packet</b> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true)</td></tr>
<tr class="separator:a243f72eb0de9e7694030ecabbdd55441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5d48b77f56a10bf3edba5d5907ea25"><td class="memTemplParams" colspan="2"><a id="a5e5d48b77f56a10bf3edba5d5907ea25" name="a5e5d48b77f56a10bf3edba5d5907ea25"></a>
template&lt;bool non_posted = true&gt; </td></tr>
<tr class="memitem:a5e5d48b77f56a10bf3edba5d5907ea25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_write_one_packet_set_state</b> (std::uint64_t dst_noc_addr, std::uint32_t size)</td></tr>
<tr class="separator:a5e5d48b77f56a10bf3edba5d5907ea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bf42adaae3e6926445b84e7c30e20e"><td class="memTemplParams" colspan="2"><a id="a99bf42adaae3e6926445b84e7c30e20e" name="a99bf42adaae3e6926445b84e7c30e20e"></a>
template&lt;bool non_posted = true&gt; </td></tr>
<tr class="memitem:a99bf42adaae3e6926445b84e7c30e20e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_write_one_packet_with_state</b> (std::uint32_t src_local_l1_addr, std::uint32_t dst_noc_addr)</td></tr>
<tr class="separator:a99bf42adaae3e6926445b84e7c30e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5989f91beb6b0ab26d115ac12fe6f"><td class="memTemplParams" colspan="2"><a id="aacf5989f91beb6b0ab26d115ac12fe6f" name="aacf5989f91beb6b0ab26d115ac12fe6f"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:aacf5989f91beb6b0ab26d115ac12fe6f"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_noc_addr</b> (const uint32_t id, const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;s, uint32_t offset=0)</td></tr>
<tr class="separator:aacf5989f91beb6b0ab26d115ac12fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca192ad50dc46eabb2688cf1e0f0575"><td class="memTemplParams" colspan="2"><a id="a1ca192ad50dc46eabb2688cf1e0f0575" name="a1ca192ad50dc46eabb2688cf1e0f0575"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:a1ca192ad50dc46eabb2688cf1e0f0575"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_noc_addr</b> (const uint32_t id, const <a class="el" href="structInterleavedPow2AddrGen.html">InterleavedPow2AddrGen</a>&lt; DRAM &gt; &amp;s, uint32_t offset=0)</td></tr>
<tr class="separator:a1ca192ad50dc46eabb2688cf1e0f0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ebbce5f15ef2a4999f983a7d13fe0"><td class="memTemplParams" colspan="2"><a id="aee5ebbce5f15ef2a4999f983a7d13fe0" name="aee5ebbce5f15ef2a4999f983a7d13fe0"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:aee5ebbce5f15ef2a4999f983a7d13fe0"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_noc_addr</b> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM &gt; &amp;s, uint32_t offset=0)</td></tr>
<tr class="separator:aee5ebbce5f15ef2a4999f983a7d13fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa628194296041838dd0512194f78cb4b"><td class="memTemplParams" colspan="2"><a id="aa628194296041838dd0512194f78cb4b" name="aa628194296041838dd0512194f78cb4b"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:aa628194296041838dd0512194f78cb4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_read_page</b> (const uint32_t id, const <a class="el" href="structInterleavedAddrGen.html">InterleavedAddrGen</a>&lt; DRAM &gt; &amp;s, std::uint32_t dst_local_l1_addr, uint32_t offset=0)</td></tr>
<tr class="separator:aa628194296041838dd0512194f78cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74a8d9d97b2e7d1c15454db2c7d7431"><td class="memTemplParams" colspan="2"><a id="ab74a8d9d97b2e7d1c15454db2c7d7431" name="ab74a8d9d97b2e7d1c15454db2c7d7431"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:ab74a8d9d97b2e7d1c15454db2c7d7431"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_read_tile</b> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM &gt; &amp;s, std::uint32_t dst_local_l1_addr, uint32_t offset=0)</td></tr>
<tr class="separator:ab74a8d9d97b2e7d1c15454db2c7d7431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5353d488f5a68e6eb89fae5ea1be951"><td class="memTemplParams" colspan="2">template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </td></tr>
<tr class="memitem:ae5353d488f5a68e6eb89fae5ea1be951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ae5353d488f5a68e6eb89fae5ea1be951">noc_async_write</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr, std::uint32_t size)</td></tr>
<tr class="separator:ae5353d488f5a68e6eb89fae5ea1be951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1c9f72ce143d24b995167a49eff5e4"><td class="memTemplParams" colspan="2"><a id="afa1c9f72ce143d24b995167a49eff5e4" name="afa1c9f72ce143d24b995167a49eff5e4"></a>
template&lt;bool DRAM&gt; </td></tr>
<tr class="memitem:afa1c9f72ce143d24b995167a49eff5e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_write_tile</b> (const uint32_t id, const <a class="el" href="structInterleavedAddrGenFast.html">InterleavedAddrGenFast</a>&lt; DRAM &gt; &amp;s, std::uint32_t src_local_l1_addr)</td></tr>
<tr class="separator:afa1c9f72ce143d24b995167a49eff5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memTemplParams" colspan="2"><a id="aad24ffd7fc05b797ce38e6072c2f0eab" name="aad24ffd7fc05b797ce38e6072c2f0eab"></a>
template&lt;ProgrammableCoreType type = ProgrammableCoreType::TENSIX&gt; </td></tr>
<tr class="memitem:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_semaphore</b> (uint32_t semaphore_id)</td></tr>
<tr class="separator:aad24ffd7fc05b797ce38e6072c2f0eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff57d6bb75c161882cd3751a3f4a67ba"><td class="memItemLeft" align="right" valign="top"><a id="aff57d6bb75c161882cd3751a3f4a67ba" name="aff57d6bb75c161882cd3751a3f4a67ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_semaphore_set_remote</b> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr)</td></tr>
<tr class="separator:aff57d6bb75c161882cd3751a3f4a67ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb548dd7fb5654248c32b147531c8d2"><td class="memTemplParams" colspan="2">template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </td></tr>
<tr class="memitem:aebb548dd7fb5654248c32b147531c8d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#aebb548dd7fb5654248c32b147531c8d2">noc_async_write_multicast</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true)</td></tr>
<tr class="separator:aebb548dd7fb5654248c32b147531c8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1debd77eb9592540a899290fb2a1709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af1debd77eb9592540a899290fb2a1709">noc_semaphore_set_multicast</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true)</td></tr>
<tr class="separator:af1debd77eb9592540a899290fb2a1709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab629fc4e0e17a8ed09e5a6b264927b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#ab629fc4e0e17a8ed09e5a6b264927b18">noc_semaphore_set_multicast_loopback_src</a> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true)</td></tr>
<tr class="separator:ab629fc4e0e17a8ed09e5a6b264927b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac57ae59ef98d40b2081b80e5636d20"><td class="memItemLeft" align="right" valign="top"><a id="a4ac57ae59ef98d40b2081b80e5636d20" name="a4ac57ae59ef98d40b2081b80e5636d20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_write_multicast_loopback_src</b> (std::uint32_t src_local_l1_addr, std::uint64_t dst_noc_addr_multicast, std::uint32_t size, std::uint32_t num_dests, bool linked=false, bool multicast_path_reserve=true)</td></tr>
<tr class="separator:a4ac57ae59ef98d40b2081b80e5636d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da61f7d36de3d865b04acf3656c7950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a8da61f7d36de3d865b04acf3656c7950">noc_async_read_barrier</a> ()</td></tr>
<tr class="separator:a8da61f7d36de3d865b04acf3656c7950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1af3e9115ddcd9d2e4b0c8b4a4b680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a8a1af3e9115ddcd9d2e4b0c8b4a4b680">noc_async_write_barrier</a> ()</td></tr>
<tr class="separator:a8a1af3e9115ddcd9d2e4b0c8b4a4b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c38db0fda2eaafccd0aac9635f0dc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a82c38db0fda2eaafccd0aac9635f0dc1">noc_async_writes_flushed</a> ()</td></tr>
<tr class="separator:a82c38db0fda2eaafccd0aac9635f0dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a74d46d62931d19a406414db103c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a13a74d46d62931d19a406414db103c4b">noc_async_atomic_barrier</a> (uint8_t noc_idx=noc_index)</td></tr>
<tr class="separator:a13a74d46d62931d19a406414db103c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f714cc4a08a2eaac5e3f7fae9d1383a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a4f714cc4a08a2eaac5e3f7fae9d1383a">noc_semaphore_wait</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:a4f714cc4a08a2eaac5e3f7fae9d1383a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a965a61b65152c42835f35dca007af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a84a965a61b65152c42835f35dca007af">noc_semaphore_wait_min</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:a84a965a61b65152c42835f35dca007af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02a9af640679b00da874318535aa397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#af02a9af640679b00da874318535aa397">noc_semaphore_set</a> (volatile uint32_t *sem_addr, uint32_t val)</td></tr>
<tr class="separator:af02a9af640679b00da874318535aa397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f11981622b01c9e42d44a939ec30be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a1f11981622b01c9e42d44a939ec30be1">noc_inline_dw_write</a> (uint64_t addr, uint32_t val, uint8_t be=0xF)</td></tr>
<tr class="separator:a1f11981622b01c9e42d44a939ec30be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962d804ce21d1d26ccb4241e2eb6ac9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dataflow__api_8h.html#a962d804ce21d1d26ccb4241e2eb6ac9f">noc_semaphore_inc</a> (uint64_t addr, uint32_t incr, uint8_t noc_id=noc_index)</td></tr>
<tr class="separator:a962d804ce21d1d26ccb4241e2eb6ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9618b5b64ed1ae0d0a747ac0f10745"><td class="memItemLeft" align="right" valign="top"><a id="a9e9618b5b64ed1ae0d0a747ac0f10745" name="a9e9618b5b64ed1ae0d0a747ac0f10745"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RISC_POST_HEARTBEAT</b> (uint32_t &amp;heartbeat)</td></tr>
<tr class="separator:a9e9618b5b64ed1ae0d0a747ac0f10745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bd290aaee1b41529717b029dc14952"><td class="memItemLeft" align="right" valign="top"><a id="a29bd290aaee1b41529717b029dc14952" name="a29bd290aaee1b41529717b029dc14952"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> (uint32_t a, uint32_t b)</td></tr>
<tr class="separator:a29bd290aaee1b41529717b029dc14952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de16ed70bc7231b31eb861b6d0a6842"><td class="memTemplParams" colspan="2"><a id="a0de16ed70bc7231b31eb861b6d0a6842" name="a0de16ed70bc7231b31eb861b6d0a6842"></a>
template&lt;uint32_t page_size, bool use_vc&gt; </td></tr>
<tr class="memitem:a0de16ed70bc7231b31eb861b6d0a6842"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noc_async_read_tile_dram_sharded_set_state</b> (uint32_t bank_base_address, uint32_t bank_id=0, const uint32_t vc=0)</td></tr>
<tr class="separator:a0de16ed70bc7231b31eb861b6d0a6842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907a8339412ff90e99743a4ca71af910"><td class="memItemLeft" align="right" valign="top"><a id="a907a8339412ff90e99743a4ca71af910" name="a907a8339412ff90e99743a4ca71af910"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_tile_dram_sharded_with_state</b> (uint32_t src_base_addr, uint32_t src_addr, uint32_t dest_addr, uint32_t trid=0)</td></tr>
<tr class="separator:a907a8339412ff90e99743a4ca71af910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c034dfaaa6b841194aab8e7d5ec42"><td class="memItemLeft" align="right" valign="top"><a id="ae92c034dfaaa6b841194aab8e7d5ec42" name="ae92c034dfaaa6b841194aab8e7d5ec42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_tile_dram_sharded_with_state_with_trid</b> (uint32_t src_base_addr, uint32_t src_addr, uint32_t dest_addr, uint32_t trid=0)</td></tr>
<tr class="separator:ae92c034dfaaa6b841194aab8e7d5ec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799ce34e86a34e05f3dd8f30cf958378"><td class="memItemLeft" align="right" valign="top"><a id="a799ce34e86a34e05f3dd8f30cf958378" name="a799ce34e86a34e05f3dd8f30cf958378"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_tile_dram_sharded_set_trid</b> (uint32_t trid=0)</td></tr>
<tr class="separator:a799ce34e86a34e05f3dd8f30cf958378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5515ebbed8b273697e2f44894cf3be28"><td class="memItemLeft" align="right" valign="top"><a id="a5515ebbed8b273697e2f44894cf3be28" name="a5515ebbed8b273697e2f44894cf3be28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>noc_async_read_barrier_with_trid</b> (uint32_t trid)</td></tr>
<tr class="separator:a5515ebbed8b273697e2f44894cf3be28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a58bc3a01e945dbd421fce21906e94441"><td class="memItemLeft" align="right" valign="top"><a id="a58bc3a01e945dbd421fce21906e94441" name="a58bc3a01e945dbd421fce21906e94441"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>noc_index</b></td></tr>
<tr class="separator:a58bc3a01e945dbd421fce21906e94441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2366e9251332058fa1fa368903d1d760"><td class="memItemLeft" align="right" valign="top"><a id="a2366e9251332058fa1fa368903d1d760" name="a2366e9251332058fa1fa368903d1d760"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>rta_l1_base</b></td></tr>
<tr class="separator:a2366e9251332058fa1fa368903d1d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c5ca11f2fb15c25af4a74db732a5fc"><td class="memItemLeft" align="right" valign="top"><a id="a74c5ca11f2fb15c25af4a74db732a5fc" name="a74c5ca11f2fb15c25af4a74db732a5fc"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>crta_l1_base</b></td></tr>
<tr class="separator:a74c5ca11f2fb15c25af4a74db732a5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237705982b987907cbfca699e32a9c64"><td class="memItemLeft" align="right" valign="top"><a id="a237705982b987907cbfca699e32a9c64" name="a237705982b987907cbfca699e32a9c64"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>sem_l1_base</b> []</td></tr>
<tr class="separator:a237705982b987907cbfca699e32a9c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab97f9dbfbb4150cb324f21520b8e6cfe" name="ab97f9dbfbb4150cb324f21520b8e6cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f9dbfbb4150cb324f21520b8e6cfe">&#9670;&#160;</a></span>get_compile_time_arg_val</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define get_compile_time_arg_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg_idx</td><td>)</td>
          <td>&#160;&#160;&#160;KERNEL_COMPILE_TIME_ARG_##arg_idx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of a constexpr argument from kernel_compile_time_args array provided during kernel creation using CreateKernel calls.</p>
<p>Return value: constexpr uint32_t</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">The index of the argument   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa3daf8e5e7299140cf2607be1a8656b0" name="aa3daf8e5e7299140cf2607be1a8656b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3daf8e5e7299140cf2607be1a8656b0">&#9670;&#160;</a></span>cb_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_pop_front </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops a specified number of tiles from the front of the specified CB. This also frees this number of tiles in the circular buffer. This call is used by the consumer to free up the space in the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of reading of the tile data from the CB does not free up the space in the CB. Waiting on available tiles and popping them is separated in order to allow the consumer to: 1) read the tile data from the CB via multiple reads of sub-tiles 2) access the tiles (or their sub-tiles) that are visible to the consumer by random access of the valid section of the CB</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to be popped   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a81357224b88562601b42833eec676ffb" name="a81357224b88562601b42833eec676ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81357224b88562601b42833eec676ffb">&#9670;&#160;</a></span>cb_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_push_back </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a given number of tiles in the back of the specified CB’s queue. Decreases the available space in the circular buffer by this number of tiles. This call is used by the producer to make the tiles visible to the consumer of the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of writing the tile data into the CB does not make the tiles visible to the consumer. Writing of the tiles and pushing is separated to allow the producer to: 1) write the tile data to the CB via multiple writes of sub-tiles 2) modify tiles (or sub-tiles) by random access of the valid section of the CB</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to be pushed   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a29521dee07b0070674a988f66c01ffed" name="a29521dee07b0070674a988f66c01ffed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29521dee07b0070674a988f66c01ffed">&#9670;&#160;</a></span>cb_reserve_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_reserve_back </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be free in the specified circular buffer. This call is used by the producer to wait for the consumer to consume (ie. free up) the specified number of tiles.</p>
<p>CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of free tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af6d8057bd05a650c3501c5208f7d9f8a" name="af6d8057bd05a650c3501c5208f7d9f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d8057bd05a650c3501c5208f7d9f8a">&#9670;&#160;</a></span>cb_wait_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cb_wait_front </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be available in the specified circular buffer (CB). This call is used by the consumer of the CB to wait for the producer to fill the CB with at least the specified number of tiles. Important note: in case multiple calls of cb_wait_front(n) are issued without a paired <a class="el" href="dataflow__api_8h.html#aa3daf8e5e7299140cf2607be1a8656b0">cb_pop_front()</a> call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example: 4 calls of cb_wait_front(8) followed by a cb_pop_front(32) would produce incorrect behavior. Instead 4 calls of <a class="el" href="dataflow__api_8h.html#af6d8057bd05a650c3501c5208f7d9f8a">cb_wait_front()</a> waiting on 8, 16, 24, 32 tiles should be issued.</p>
<p>Important note: number of tiles used in all cb_* calls must evenly divide the cb size and must be the same number in all cb_wait_front calls in the same kernel. Example 1: cb_wait_front(32), cb_wait_front(40), cb_pop_front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2: cb_wait_front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.</p>
<p>Important note: CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_tiles   </td><td class="markdownTableBodyNone">The number of tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone"></td></tr>
</table>

</div>
</div>
<a id="a6a5074e8cd2732fcecab57fced3ebd1f" name="a6a5074e8cd2732fcecab57fced3ebd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5074e8cd2732fcecab57fced3ebd1f">&#9670;&#160;</a></span>get_arg_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_arg_val </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a given runtime argument index for unique (per-core) runtime arguments set via SetRuntimeArgs() API.</p>
<p>Return value: The value associated with the unique runtime argument index</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">Unique Runtime argument index   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 255   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">T (template argument)   </td><td class="markdownTableBodyNone">Data type of the returned argument   </td><td class="markdownTableBodyNone">Any 4-byte sized type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="abba486e3732fb5ea715651f92234e60a" name="abba486e3732fb5ea715651f92234e60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba486e3732fb5ea715651f92234e60a">&#9670;&#160;</a></span>get_common_arg_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_common_arg_val </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a given runtime argument index for common (all cores) runtime arguments set via SetCommonRuntimeArgs() API.</p>
<p>Return value: The value associated with the common runtime argument index</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">arg_idx   </td><td class="markdownTableBodyNone">Common Runtime argument index   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 255   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">T (template argument)   </td><td class="markdownTableBodyNone">Data type of the returned argument   </td><td class="markdownTableBodyNone">Any 4-byte sized type   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a66a31715a14cea1a63cbdca8c99b0827" name="a66a31715a14cea1a63cbdca8c99b0827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a31715a14cea1a63cbdca8c99b0827">&#9670;&#160;</a></span>get_read_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_read_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of a memory block previously received by cb_wait_front. Note that this call is only valid between calls to cb_wait_front and cb_pop_front. The amount of valid memory is equal to the number of tiles requested in a prior cb_wait_front call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">operand   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a593e43aff0c85e4b3f86d13f1d7350dd" name="a593e43aff0c85e4b3f86d13f1d7350dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593e43aff0c85e4b3f86d13f1d7350dd">&#9670;&#160;</a></span>get_write_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_write_ptr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the beginning of a memory block previously reserved by cb_reserve_back. Note that this call is only valid between calls to cb_reserve_back and cb_push_back. The amount of valid memory is equal to the number of tiles requested in a prior cb_reserve_back call.</p>
<p>CB total size must be an even multiple of this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">operand   </td><td class="markdownTableBodyNone">The index of the circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a13a74d46d62931d19a406414db103c4b" name="a13a74d46d62931d19a406414db103c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a74d46d62931d19a406414db103c4b">&#9670;&#160;</a></span>noc_async_atomic_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_atomic_barrier </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc_idx</em> = <code>noc_index</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_write</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="ab97e89d297b36a2143d7f57011dd7ec5" name="ab97e89d297b36a2143d7f57011dd7ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97e89d297b36a2143d7f57011dd7ec5">&#9670;&#160;</a></span>noc_async_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>src_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>dst_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous read from a specified source node located at NOC coordinates (x,y) at a local address (encoded as a uint64_t using <em>get_noc_addr</em> function). The destination is in L1 memory on the Tensix core executing this function call. Also, see <em>noc_async_read_barrier</em>.</p>
<p>The source node can be either a DRAM bank, a Tensix core or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Data type   </th><th class="markdownTableHeadNone">Valid range   </th><th class="markdownTableHeadNone">required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_noc_addr   </td><td class="markdownTableBodyNone">Encoding of the source NOC location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(ref to explain valid coords)   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_local_l1_addr   </td><td class="markdownTableBodyNone">Address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a8da61f7d36de3d865b04acf3656c7950" name="a8da61f7d36de3d865b04acf3656c7950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da61f7d36de3d865b04acf3656c7950">&#9670;&#160;</a></span>noc_async_read_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_read_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_read</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_read</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="ae5353d488f5a68e6eb89fae5ea1be951" name="ae5353d488f5a68e6eb89fae5ea1be951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5353d488f5a68e6eb89fae5ea1be951">&#9670;&#160;</a></span>noc_async_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call. The destination is specified using a uint64_t encoding referencing an on-chip node located at NOC coordinates (x,y) and a local address created using get_noc_addr function. Also, see <em>noc_async_write_barrier</em>.</p>
<p>The destination node can be either a DRAM bank, Tensix core+L1 memory address or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr   </td><td class="markdownTableBodyNone">Encoding of the destination NOC location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a8a1af3e9115ddcd9d2e4b0c8b4a4b680" name="a8a1af3e9115ddcd9d2e4b0c8b4a4b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1af3e9115ddcd9d2e4b0c8b4a4b680">&#9670;&#160;</a></span>noc_async_write_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all the outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to complete. After returning from this call the <em>noc_async_write</em> queue will be empty for the current Tensix core.</p>
<p>Return value: None </p>

</div>
</div>
<a id="aebb548dd7fb5654248c32b147531c8d2" name="aebb548dd7fb5654248c32b147531c8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb548dd7fb5654248c32b147531c8d2">&#9670;&#160;</a></span>noc_async_write_multicast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t max_page_size = NOC_MAX_BURST_SIZE + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_write_multicast </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. Also, <em>see noc_async_write_barrier</em>.</p>
<p>The destination nodes can only be a set of Tensix cores + L1 memory address. The destination nodes must form a rectangular grid. The destination L1 memory address must be the same on all destination nodes.</p>
<p>With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.e. must perform a local L1 write), the other API variant <em>noc_async_write_multicast_loopback_src</em> can be used.</p>
<p>Note: The number of destinations needs to be non-zero. Besides that, there is no restriction on the number of destinations, i.e. the multicast destinations can span the full chip. However, as mentioned previously, the multicast source cannot be part of the destinations. So, the maximum number of destinations is 119.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size   </td><td class="markdownTableBodyNone">Size of data transfer in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..119   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a82c38db0fda2eaafccd0aac9635f0dc1" name="a82c38db0fda2eaafccd0aac9635f0dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c38db0fda2eaafccd0aac9635f0dc1">&#9670;&#160;</a></span>noc_async_writes_flushed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_async_writes_flushed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This blocking call waits for all outstanding enqueued <em>noc_async_write</em> calls issued on the current Tensix core to depart, but will not wait for them to complete </p>

</div>
</div>
<a id="a1f11981622b01c9e42d44a939ec30be1" name="a1f11981622b01c9e42d44a939ec30be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f11981622b01c9e42d44a939ec30be1">&#9670;&#160;</a></span>noc_inline_dw_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_inline_dw_write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>be</em> = <code>0xF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an asynchronous write of a 32-bit value to a NOC destination. Typically used for writing registers, but can be used for memory locations as well. The destination is specified as a 64-bit NOC address (see <em>noc_async_write</em>). The advantage over using <em>noc_async_write</em> is that we don't a Tensix L1 memory source location; the write value is written directly into a register. Unlike using <em>noc_async_write</em>, there are also no address alignment concerns. Also, see <em>noc_async_write_barrier</em>.</p>
<p>The destination node can be either a DRAM bank, Tensix core+L1 memory address or a PCIe controller.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addr   </td><td class="markdownTableBodyNone">Encoding of the destination location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The value to be written   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">be   </td><td class="markdownTableBodyNone">Byte-enable   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone">0x1-0xF   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a962d804ce21d1d26ccb4241e2eb6ac9f" name="a962d804ce21d1d26ccb4241e2eb6ac9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962d804ce21d1d26ccb4241e2eb6ac9f">&#9670;&#160;</a></span>noc_semaphore_inc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_inc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>incr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noc_id</em> = <code>noc_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Tensix core executing this function call initiates an atomic increment (with 32-bit wrap) of a remote Tensix core L1 memory address. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addr   </td><td class="markdownTableBodyNone">Encoding of the destination location (x,y)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">incr   </td><td class="markdownTableBodyNone">The value to increment by   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af02a9af640679b00da874318535aa397" name="af02a9af640679b00da874318535aa397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02a9af640679b00da874318535aa397">&#9670;&#160;</a></span>noc_semaphore_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of a local L1 memory address on the Tensix core executing this function to a specific value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_wait</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">Value to set the semaphore to   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af1debd77eb9592540a899290fb2a1709" name="af1debd77eb9592540a899290fb2a1709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1debd77eb9592540a899290fb2a1709">&#9670;&#160;</a></span>noc_semaphore_set_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set_multicast </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as <em>noc_async_write_multicast</em> with preset size of 4 Bytes.</p>
<p>With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.e. must perform a local L1 write), the other API variant <em>noc_semaphore_set_multicast_loopback_src</em> can be used.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..119   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ab629fc4e0e17a8ed09e5a6b264927b18" name="ab629fc4e0e17a8ed09e5a6b264927b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab629fc4e0e17a8ed09e5a6b264927b18">&#9670;&#160;</a></span>noc_semaphore_set_multicast_loopback_src()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_set_multicast_loopback_src </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>src_local_l1_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>dst_noc_addr_multicast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>num_dests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linked</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multicast_path_reserve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64_t encoding referencing an on-chip grid of nodes located at NOC coordinate range (x_start,y_start,x_end,y_end) and a local address created using <em>get_noc_multicast_addr</em> function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as <em>noc_async_write_multicast</em> with preset size of 4 Bytes.</p>
<p>Note: With this API, sending data only to the source node (when num_dests is 1) may result in unexpected behaviour. For some parameters, hangs have been observed. For some other parameters, nothing may happen. Consider using regular non multicast operations such as <em>noc_async_write</em> in this case.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src_local_l1_addr   </td><td class="markdownTableBodyNone">Source address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_noc_addr_multicast   </td><td class="markdownTableBodyNone">Encoding of the destinations nodes (x_start,y_start,x_end,y_end)+address   </td><td class="markdownTableBodyNone">uint64_t   </td><td class="markdownTableBodyNone">DOX-TODO(insert a reference to what constitutes valid coords)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_dests   </td><td class="markdownTableBodyNone">Number of destinations that the multicast source is targetting   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..119   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a4f714cc4a08a2eaac5e3f7fae9d1383a" name="a4f714cc4a08a2eaac5e3f7fae9d1383a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f714cc4a08a2eaac5e3f7fae9d1383a">&#9670;&#160;</a></span>noc_semaphore_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_wait </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The target value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a84a965a61b65152c42835f35dca007af" name="a84a965a61b65152c42835f35dca007af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a965a61b65152c42835f35dca007af">&#9670;&#160;</a></span>noc_semaphore_wait_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void noc_semaphore_wait_min </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>sem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <em>noc_semaphore_set</em>.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sem_addr   </td><td class="markdownTableBodyNone">Semaphore address in local L1 memory   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0..1MB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">val   </td><td class="markdownTableBodyNone">The target value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any uint32_t value   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
