\hypertarget{dataflow__api_8h}{}\doxysection{tt\+\_\+metal/hw/inc/dataflow\+\_\+api.h File Reference}
\label{dataflow__api_8h}\index{tt\_metal/hw/inc/dataflow\_api.h@{tt\_metal/hw/inc/dataflow\_api.h}}
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include \char`\"{}core\+\_\+config.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}circular\+\_\+buffer.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug/sanitize\+\_\+noc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug/waypoint.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}eth\+\_\+l1\+\_\+address\+\_\+map.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}hostdevcommon/common\+\_\+runtime\+\_\+address\+\_\+map.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}hostdevcommon/common\+\_\+values.\+hpp\char`\"{}}\newline
{\ttfamily \#include \char`\"{}risc\+\_\+attribs.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}third\+\_\+party/umd/device/tt\+\_\+silicon\+\_\+driver\+\_\+common.\+hpp\char`\"{}}\newline
{\ttfamily \#include \char`\"{}debug/assert.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}dev\+\_\+msgs.\+h\char`\"{}}\newline
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structInterleavedAddrGen}{Interleaved\+Addr\+Gen$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{structInterleavedPow2AddrGen}{Interleaved\+Pow2\+Addr\+Gen$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{structInterleavedAddrGenFast}{Interleaved\+Addr\+Gen\+Fast$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{structInterleavedPow2AddrGenFast}{Interleaved\+Pow2\+Addr\+Gen\+Fast$<$ DRAM $>$}}
\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{dataflow__api_8h_a56cf50350ff87477df00fb899480ff2d}\label{dataflow__api_8h_a56cf50350ff87477df00fb899480ff2d}} 
\#define {\bfseries NOC\+\_\+\+UNICAST\+\_\+\+WRITE\+\_\+\+VC}~1
\item 
\mbox{\Hypertarget{dataflow__api_8h_a5fb39d71d6c419e9ad7aa0f43e5a91d8}\label{dataflow__api_8h_a5fb39d71d6c419e9ad7aa0f43e5a91d8}} 
\#define {\bfseries NOC\+\_\+\+MULTICAST\+\_\+\+WRITE\+\_\+\+VC}~4
\item 
\mbox{\Hypertarget{dataflow__api_8h_a49104913a904db0ef5c642d10a33c923}\label{dataflow__api_8h_a49104913a904db0ef5c642d10a33c923}} 
\#define {\bfseries NOC\+\_\+\+DISPATCH\+\_\+\+MULTICAST\+\_\+\+WRITE\+\_\+\+VC}~5
\item 
\#define \mbox{\hyperlink{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe}{get\+\_\+compile\+\_\+time\+\_\+arg\+\_\+val}}(arg\+\_\+idx)~KERNEL\+\_\+\+COMPILE\+\_\+\+TIME\+\_\+\+ARG\+\_\+\#\#arg\+\_\+idx
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{dataflow__api_8h_ac4752c4d9a07974ce99aaa671a675fe2}\label{dataflow__api_8h_ac4752c4d9a07974ce99aaa671a675fe2}} 
uint32\+\_\+t {\bfseries align} (uint32\+\_\+t addr, uint32\+\_\+t alignment)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a4018be9d6302207fdc0dac085663e184}\label{dataflow__api_8h_a4018be9d6302207fdc0dac085663e184}} 
{\footnotesize template$<$bool DRAM$>$ }\\uint32\+\_\+t {\bfseries interleaved\+\_\+addr\+\_\+gen\+::get\+\_\+bank\+\_\+offset\+\_\+index} (uint32\+\_\+t id)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a63194c761e19c2a9d096f91c9e9be63c}\label{dataflow__api_8h_a63194c761e19c2a9d096f91c9e9be63c}} 
{\footnotesize template$<$bool DRAM$>$ }\\uint32\+\_\+t {\bfseries interleaved\+\_\+addr\+\_\+gen\+::get\+\_\+bank\+\_\+index} (uint32\+\_\+t id, uint32\+\_\+t bank\+\_\+offset\+\_\+index)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a7581885ee418929f06551a5e8f9649c2}\label{dataflow__api_8h_a7581885ee418929f06551a5e8f9649c2}} 
{\footnotesize template$<$bool DRAM$>$ }\\uint32\+\_\+t {\bfseries interleaved\+\_\+addr\+\_\+gen\+::get\+\_\+noc\+\_\+xy} (uint32\+\_\+t bank\+\_\+index)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a593eecf4e9f53608d0c5c82e54b36b03}\label{dataflow__api_8h_a593eecf4e9f53608d0c5c82e54b36b03}} 
{\footnotesize template$<$bool DRAM$>$ }\\uint32\+\_\+t {\bfseries interleaved\+\_\+addr\+\_\+gen\+::get\+\_\+bank\+\_\+offset} (uint32\+\_\+t bank\+\_\+index)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f}{get\+\_\+arg\+\_\+val}} (int arg\+\_\+idx)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a}{get\+\_\+common\+\_\+arg\+\_\+val}} (int arg\+\_\+idx)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a81357224b88562601b42833eec676ffb}{cb\+\_\+push\+\_\+back}} (const int32\+\_\+t operand, const int32\+\_\+t num\+\_\+pages)
\item 
void \mbox{\hyperlink{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}{cb\+\_\+pop\+\_\+front}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
\mbox{\Hypertarget{dataflow__api_8h_af4a1a9478a83ad216d826dc5f783d1f8}\label{dataflow__api_8h_af4a1a9478a83ad216d826dc5f783d1f8}} 
constexpr std\+::int32\+\_\+t {\bfseries get\+\_\+tile\+\_\+size} (const std\+::int32\+\_\+t operand)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ae214b6c2f978e745f9c24d397dad906d}\label{dataflow__api_8h_ae214b6c2f978e745f9c24d397dad906d}} 
constexpr Data\+Format {\bfseries get\+\_\+dataformat} (const std\+::int32\+\_\+t operand)
\item 
uint32\+\_\+t \mbox{\hyperlink{dataflow__api_8h_a593e43aff0c85e4b3f86d13f1d7350dd}{get\+\_\+write\+\_\+ptr}} (uint32\+\_\+t operand)
\item 
uint32\+\_\+t \mbox{\hyperlink{dataflow__api_8h_a66a31715a14cea1a63cbdca8c99b0827}{get\+\_\+read\+\_\+ptr}} (uint32\+\_\+t operand)
\item 
\mbox{\Hypertarget{dataflow__api_8h_af2384f3c7d9784e3e662093136cbed25}\label{dataflow__api_8h_af2384f3c7d9784e3e662093136cbed25}} 
void {\bfseries wait\+\_\+for\+\_\+sync\+\_\+register\+\_\+value} (uint32\+\_\+t addr, int32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed}{cb\+\_\+reserve\+\_\+back}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}{cb\+\_\+wait\+\_\+front}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ae4374fb8ab97c23045cf3f9dd8e1615f}\label{dataflow__api_8h_ae4374fb8ab97c23045cf3f9dd8e1615f}} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+multicast\+\_\+addr} (std\+::uint32\+\_\+t noc\+\_\+x\+\_\+start, std\+::uint32\+\_\+t noc\+\_\+y\+\_\+start, std\+::uint32\+\_\+t noc\+\_\+x\+\_\+end, std\+::uint32\+\_\+t noc\+\_\+y\+\_\+end, std\+::uint32\+\_\+t addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a6080fdaa08b51535164a0b439599c2b2}\label{dataflow__api_8h_a6080fdaa08b51535164a0b439599c2b2}} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (std\+::uint32\+\_\+t noc\+\_\+x, std\+::uint32\+\_\+t noc\+\_\+y, std\+::uint32\+\_\+t addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aa850145f50aafa428c0d257cfed4fb8c}\label{dataflow__api_8h_aa850145f50aafa428c0d257cfed4fb8c}} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr\+\_\+helper} (std\+::uint32\+\_\+t noc\+\_\+xy, std\+::uint32\+\_\+t addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aba0d056dcf68dc0d8745c6eb6d6b36ef}\label{dataflow__api_8h_aba0d056dcf68dc0d8745c6eb6d6b36ef}} 
uint64\+\_\+t {\bfseries get\+\_\+dram\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t bank\+\_\+base\+\_\+address, const uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aefcec950f39f40599c5c01a66d1055e1}\label{dataflow__api_8h_aefcec950f39f40599c5c01a66d1055e1}} 
uint64\+\_\+t {\bfseries get\+\_\+l1\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t bank\+\_\+base\+\_\+address, const uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a6cea6159b23fc89dcfb5daa668439d1c}\label{dataflow__api_8h_a6cea6159b23fc89dcfb5daa668439d1c}} 
uint64\+\_\+t {\bfseries get\+\_\+system\+\_\+memory\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t base\+\_\+addr, const uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ab2336f9ac51bfd90b0393665f608785f}\label{dataflow__api_8h_ab2336f9ac51bfd90b0393665f608785f}} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (std\+::uint32\+\_\+t addr)
\item 
void \mbox{\hyperlink{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5}{noc\+\_\+async\+\_\+read}} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ad2263fe3188c0629cc6c40c30ad8dc27}\label{dataflow__api_8h_ad2263fe3188c0629cc6c40c30ad8dc27}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aa5dd39896c00012bcafdbff681f456be}\label{dataflow__api_8h_aa5dd39896c00012bcafdbff681f456be}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_abf12fff178e5ec0115fcd9c503835bfe}\label{dataflow__api_8h_abf12fff178e5ec0115fcd9c503835bfe}} 
{\footnotesize template$<$bool inc\+\_\+num\+\_\+issued = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_abc73bc75c5461bec168e308cc4dac463}\label{dataflow__api_8h_abc73bc75c5461bec168e308cc4dac463}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a5f0190364ed02bd2ebd4ad9dcaf66606}\label{dataflow__api_8h_a5f0190364ed02bd2ebd4ad9dcaf66606}} 
{\footnotesize template$<$bool inc\+\_\+num\+\_\+issued = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a4258a390cad1838db7970453230d3f20}\label{dataflow__api_8h_a4258a390cad1838db7970453230d3f20}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+inc\+\_\+num\+\_\+issued} (std\+::uint32\+\_\+t num\+\_\+issued\+\_\+reads\+\_\+inc)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ace2e10391566bc043956841d26c2b96a}\label{dataflow__api_8h_ace2e10391566bc043956841d26c2b96a}} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a243f72eb0de9e7694030ecabbdd55441}\label{dataflow__api_8h_a243f72eb0de9e7694030ecabbdd55441}} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+one\+\_\+packet} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a5e5d48b77f56a10bf3edba5d5907ea25}\label{dataflow__api_8h_a5e5d48b77f56a10bf3edba5d5907ea25}} 
{\footnotesize template$<$bool non\+\_\+posted = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a99bf42adaae3e6926445b84e7c30e20e}\label{dataflow__api_8h_a99bf42adaae3e6926445b84e7c30e20e}} 
{\footnotesize template$<$bool non\+\_\+posted = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+noc\+\_\+addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aacf5989f91beb6b0ab26d115ac12fe6f}\label{dataflow__api_8h_aacf5989f91beb6b0ab26d115ac12fe6f}} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedAddrGen}{Interleaved\+Addr\+Gen}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a1ca192ad50dc46eabb2688cf1e0f0575}\label{dataflow__api_8h_a1ca192ad50dc46eabb2688cf1e0f0575}} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedPow2AddrGen}{Interleaved\+Pow2\+Addr\+Gen}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aee5ebbce5f15ef2a4999f983a7d13fe0}\label{dataflow__api_8h_aee5ebbce5f15ef2a4999f983a7d13fe0}} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedAddrGenFast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aa628194296041838dd0512194f78cb4b}\label{dataflow__api_8h_aa628194296041838dd0512194f78cb4b}} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+page} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedAddrGen}{Interleaved\+Addr\+Gen}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, uint32\+\_\+t offset=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ab74a8d9d97b2e7d1c15454db2c7d7431}\label{dataflow__api_8h_ab74a8d9d97b2e7d1c15454db2c7d7431}} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedAddrGenFast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, uint32\+\_\+t offset=0)
\item 
{\footnotesize template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ }\\void \mbox{\hyperlink{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951}{noc\+\_\+async\+\_\+write}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\mbox{\Hypertarget{dataflow__api_8h_afa1c9f72ce143d24b995167a49eff5e4}\label{dataflow__api_8h_afa1c9f72ce143d24b995167a49eff5e4}} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+tile} (const uint32\+\_\+t id, const \mbox{\hyperlink{structInterleavedAddrGenFast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aad24ffd7fc05b797ce38e6072c2f0eab}\label{dataflow__api_8h_aad24ffd7fc05b797ce38e6072c2f0eab}} 
{\footnotesize template$<$Programmable\+Core\+Type type = Programmable\+Core\+Type\+::\+TENSIX$>$ }\\uint32\+\_\+t {\bfseries get\+\_\+semaphore} (uint32\+\_\+t semaphore\+\_\+id)
\item 
\mbox{\Hypertarget{dataflow__api_8h_aff57d6bb75c161882cd3751a3f4a67ba}\label{dataflow__api_8h_aff57d6bb75c161882cd3751a3f4a67ba}} 
void {\bfseries noc\+\_\+semaphore\+\_\+set\+\_\+remote} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr)
\item 
{\footnotesize template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ }\\void \mbox{\hyperlink{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2}{noc\+\_\+async\+\_\+write\+\_\+multicast}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709}{noc\+\_\+semaphore\+\_\+set\+\_\+multicast}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
void \mbox{\hyperlink{dataflow__api_8h_ab629fc4e0e17a8ed09e5a6b264927b18}{noc\+\_\+semaphore\+\_\+set\+\_\+multicast\+\_\+loopback\+\_\+src}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a4ac57ae59ef98d40b2081b80e5636d20}\label{dataflow__api_8h_a4ac57ae59ef98d40b2081b80e5636d20}} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+loopback\+\_\+src} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950}{noc\+\_\+async\+\_\+read\+\_\+barrier}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680}{noc\+\_\+async\+\_\+write\+\_\+barrier}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1}{noc\+\_\+async\+\_\+writes\+\_\+flushed}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a13a74d46d62931d19a406414db103c4b}{noc\+\_\+async\+\_\+atomic\+\_\+barrier}} (uint8\+\_\+t noc\+\_\+idx=noc\+\_\+index)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a}{noc\+\_\+semaphore\+\_\+wait}} (volatile uint32\+\_\+t $\ast$sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a84a965a61b65152c42835f35dca007af}{noc\+\_\+semaphore\+\_\+wait\+\_\+min}} (volatile uint32\+\_\+t $\ast$sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af02a9af640679b00da874318535aa397}{noc\+\_\+semaphore\+\_\+set}} (volatile uint32\+\_\+t $\ast$sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1}{noc\+\_\+inline\+\_\+dw\+\_\+write}} (uint64\+\_\+t addr, uint32\+\_\+t val, uint8\+\_\+t be=0xF)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a962d804ce21d1d26ccb4241e2eb6ac9f}{noc\+\_\+semaphore\+\_\+inc}} (uint64\+\_\+t addr, uint32\+\_\+t incr, uint8\+\_\+t noc\+\_\+id=noc\+\_\+index)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a9e9618b5b64ed1ae0d0a747ac0f10745}\label{dataflow__api_8h_a9e9618b5b64ed1ae0d0a747ac0f10745}} 
void {\bfseries RISC\+\_\+\+POST\+\_\+\+HEARTBEAT} (uint32\+\_\+t \&heartbeat)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a29bd290aaee1b41529717b029dc14952}\label{dataflow__api_8h_a29bd290aaee1b41529717b029dc14952}} 
uint32\+\_\+t {\bfseries min} (uint32\+\_\+t a, uint32\+\_\+t b)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a0de16ed70bc7231b31eb861b6d0a6842}\label{dataflow__api_8h_a0de16ed70bc7231b31eb861b6d0a6842}} 
{\footnotesize template$<$uint32\+\_\+t page\+\_\+size, bool use\+\_\+vc$>$ }\\uint32\+\_\+t {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile\+\_\+dram\+\_\+sharded\+\_\+set\+\_\+state} (uint32\+\_\+t bank\+\_\+base\+\_\+address, uint32\+\_\+t bank\+\_\+id=0, const uint32\+\_\+t vc=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a907a8339412ff90e99743a4ca71af910}\label{dataflow__api_8h_a907a8339412ff90e99743a4ca71af910}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile\+\_\+dram\+\_\+sharded\+\_\+with\+\_\+state} (uint32\+\_\+t src\+\_\+base\+\_\+addr, uint32\+\_\+t src\+\_\+addr, uint32\+\_\+t dest\+\_\+addr, uint32\+\_\+t trid=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_ae92c034dfaaa6b841194aab8e7d5ec42}\label{dataflow__api_8h_ae92c034dfaaa6b841194aab8e7d5ec42}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile\+\_\+dram\+\_\+sharded\+\_\+with\+\_\+state\+\_\+with\+\_\+trid} (uint32\+\_\+t src\+\_\+base\+\_\+addr, uint32\+\_\+t src\+\_\+addr, uint32\+\_\+t dest\+\_\+addr, uint32\+\_\+t trid=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a799ce34e86a34e05f3dd8f30cf958378}\label{dataflow__api_8h_a799ce34e86a34e05f3dd8f30cf958378}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile\+\_\+dram\+\_\+sharded\+\_\+set\+\_\+trid} (uint32\+\_\+t trid=0)
\item 
\mbox{\Hypertarget{dataflow__api_8h_a5515ebbed8b273697e2f44894cf3be28}\label{dataflow__api_8h_a5515ebbed8b273697e2f44894cf3be28}} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+barrier\+\_\+with\+\_\+trid} (uint32\+\_\+t trid)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{dataflow__api_8h_a58bc3a01e945dbd421fce21906e94441}\label{dataflow__api_8h_a58bc3a01e945dbd421fce21906e94441}} 
uint8\+\_\+t {\bfseries noc\+\_\+index}
\item 
\mbox{\Hypertarget{dataflow__api_8h_a2366e9251332058fa1fa368903d1d760}\label{dataflow__api_8h_a2366e9251332058fa1fa368903d1d760}} 
uint32\+\_\+t $\ast$ {\bfseries rta\+\_\+l1\+\_\+base}
\item 
\mbox{\Hypertarget{dataflow__api_8h_a74c5ca11f2fb15c25af4a74db732a5fc}\label{dataflow__api_8h_a74c5ca11f2fb15c25af4a74db732a5fc}} 
uint32\+\_\+t $\ast$ {\bfseries crta\+\_\+l1\+\_\+base}
\item 
\mbox{\Hypertarget{dataflow__api_8h_a237705982b987907cbfca699e32a9c64}\label{dataflow__api_8h_a237705982b987907cbfca699e32a9c64}} 
uint32\+\_\+t $\ast$ {\bfseries sem\+\_\+l1\+\_\+base} \mbox{[}$\,$\mbox{]}
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe}\label{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe}} 
\index{dataflow\_api.h@{dataflow\_api.h}!get\_compile\_time\_arg\_val@{get\_compile\_time\_arg\_val}}
\index{get\_compile\_time\_arg\_val@{get\_compile\_time\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_compile\_time\_arg\_val}{get\_compile\_time\_arg\_val}}
{\footnotesize\ttfamily \#define get\+\_\+compile\+\_\+time\+\_\+arg\+\_\+val(\begin{DoxyParamCaption}\item[{}]{arg\+\_\+idx }\end{DoxyParamCaption})~KERNEL\+\_\+\+COMPILE\+\_\+\+TIME\+\_\+\+ARG\+\_\+\#\#arg\+\_\+idx}

Returns the value of a constexpr argument from kernel\+\_\+compile\+\_\+time\+\_\+args array provided during kernel creation using Create\+Kernel calls.

Return value\+: constexpr uint32\+\_\+t

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &The index of the argument   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}\label{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}} 
\index{dataflow\_api.h@{dataflow\_api.h}!cb\_pop\_front@{cb\_pop\_front}}
\index{cb\_pop\_front@{cb\_pop\_front}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_pop\_front()}{cb\_pop\_front()}}
{\footnotesize\ttfamily void cb\+\_\+pop\+\_\+front (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand,  }\item[{int32\+\_\+t}]{num\+\_\+pages }\end{DoxyParamCaption})}

Pops a specified number of tiles from the front of the specified CB. This also frees this number of tiles in the circular buffer. This call is used by the consumer to free up the space in the CB.

We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.

Note that the act of reading of the tile data from the CB does not free up the space in the CB. Waiting on available tiles and popping them is separated in order to allow the consumer to\+: 1) read the tile data from the CB via multiple reads of sub-\/tiles 2) access the tiles (or their sub-\/tiles) that are visible to the consumer by random access of the valid section of the CB

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to be popped   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a81357224b88562601b42833eec676ffb}\label{dataflow__api_8h_a81357224b88562601b42833eec676ffb}} 
\index{dataflow\_api.h@{dataflow\_api.h}!cb\_push\_back@{cb\_push\_back}}
\index{cb\_push\_back@{cb\_push\_back}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_push\_back()}{cb\_push\_back()}}
{\footnotesize\ttfamily void cb\+\_\+push\+\_\+back (\begin{DoxyParamCaption}\item[{const int32\+\_\+t}]{operand,  }\item[{const int32\+\_\+t}]{num\+\_\+pages }\end{DoxyParamCaption})}

Pushes a given number of tiles in the back of the specified CB’s queue. Decreases the available space in the circular buffer by this number of tiles. This call is used by the producer to make the tiles visible to the consumer of the CB.

We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.

Note that the act of writing the tile data into the CB does not make the tiles visible to the consumer. Writing of the tiles and pushing is separated to allow the producer to\+: 1) write the tile data to the CB via multiple writes of sub-\/tiles 2) modify tiles (or sub-\/tiles) by random access of the valid section of the CB

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to be pushed   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed}\label{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed}} 
\index{dataflow\_api.h@{dataflow\_api.h}!cb\_reserve\_back@{cb\_reserve\_back}}
\index{cb\_reserve\_back@{cb\_reserve\_back}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_reserve\_back()}{cb\_reserve\_back()}}
{\footnotesize\ttfamily void cb\+\_\+reserve\+\_\+back (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand,  }\item[{int32\+\_\+t}]{num\+\_\+pages }\end{DoxyParamCaption})}

A blocking call that waits for the specified number of tiles to be free in the specified circular buffer. This call is used by the producer to wait for the consumer to consume (ie. free up) the specified number of tiles.

CB total size must be an even multiple of the argument passed to this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of free tiles to wait for   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}\label{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}} 
\index{dataflow\_api.h@{dataflow\_api.h}!cb\_wait\_front@{cb\_wait\_front}}
\index{cb\_wait\_front@{cb\_wait\_front}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_wait\_front()}{cb\_wait\_front()}}
{\footnotesize\ttfamily void cb\+\_\+wait\+\_\+front (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand,  }\item[{int32\+\_\+t}]{num\+\_\+pages }\end{DoxyParamCaption})}

A blocking call that waits for the specified number of tiles to be available in the specified circular buffer (CB). This call is used by the consumer of the CB to wait for the producer to fill the CB with at least the specified number of tiles. Important note\+: in case multiple calls of cb\+\_\+wait\+\_\+front(n) are issued without a paired \mbox{\hyperlink{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}{cb\+\_\+pop\+\_\+front()}} call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example\+: 4 calls of cb\+\_\+wait\+\_\+front(8) followed by a cb\+\_\+pop\+\_\+front(32) would produce incorrect behavior. Instead 4 calls of \mbox{\hyperlink{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}{cb\+\_\+wait\+\_\+front()}} waiting on 8, 16, 24, 32 tiles should be issued.

Important note\+: number of tiles used in all cb\+\_\+$\ast$ calls must evenly divide the cb size and must be the same number in all cb\+\_\+wait\+\_\+front calls in the same kernel. Example 1\+: cb\+\_\+wait\+\_\+front(32), cb\+\_\+wait\+\_\+front(40), cb\+\_\+pop\+\_\+front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2\+: cb\+\_\+wait\+\_\+front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.

Important note\+: CB total size must be an even multiple of the argument passed to this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to wait for   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &\\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f}\label{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f}} 
\index{dataflow\_api.h@{dataflow\_api.h}!get\_arg\_val@{get\_arg\_val}}
\index{get\_arg\_val@{get\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_arg\_val()}{get\_arg\_val()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T get\+\_\+arg\+\_\+val (\begin{DoxyParamCaption}\item[{int}]{arg\+\_\+idx }\end{DoxyParamCaption})}

Returns the value at a given runtime argument index for unique (per-\/core) runtime arguments set via Set\+Runtime\+Args() API.

Return value\+: The value associated with the unique runtime argument index

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &Unique Runtime argument index   &uint32\+\_\+t   &0 to 255   &True    \\\cline{1-5}
T (template argument)   &Data type of the returned argument   &Any 4-\/byte sized type   &N/A   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a}\label{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a}} 
\index{dataflow\_api.h@{dataflow\_api.h}!get\_common\_arg\_val@{get\_common\_arg\_val}}
\index{get\_common\_arg\_val@{get\_common\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_common\_arg\_val()}{get\_common\_arg\_val()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T get\+\_\+common\+\_\+arg\+\_\+val (\begin{DoxyParamCaption}\item[{int}]{arg\+\_\+idx }\end{DoxyParamCaption})}

Returns the value at a given runtime argument index for common (all cores) runtime arguments set via Set\+Common\+Runtime\+Args() API.

Return value\+: The value associated with the common runtime argument index

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &Common Runtime argument index   &uint32\+\_\+t   &0 to 255   &True    \\\cline{1-5}
T (template argument)   &Data type of the returned argument   &Any 4-\/byte sized type   &N/A   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a66a31715a14cea1a63cbdca8c99b0827}\label{dataflow__api_8h_a66a31715a14cea1a63cbdca8c99b0827}} 
\index{dataflow\_api.h@{dataflow\_api.h}!get\_read\_ptr@{get\_read\_ptr}}
\index{get\_read\_ptr@{get\_read\_ptr}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_read\_ptr()}{get\_read\_ptr()}}
{\footnotesize\ttfamily uint32\+\_\+t get\+\_\+read\+\_\+ptr (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{operand }\end{DoxyParamCaption})}

Returns a pointer to the beginning of a memory block previously received by cb\+\_\+wait\+\_\+front. Note that this call is only valid between calls to cb\+\_\+wait\+\_\+front and cb\+\_\+pop\+\_\+front. The amount of valid memory is equal to the number of tiles requested in a prior cb\+\_\+wait\+\_\+front call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
operand   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a593e43aff0c85e4b3f86d13f1d7350dd}\label{dataflow__api_8h_a593e43aff0c85e4b3f86d13f1d7350dd}} 
\index{dataflow\_api.h@{dataflow\_api.h}!get\_write\_ptr@{get\_write\_ptr}}
\index{get\_write\_ptr@{get\_write\_ptr}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_write\_ptr()}{get\_write\_ptr()}}
{\footnotesize\ttfamily uint32\+\_\+t get\+\_\+write\+\_\+ptr (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{operand }\end{DoxyParamCaption})}

Returns a pointer to the beginning of a memory block previously reserved by cb\+\_\+reserve\+\_\+back. Note that this call is only valid between calls to cb\+\_\+reserve\+\_\+back and cb\+\_\+push\+\_\+back. The amount of valid memory is equal to the number of tiles requested in a prior cb\+\_\+reserve\+\_\+back call.

CB total size must be an even multiple of this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
operand   &The index of the circular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a13a74d46d62931d19a406414db103c4b}\label{dataflow__api_8h_a13a74d46d62931d19a406414db103c4b}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_atomic\_barrier@{noc\_async\_atomic\_barrier}}
\index{noc\_async\_atomic\_barrier@{noc\_async\_atomic\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_atomic\_barrier()}{noc\_async\_atomic\_barrier()}}
{\footnotesize\ttfamily void noc\+\_\+async\+\_\+atomic\+\_\+barrier (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{noc\+\_\+idx = {\ttfamily noc\+\_\+index} }\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+write} queue will be empty for the current Tensix core.

Return value\+: None \mbox{\Hypertarget{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5}\label{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_read@{noc\_async\_read}}
\index{noc\_async\_read@{noc\_async\_read}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_read()}{noc\_async\_read()}}
{\footnotesize\ttfamily void noc\+\_\+async\+\_\+read (\begin{DoxyParamCaption}\item[{std\+::uint64\+\_\+t}]{src\+\_\+noc\+\_\+addr,  }\item[{std\+::uint32\+\_\+t}]{dst\+\_\+local\+\_\+l1\+\_\+addr,  }\item[{std\+::uint32\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous read from a specified source node located at NOC coordinates (x,y) at a local address (encoded as a uint64\+\_\+t using {\itshape get\+\_\+noc\+\_\+addr} function). The destination is in L1 memory on the Tensix core executing this function call. Also, see {\itshape noc\+\_\+async\+\_\+read\+\_\+barrier}.

The source node can be either a DRAM bank, a Tensix core or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Data type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Data type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ required    }\\\cline{1-5}
\endhead
src\+\_\+noc\+\_\+addr   &Encoding of the source NOC location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(ref to explain valid coords)   &Yes    \\\cline{1-5}
dst\+\_\+local\+\_\+l1\+\_\+addr   &Address in local L1 memory   &uint32\+\_\+t   &0..1MB   &Yes    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &Yes   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950}\label{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_read\_barrier@{noc\_async\_read\_barrier}}
\index{noc\_async\_read\_barrier@{noc\_async\_read\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_read\_barrier()}{noc\_async\_read\_barrier()}}
{\footnotesize\ttfamily void noc\+\_\+async\+\_\+read\+\_\+barrier (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+read} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+read} queue will be empty for the current Tensix core.

Return value\+: None \mbox{\Hypertarget{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951}\label{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write@{noc\_async\_write}}
\index{noc\_async\_write@{noc\_async\_write}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write()}{noc\_async\_write()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ \\
void noc\+\_\+async\+\_\+write (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr,  }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr,  }\item[{std\+::uint32\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call. The destination is specified using a uint64\+\_\+t encoding referencing an on-\/chip node located at NOC coordinates (x,y) and a local address created using get\+\_\+noc\+\_\+addr function. Also, see {\itshape noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination node can be either a DRAM bank, Tensix core+\+L1 memory address or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr   &Encoding of the destination NOC location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680}\label{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write\_barrier@{noc\_async\_write\_barrier}}
\index{noc\_async\_write\_barrier@{noc\_async\_write\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write\_barrier()}{noc\_async\_write\_barrier()}}
{\footnotesize\ttfamily void noc\+\_\+async\+\_\+write\+\_\+barrier (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+write} queue will be empty for the current Tensix core.

Return value\+: None \mbox{\Hypertarget{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2}\label{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write\_multicast@{noc\_async\_write\_multicast}}
\index{noc\_async\_write\_multicast@{noc\_async\_write\_multicast}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write\_multicast()}{noc\_async\_write\_multicast()}}
{\footnotesize\ttfamily template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ \\
void noc\+\_\+async\+\_\+write\+\_\+multicast (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr,  }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr\+\_\+multicast,  }\item[{std\+::uint32\+\_\+t}]{size,  }\item[{std\+::uint32\+\_\+t}]{num\+\_\+dests,  }\item[{bool}]{linked = {\ttfamily false},  }\item[{bool}]{multicast\+\_\+path\+\_\+reserve = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64\+\_\+t encoding referencing an on-\/chip grid of nodes located at NOC coordinate range (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end) and a local address created using {\itshape get\+\_\+noc\+\_\+multicast\+\_\+addr} function. Also, {\itshape see noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination nodes can only be a set of Tensix cores + L1 memory address. The destination nodes must form a rectangular grid. The destination L1 memory address must be the same on all destination nodes.

With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.\+e. must perform a local L1 write), the other API variant {\itshape noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+loopback\+\_\+src} can be used.

Note\+: The number of destinations needs to be non-\/zero. Besides that, there is no restriction on the number of destinations, i.\+e. the multicast destinations can span the full chip. However, as mentioned previously, the multicast source cannot be part of the destinations. So, the maximum number of destinations is 119.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr\+\_\+multicast   &Encoding of the destinations nodes (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
num\+\_\+dests   &Number of destinations that the multicast source is targetting   &uint32\+\_\+t   &0..119   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1}\label{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_writes\_flushed@{noc\_async\_writes\_flushed}}
\index{noc\_async\_writes\_flushed@{noc\_async\_writes\_flushed}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_writes\_flushed()}{noc\_async\_writes\_flushed()}}
{\footnotesize\ttfamily void noc\+\_\+async\+\_\+writes\+\_\+flushed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This blocking call waits for all outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to depart, but will not wait for them to complete \mbox{\Hypertarget{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1}\label{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_inline\_dw\_write@{noc\_inline\_dw\_write}}
\index{noc\_inline\_dw\_write@{noc\_inline\_dw\_write}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_inline\_dw\_write()}{noc\_inline\_dw\_write()}}
{\footnotesize\ttfamily void noc\+\_\+inline\+\_\+dw\+\_\+write (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{addr,  }\item[{uint32\+\_\+t}]{val,  }\item[{uint8\+\_\+t}]{be = {\ttfamily 0xF} }\end{DoxyParamCaption})}

Initiates an asynchronous write of a 32-\/bit value to a NOC destination. Typically used for writing registers, but can be used for memory locations as well. The destination is specified as a 64-\/bit NOC address (see {\itshape noc\+\_\+async\+\_\+write}). The advantage over using {\itshape noc\+\_\+async\+\_\+write} is that we don\textquotesingle{}t a Tensix L1 memory source location; the write value is written directly into a register. Unlike using {\itshape noc\+\_\+async\+\_\+write}, there are also no address alignment concerns. Also, see {\itshape noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination node can be either a DRAM bank, Tensix core+\+L1 memory address or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
addr   &Encoding of the destination location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
val   &The value to be written   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True    \\\cline{1-5}
be   &Byte-\/enable   &uint8\+\_\+t   &0x1-\/0xF   &False   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a962d804ce21d1d26ccb4241e2eb6ac9f}\label{dataflow__api_8h_a962d804ce21d1d26ccb4241e2eb6ac9f}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_inc@{noc\_semaphore\_inc}}
\index{noc\_semaphore\_inc@{noc\_semaphore\_inc}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_inc()}{noc\_semaphore\_inc()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+inc (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{addr,  }\item[{uint32\+\_\+t}]{incr,  }\item[{uint8\+\_\+t}]{noc\+\_\+id = {\ttfamily noc\+\_\+index} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

The Tensix core executing this function call initiates an atomic increment (with 32-\/bit wrap) of a remote Tensix core L1 memory address. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
addr   &Encoding of the destination location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
incr   &The value to increment by   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_af02a9af640679b00da874318535aa397}\label{dataflow__api_8h_af02a9af640679b00da874318535aa397}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_set@{noc\_semaphore\_set}}
\index{noc\_semaphore\_set@{noc\_semaphore\_set}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_set()}{noc\_semaphore\_set()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+set (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t $\ast$}]{sem\+\_\+addr,  }\item[{uint32\+\_\+t}]{val }\end{DoxyParamCaption})}

Sets the value of a local L1 memory address on the Tensix core executing this function to a specific value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+wait}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &Value to set the semaphore to   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709}\label{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_set\_multicast@{noc\_semaphore\_set\_multicast}}
\index{noc\_semaphore\_set\_multicast@{noc\_semaphore\_set\_multicast}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_set\_multicast()}{noc\_semaphore\_set\_multicast()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+set\+\_\+multicast (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr,  }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr\+\_\+multicast,  }\item[{std\+::uint32\+\_\+t}]{num\+\_\+dests,  }\item[{bool}]{linked = {\ttfamily false},  }\item[{bool}]{multicast\+\_\+path\+\_\+reserve = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64\+\_\+t encoding referencing an on-\/chip grid of nodes located at NOC coordinate range (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end) and a local address created using {\itshape get\+\_\+noc\+\_\+multicast\+\_\+addr} function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as {\itshape noc\+\_\+async\+\_\+write\+\_\+multicast} with preset size of 4 Bytes.

With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.\+e. must perform a local L1 write), the other API variant {\itshape noc\+\_\+semaphore\+\_\+set\+\_\+multicast\+\_\+loopback\+\_\+src} can be used.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr\+\_\+multicast   &Encoding of the destinations nodes (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
num\+\_\+dests   &Number of destinations that the multicast source is targetting   &uint32\+\_\+t   &0..119   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_ab629fc4e0e17a8ed09e5a6b264927b18}\label{dataflow__api_8h_ab629fc4e0e17a8ed09e5a6b264927b18}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_set\_multicast\_loopback\_src@{noc\_semaphore\_set\_multicast\_loopback\_src}}
\index{noc\_semaphore\_set\_multicast\_loopback\_src@{noc\_semaphore\_set\_multicast\_loopback\_src}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_set\_multicast\_loopback\_src()}{noc\_semaphore\_set\_multicast\_loopback\_src()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+set\+\_\+multicast\+\_\+loopback\+\_\+src (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr,  }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr\+\_\+multicast,  }\item[{std\+::uint32\+\_\+t}]{num\+\_\+dests,  }\item[{bool}]{linked = {\ttfamily false},  }\item[{bool}]{multicast\+\_\+path\+\_\+reserve = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64\+\_\+t encoding referencing an on-\/chip grid of nodes located at NOC coordinate range (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end) and a local address created using {\itshape get\+\_\+noc\+\_\+multicast\+\_\+addr} function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as {\itshape noc\+\_\+async\+\_\+write\+\_\+multicast} with preset size of 4 Bytes.

Note\+: With this API, sending data only to the source node (when num\+\_\+dests is 1) may result in unexpected behaviour. For some parameters, hangs have been observed. For some other parameters, nothing may happen. Consider using regular non multicast operations such as {\itshape noc\+\_\+async\+\_\+write} in this case.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr\+\_\+multicast   &Encoding of the destinations nodes (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
num\+\_\+dests   &Number of destinations that the multicast source is targetting   &uint32\+\_\+t   &0..119   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a}\label{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_wait@{noc\_semaphore\_wait}}
\index{noc\_semaphore\_wait@{noc\_semaphore\_wait}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_wait()}{noc\_semaphore\_wait()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+wait (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t $\ast$}]{sem\+\_\+addr,  }\item[{uint32\+\_\+t}]{val }\end{DoxyParamCaption})}

A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+set}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &The target value of the semaphore   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\mbox{\Hypertarget{dataflow__api_8h_a84a965a61b65152c42835f35dca007af}\label{dataflow__api_8h_a84a965a61b65152c42835f35dca007af}} 
\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_wait\_min@{noc\_semaphore\_wait\_min}}
\index{noc\_semaphore\_wait\_min@{noc\_semaphore\_wait\_min}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_wait\_min()}{noc\_semaphore\_wait\_min()}}
{\footnotesize\ttfamily void noc\+\_\+semaphore\+\_\+wait\+\_\+min (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t $\ast$}]{sem\+\_\+addr,  }\item[{uint32\+\_\+t}]{val }\end{DoxyParamCaption})}

A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+set}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &The target value of the semaphore   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
