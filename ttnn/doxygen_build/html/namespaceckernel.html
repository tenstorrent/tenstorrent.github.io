<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: ckernel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ckernel Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a457fed1c2f71b59d1949d93479d54f8c"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a457fed1c2f71b59d1949d93479d54f8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a457fed1c2f71b59d1949d93479d54f8c">erf_tile_init</a> ()</td></tr>
<tr class="separator:a457fed1c2f71b59d1949d93479d54f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e2745c2e1e812179a659ffac84f231"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:ab2e2745c2e1e812179a659ffac84f231"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab2e2745c2e1e812179a659ffac84f231">erf_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ab2e2745c2e1e812179a659ffac84f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d55d9b6ac18b93104f4cddf6da7aea1"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a8d55d9b6ac18b93104f4cddf6da7aea1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8d55d9b6ac18b93104f4cddf6da7aea1">erfc_tile_init</a> ()</td></tr>
<tr class="separator:a8d55d9b6ac18b93104f4cddf6da7aea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262be4a133a92ad6d55e6f505dfce753"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a262be4a133a92ad6d55e6f505dfce753"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a262be4a133a92ad6d55e6f505dfce753">erfc_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a262be4a133a92ad6d55e6f505dfce753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd09eba45c8dd3c153752330aa240433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acd09eba45c8dd3c153752330aa240433">erfinv_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:acd09eba45c8dd3c153752330aa240433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab511b6e54d4686ab30c35b169dadac56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab511b6e54d4686ab30c35b169dadac56">erfinv_tile_init</a> ()</td></tr>
<tr class="separator:ab511b6e54d4686ab30c35b169dadac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b870d401c7fbed7ae21f8a6616019"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = false&gt; </td></tr>
<tr class="memitem:acd7b870d401c7fbed7ae21f8a6616019"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acd7b870d401c7fbed7ae21f8a6616019">exp_tile_init</a> ()</td></tr>
<tr class="separator:acd7b870d401c7fbed7ae21f8a6616019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ada6cea1eb5bfefab73dcf6f3b7a5"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = false&gt; </td></tr>
<tr class="memitem:acf8ada6cea1eb5bfefab73dcf6f3b7a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acf8ada6cea1eb5bfefab73dcf6f3b7a5">exp_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:acf8ada6cea1eb5bfefab73dcf6f3b7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f2cefbe52082482d71f807145de1e"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a2e0f2cefbe52082482d71f807145de1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2e0f2cefbe52082482d71f807145de1e">gelu_tile_init</a> ()</td></tr>
<tr class="separator:a2e0f2cefbe52082482d71f807145de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572012591ff76c4277ed48036399de6e"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a572012591ff76c4277ed48036399de6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a572012591ff76c4277ed48036399de6e">gelu_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a572012591ff76c4277ed48036399de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506824a7a457435e622ba1fffc8d8678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a506824a7a457435e622ba1fffc8d8678">recip_tile_init</a> ()</td></tr>
<tr class="separator:a506824a7a457435e622ba1fffc8d8678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31441a86e04985c013f03fca3c59f55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a31441a86e04985c013f03fca3c59f55d">recip_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a31441a86e04985c013f03fca3c59f55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e1e97c019937643933a7b5ec4a73ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a54e1e97c019937643933a7b5ec4a73ff">sqrt_tile_init</a> ()</td></tr>
<tr class="separator:a54e1e97c019937643933a7b5ec4a73ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c2391b46aa28abea6e13bbe7610780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ad7c2391b46aa28abea6e13bbe7610780">sqrt_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ad7c2391b46aa28abea6e13bbe7610780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be3d49aef6238fcf0fe4dc67868d3bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7be3d49aef6238fcf0fe4dc67868d3bd">elu_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:a7be3d49aef6238fcf0fe4dc67868d3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53917e4947e7f3de1c5ef5d1a22aecbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a53917e4947e7f3de1c5ef5d1a22aecbc">elu_tile_init</a> ()</td></tr>
<tr class="separator:a53917e4947e7f3de1c5ef5d1a22aecbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab022361921e28e620e0aa64449d707a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab022361921e28e620e0aa64449d707a8">relu_max_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:ab022361921e28e620e0aa64449d707a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd335c04a4da54f27b29814dc3ba06c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aebd335c04a4da54f27b29814dc3ba06c">relu_max_tile_init</a> ()</td></tr>
<tr class="separator:aebd335c04a4da54f27b29814dc3ba06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2055cc5f849f59581322d4f99aafe7fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2055cc5f849f59581322d4f99aafe7fd">relu_min_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:a2055cc5f849f59581322d4f99aafe7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf551de7b8a1527a9f8d2ffde7ec468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#accf551de7b8a1527a9f8d2ffde7ec468">relu_min_tile_init</a> ()</td></tr>
<tr class="separator:accf551de7b8a1527a9f8d2ffde7ec468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21cee43ed0d618c23762c357dcf1c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abb21cee43ed0d618c23762c357dcf1c2">relu_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:abb21cee43ed0d618c23762c357dcf1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a214735fbd70467722ab3af7f2fb87b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6a214735fbd70467722ab3af7f2fb87b">relu_tile_init</a> ()</td></tr>
<tr class="separator:a6a214735fbd70467722ab3af7f2fb87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f979e18403c78aab904f362ec748f7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8f979e18403c78aab904f362ec748f7e">leaky_relu_tile</a> (uint32_t idst, uint32_t slope)</td></tr>
<tr class="separator:a8f979e18403c78aab904f362ec748f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac696b79d37bcb5188163ffb166566ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac696b79d37bcb5188163ffb166566ca6">leaky_relu_tile_init</a> ()</td></tr>
<tr class="separator:ac696b79d37bcb5188163ffb166566ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08de262ccd14cf8a88f2e74a4d5c5713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a08de262ccd14cf8a88f2e74a4d5c5713">i0_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a08de262ccd14cf8a88f2e74a4d5c5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81bbfe5f0f38c17b58d56562e3ec734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa81bbfe5f0f38c17b58d56562e3ec734">i0_tile_init</a> ()</td></tr>
<tr class="separator:aa81bbfe5f0f38c17b58d56562e3ec734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56fe236cbce161cc69af6a64abd6580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae56fe236cbce161cc69af6a64abd6580">rsub_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:ae56fe236cbce161cc69af6a64abd6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67bbff0728951b06c54865adb9b1e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae67bbff0728951b06c54865adb9b1e6d">rsub_tile_init</a> ()</td></tr>
<tr class="separator:ae67bbff0728951b06c54865adb9b1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560cbe71d63208236a384c40e6da61a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a560cbe71d63208236a384c40e6da61a7">isinf_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a560cbe71d63208236a384c40e6da61a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff15ecc59d70682ad19f46ae6b3ab169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aff15ecc59d70682ad19f46ae6b3ab169">isinf_tile_init</a> ()</td></tr>
<tr class="separator:aff15ecc59d70682ad19f46ae6b3ab169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abe529c6f48dc47b3590bddc44f75b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9abe529c6f48dc47b3590bddc44f75b9">isposinf_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a9abe529c6f48dc47b3590bddc44f75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4903e99b9ac3930660daa6210989adc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a4903e99b9ac3930660daa6210989adc8">isposinf_tile_init</a> ()</td></tr>
<tr class="separator:a4903e99b9ac3930660daa6210989adc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023d3466cbf2b6d0bb6519164f058137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a023d3466cbf2b6d0bb6519164f058137">isneginf_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a023d3466cbf2b6d0bb6519164f058137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6293738625933a80a8d3be6ea9090c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6293738625933a80a8d3be6ea9090c97">isneginf_tile_init</a> ()</td></tr>
<tr class="separator:a6293738625933a80a8d3be6ea9090c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb289937576f99d689c1e0340aaa89b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7cb289937576f99d689c1e0340aaa89b">isnan_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a7cb289937576f99d689c1e0340aaa89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753c8882bdd2d9d5ee76f5261143df24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a753c8882bdd2d9d5ee76f5261143df24">isnan_tile_init</a> ()</td></tr>
<tr class="separator:a753c8882bdd2d9d5ee76f5261143df24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0329908fbe83bd7dc85fe97d621520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#afb0329908fbe83bd7dc85fe97d621520">isfinite_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:afb0329908fbe83bd7dc85fe97d621520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475741e5433ee1dc3173fd791b88aa9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a475741e5433ee1dc3173fd791b88aa9c">isfinite_tile_init</a> ()</td></tr>
<tr class="separator:a475741e5433ee1dc3173fd791b88aa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb2237676286e9427ec296e6cc5ab26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8eb2237676286e9427ec296e6cc5ab26">logical_not_unary_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a8eb2237676286e9427ec296e6cc5ab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c76b173d12fc2c8d4b6a69268fd90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aea8c76b173d12fc2c8d4b6a69268fd90">logical_not_unary_tile_init</a> ()</td></tr>
<tr class="separator:aea8c76b173d12fc2c8d4b6a69268fd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c4ee2f9fd4e95f083612d0e5462d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a060c4ee2f9fd4e95f083612d0e5462d7">sin_tile_init</a> ()</td></tr>
<tr class="separator:a060c4ee2f9fd4e95f083612d0e5462d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a673f6f27ef504770b0b47891cea9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a47a673f6f27ef504770b0b47891cea9c">sin_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a47a673f6f27ef504770b0b47891cea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf68d57fea4010334471559c44e7b8b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abf68d57fea4010334471559c44e7b8b5">cos_tile_init</a> ()</td></tr>
<tr class="separator:abf68d57fea4010334471559c44e7b8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6b37aa28157a3c79780f7053d752f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aeb6b37aa28157a3c79780f7053d752f2">cos_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:aeb6b37aa28157a3c79780f7053d752f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e56f700e9f9c0d201dc4cfa63ecbf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab8e56f700e9f9c0d201dc4cfa63ecbf9">tan_tile_init</a> ()</td></tr>
<tr class="separator:ab8e56f700e9f9c0d201dc4cfa63ecbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340b3d31ff3f60adb500d58dbca820b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a340b3d31ff3f60adb500d58dbca820b7">tan_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a340b3d31ff3f60adb500d58dbca820b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732357a3d198fca729c337979f0c374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9732357a3d198fca729c337979f0c374">sub_tiles_bcast_cols</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a9732357a3d198fca729c337979f0c374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2d1f70dd8d9cba1330480bda3fe9cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a4d2d1f70dd8d9cba1330480bda3fe9cf">sub_tiles_bcast_scalar</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a4d2d1f70dd8d9cba1330480bda3fe9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c6f83f3bb8ee245c6e81d78512498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aec9c6f83f3bb8ee245c6e81d78512498">mul_tiles_bcast_cols</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:aec9c6f83f3bb8ee245c6e81d78512498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676bdf18fdcf79931c618493b7b06438"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a676bdf18fdcf79931c618493b7b06438">mul_tiles_bcast_rows</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a676bdf18fdcf79931c618493b7b06438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab33367f38dde9e23fe6125541eb0568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aab33367f38dde9e23fe6125541eb0568">add_tiles_bcast_rows</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:aab33367f38dde9e23fe6125541eb0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a07f0334b79f3a1945e988bed27e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac6a07f0334b79f3a1945e988bed27e95">add_tiles_bcast_cols</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:ac6a07f0334b79f3a1945e988bed27e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c56cbe89c2bf82e59321407a6397de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae0c56cbe89c2bf82e59321407a6397de">add_tiles_bcast_scalar</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:ae0c56cbe89c2bf82e59321407a6397de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87794bafca1824e6e8e8a4d8a9f0465c"><td class="memTemplParams" colspan="2">template&lt;EltwiseBinaryType tBcastOp, BroadcastType tBcastDim&gt; </td></tr>
<tr class="memitem:a87794bafca1824e6e8e8a4d8a9f0465c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a87794bafca1824e6e8e8a4d8a9f0465c">init_bcast</a> (uint32_t icb0, uint32_t icb1, uint32_t ocb=16)</td></tr>
<tr class="separator:a87794bafca1824e6e8e8a4d8a9f0465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7594ecae6f992d81148ab148486906"><td class="memTemplParams" colspan="2">template&lt;EltwiseBinaryType tBcastOp, BroadcastType tBcastDim&gt; </td></tr>
<tr class="memitem:a6a7594ecae6f992d81148ab148486906"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6a7594ecae6f992d81148ab148486906">any_tiles_bcast</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a6a7594ecae6f992d81148ab148486906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ce76cfa211ae46dea6f04035a8050"><td class="memTemplParams" colspan="2">template&lt;BroadcastType tBcastDim&gt; </td></tr>
<tr class="memitem:ab69ce76cfa211ae46dea6f04035a8050"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab69ce76cfa211ae46dea6f04035a8050">add_tiles_bcast</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:ab69ce76cfa211ae46dea6f04035a8050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045c8a2d7ddbb1993bbeceaff52b3185"><td class="memTemplParams" colspan="2">template&lt;BroadcastType tBcastDim&gt; </td></tr>
<tr class="memitem:a045c8a2d7ddbb1993bbeceaff52b3185"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a045c8a2d7ddbb1993bbeceaff52b3185">sub_tiles_bcast</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a045c8a2d7ddbb1993bbeceaff52b3185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb3059dafd1abba339a9ab4218bf873"><td class="memTemplParams" colspan="2">template&lt;BroadcastType tBcastDim&gt; </td></tr>
<tr class="memitem:abcb3059dafd1abba339a9ab4218bf873"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abcb3059dafd1abba339a9ab4218bf873">mul_tiles_bcast</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:abcb3059dafd1abba339a9ab4218bf873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8358653b6f7b22d1931166373b21b07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac8358653b6f7b22d1931166373b21b07">add_bcast_rows_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:ac8358653b6f7b22d1931166373b21b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae985587f12cada5d6a8af4c1a2252e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae985587f12cada5d6a8af4c1a2252e92">add_bcast_cols_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:ae985587f12cada5d6a8af4c1a2252e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335020a55a6f60210246e438a16bbeee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a335020a55a6f60210246e438a16bbeee">add_bcast_scalar_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a335020a55a6f60210246e438a16bbeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ea7911483802a312e9d8667316bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab35ea7911483802a312e9d8667316bc4">mul_tiles_bcast_scalar_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:ab35ea7911483802a312e9d8667316bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf053fb4909a8dde19f43d65823a784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aadf053fb4909a8dde19f43d65823a784">mul_tiles_bcast_scalar</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:aadf053fb4909a8dde19f43d65823a784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5aa9bbc1b46b6135b629d0f1278a86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aab5aa9bbc1b46b6135b629d0f1278a86">mul_bcast_cols_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:aab5aa9bbc1b46b6135b629d0f1278a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb428b7e7ac6982665a7facc912fd9a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#afb428b7e7ac6982665a7facc912fd9a5">mul_bcast_rows_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:afb428b7e7ac6982665a7facc912fd9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f808cf8022ca4533ca149257ffa779b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3f808cf8022ca4533ca149257ffa779b">sub_bcast_cols_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a3f808cf8022ca4533ca149257ffa779b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2071bf381ca9dc8ed656c3cf8f7ea746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2071bf381ca9dc8ed656c3cf8f7ea746">sub_tiles_bcast_scalar_init_short</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a2071bf381ca9dc8ed656c3cf8f7ea746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d20635facce5ae4c7ee121028740b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2d20635facce5ae4c7ee121028740b38">cb_wait_front</a> (uint32_t cbid, uint32_t ntiles)</td></tr>
<tr class="separator:a2d20635facce5ae4c7ee121028740b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e8d82ba4b886f8e90eec038735d759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a09e8d82ba4b886f8e90eec038735d759">cb_pop_front</a> (uint32_t cbid, uint32_t ntiles)</td></tr>
<tr class="separator:a09e8d82ba4b886f8e90eec038735d759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af917245b58bfd6176048dc6844a7b7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#af917245b58bfd6176048dc6844a7b7fe">cb_reserve_back</a> (uint32_t cbid, uint32_t ntiles)</td></tr>
<tr class="separator:af917245b58bfd6176048dc6844a7b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f81e4da52b94a5397f904d446808c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#af6f81e4da52b94a5397f904d446808c9">cb_push_back</a> (uint32_t cbid, uint32_t ntiles)</td></tr>
<tr class="separator:af6f81e4da52b94a5397f904d446808c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c38a99abe8e5e072ae3bc9ea35cf23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a60c38a99abe8e5e072ae3bc9ea35cf23">cb_get_tile</a> (uint32_t cb_id, uint32_t index, volatile void *p_tile)</td></tr>
<tr class="separator:a60c38a99abe8e5e072ae3bc9ea35cf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab833f2a940d6668f992dd77ca06ed03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab833f2a940d6668f992dd77ca06ed03d">cb_release_tile</a> (uint32_t cb_id)</td></tr>
<tr class="separator:ab833f2a940d6668f992dd77ca06ed03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e3d7d25c1ebd5f6f1e0fe471a502f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa8e3d7d25c1ebd5f6f1e0fe471a502f6">binary_op_init_common</a> (uint32_t icb0, uint32_t icb1, uint32_t ocb=16)</td></tr>
<tr class="separator:aa8e3d7d25c1ebd5f6f1e0fe471a502f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20703c9d347ca4c998ca32e38762cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#af20703c9d347ca4c998ca32e38762cd5">mul_tiles_init_f</a> ()</td></tr>
<tr class="separator:af20703c9d347ca4c998ca32e38762cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7722fc6c62a98e87aa80dfd4addc04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a5d7722fc6c62a98e87aa80dfd4addc04">mul_tiles_init</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a5d7722fc6c62a98e87aa80dfd4addc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38862808571447611983528275f91831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a38862808571447611983528275f91831">add_tiles_init_nof</a> ()</td></tr>
<tr class="separator:a38862808571447611983528275f91831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f8bb9e954453c9391caf073cbb2ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab15f8bb9e954453c9391caf073cbb2ee">add_tiles_init</a> (uint32_t icb0=0, uint32_t icb1=1, bool acc_to_dest=false)</td></tr>
<tr class="separator:ab15f8bb9e954453c9391caf073cbb2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136179be2361633cae3291b6d25fa2a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a136179be2361633cae3291b6d25fa2a5">sub_tiles_init_nof</a> ()</td></tr>
<tr class="separator:a136179be2361633cae3291b6d25fa2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96384bfa2d9947faea6cd7d7f61b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a1b96384bfa2d9947faea6cd7d7f61b6c">sub_tiles_init</a> (uint32_t icb0=0, uint32_t icb1=1, bool acc_to_dest=false)</td></tr>
<tr class="separator:a1b96384bfa2d9947faea6cd7d7f61b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d86448b624a24f6bf77c45334590835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a5d86448b624a24f6bf77c45334590835">mul_tiles</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a5d86448b624a24f6bf77c45334590835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a091c5371932422fc303adea3eec806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a5a091c5371932422fc303adea3eec806">add_tiles</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a5a091c5371932422fc303adea3eec806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc846385166d37dbbab9e602e44e1fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acc846385166d37dbbab9e602e44e1fb3">sub_tiles</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:acc846385166d37dbbab9e602e44e1fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae239860fe24a16896deca931882e7bd6"><td class="memTemplParams" colspan="2">template&lt;bool full_init = false, EltwiseBinaryType eltwise_binary_op_type = ELWADD&gt; </td></tr>
<tr class="memitem:ae239860fe24a16896deca931882e7bd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae239860fe24a16896deca931882e7bd6">binary_op_specific_init</a> ()</td></tr>
<tr class="separator:ae239860fe24a16896deca931882e7bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6439309935d12d0f15ca795bb8985"><td class="memTemplParams" colspan="2">template&lt;EltwiseBinaryType eltwise_binary_type = ELWADD, EltwiseBinaryReuseDestType binary_reuse_dest = EltwiseBinaryReuseDestType::NONE&gt; </td></tr>
<tr class="memitem:a1ca6439309935d12d0f15ca795bb8985"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a1ca6439309935d12d0f15ca795bb8985">binary_dest_reuse_tiles_init</a> (uint32_t icb0)</td></tr>
<tr class="separator:a1ca6439309935d12d0f15ca795bb8985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5d8b2767ab4f1e188aac1ee4a8c744"><td class="memTemplParams" colspan="2">template&lt;EltwiseBinaryType eltwise_binary_type = ELWADD, EltwiseBinaryReuseDestType binary_reuse_dest = EltwiseBinaryReuseDestType::NONE&gt; </td></tr>
<tr class="memitem:a9f5d8b2767ab4f1e188aac1ee4a8c744"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9f5d8b2767ab4f1e188aac1ee4a8c744">binary_dest_reuse_tiles</a> (uint32_t in_cb_id, uint32_t in_tile_index, uint32_t dst_tile_index)</td></tr>
<tr class="separator:a9f5d8b2767ab4f1e188aac1ee4a8c744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeadefda1b391d2924a635b87f264c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#adeadefda1b391d2924a635b87f264c9f">mm_init</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, uint32_t out_cb_id=16, const uint32_t transpose=0)</td></tr>
<tr class="separator:adeadefda1b391d2924a635b87f264c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b5c274614aec08a77df1f78829c39d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae3b5c274614aec08a77df1f78829c39d">matmul_tiles</a> (uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t in0_tile_index, uint32_t in1_tile_index, uint32_t idst, const uint32_t transpose)</td></tr>
<tr class="separator:ae3b5c274614aec08a77df1f78829c39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c225636a89c5fbc8e3ab0f17902f88"><td class="memTemplParams" colspan="2">template&lt;uint32_t num_faces = 4&gt; </td></tr>
<tr class="memitem:a11c225636a89c5fbc8e3ab0f17902f88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a11c225636a89c5fbc8e3ab0f17902f88">matmul_tiles_math</a> (uint32_t idst)</td></tr>
<tr class="separator:a11c225636a89c5fbc8e3ab0f17902f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035a5d432eee641ae14275669d349f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a035a5d432eee641ae14275669d349f9e">mm_init_short</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, const uint32_t transpose=0)</td></tr>
<tr class="separator:a035a5d432eee641ae14275669d349f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9da9bf23131b50fcd49cff381df661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acc9da9bf23131b50fcd49cff381df661">mm_init_short_with_dt</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, uint32_t c_in_old_srca=2, const uint32_t transpose=0)</td></tr>
<tr class="separator:acc9da9bf23131b50fcd49cff381df661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af455b928c9eb2b460ea9d3816f84c652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#af455b928c9eb2b460ea9d3816f84c652">mm_block_init</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, uint32_t out_cb_id=16, const uint32_t transpose=0, uint32_t ct_dim=1, uint32_t rt_dim=1, uint32_t kt_dim=1)</td></tr>
<tr class="separator:af455b928c9eb2b460ea9d3816f84c652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96a5576438c50eba97c7669ec2ebdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aaf96a5576438c50eba97c7669ec2ebdb">matmul_block</a> (uint32_t in0_cb_id, uint32_t in1_cb_id, uint32_t in0_tile_index, uint32_t in1_tile_index, uint32_t idst, const uint32_t transpose, uint32_t ct_dim, uint32_t rt_dim, uint32_t kt_dim)</td></tr>
<tr class="separator:aaf96a5576438c50eba97c7669ec2ebdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95a903f77a9f781fbabd4f083b743f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6a95a903f77a9f781fbabd4f083b743f">mm_block_init_short</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, const uint32_t transpose=0, uint32_t ct_dim=1, uint32_t rt_dim=1, uint32_t kt_dim=1)</td></tr>
<tr class="separator:a6a95a903f77a9f781fbabd4f083b743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae4aa02b645cb258c3c763d4ffc5c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a0ae4aa02b645cb258c3c763d4ffc5c1c">mm_block_init_short_with_dt</a> (uint32_t in0_cb_id=0, uint32_t in1_cb_id=1, uint32_t old_in1_cb_id=2, const uint32_t transpose=0, uint32_t ct_dim=1, uint32_t rt_dim=1, uint32_t kt_dim=1)</td></tr>
<tr class="separator:a0ae4aa02b645cb258c3c763d4ffc5c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c43acd48809eac8f0fd79a09cac7b7"><td class="memTemplParams" colspan="2">template&lt;bool out_of_order_output = false&gt; </td></tr>
<tr class="memitem:a63c43acd48809eac8f0fd79a09cac7b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a63c43acd48809eac8f0fd79a09cac7b7">pack_tile</a> (uint32_t ifrom_dst, uint32_t icb, std::uint32_t output_tile_index=0)</td></tr>
<tr class="separator:a63c43acd48809eac8f0fd79a09cac7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac63a0fae82e1b790a1f6b3a3d8d600f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aac63a0fae82e1b790a1f6b3a3d8d600f">matmul_pack_tile</a> (uint32_t ifrom_dst, uint32_t icb, uint32_t ntiles)</td></tr>
<tr class="separator:aac63a0fae82e1b790a1f6b3a3d8d600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf446c6f981d4fac592dd761236d013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9bf446c6f981d4fac592dd761236d013">pack_reconfig_data_format</a> (const uint32_t new_operand)</td></tr>
<tr class="separator:a9bf446c6f981d4fac592dd761236d013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72f60c412aeb6d07dfc4b72e1c6370d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa72f60c412aeb6d07dfc4b72e1c6370d">pack_reconfig_data_format</a> (const uint32_t old_operand, const uint32_t new_operand)</td></tr>
<tr class="separator:aa72f60c412aeb6d07dfc4b72e1c6370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c6749f2bb88aafc343a6bd67911d66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ad0c6749f2bb88aafc343a6bd67911d66">pack_reconfig_l1_acc</a> (const uint32_t l1_acc_en)</td></tr>
<tr class="separator:ad0c6749f2bb88aafc343a6bd67911d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5800c870a89695e8de483bfdec9d8c"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:a9a5800c870a89695e8de483bfdec9d8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9a5800c870a89695e8de483bfdec9d8c">reconfig_data_format</a> (const uint32_t srca_new_operand, const uint32_t srcb_new_operand)</td></tr>
<tr class="separator:a9a5800c870a89695e8de483bfdec9d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bb6b25a9a51fd1949d929fecd4e1a8"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:a94bb6b25a9a51fd1949d929fecd4e1a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a94bb6b25a9a51fd1949d929fecd4e1a8">reconfig_data_format</a> (const uint32_t srca_old_operand, const uint32_t srca_new_operand, const uint32_t srcb_old_operand, const uint32_t srcb_new_operand)</td></tr>
<tr class="separator:a94bb6b25a9a51fd1949d929fecd4e1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb205e7b72524a5e756c97070b2f75e"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:a0bb205e7b72524a5e756c97070b2f75e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a0bb205e7b72524a5e756c97070b2f75e">reconfig_data_format_srca</a> (const uint32_t srca_new_operand)</td></tr>
<tr class="separator:a0bb205e7b72524a5e756c97070b2f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0577f32a4e70d8ab0d4bbc70e929bc"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:aaa0577f32a4e70d8ab0d4bbc70e929bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aaa0577f32a4e70d8ab0d4bbc70e929bc">reconfig_data_format_srca</a> (const uint32_t srca_old_operand, const uint32_t srca_new_operand)</td></tr>
<tr class="separator:aaa0577f32a4e70d8ab0d4bbc70e929bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920d5a56cc4204d7fb4dae0c0629e8d1"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:a920d5a56cc4204d7fb4dae0c0629e8d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a920d5a56cc4204d7fb4dae0c0629e8d1">reconfig_data_format_srcb</a> (const uint32_t srcb_new_operand)</td></tr>
<tr class="separator:a920d5a56cc4204d7fb4dae0c0629e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261d53be7d210e871741821a126c34d3"><td class="memTemplParams" colspan="2">template&lt;bool to_from_int8 = false&gt; </td></tr>
<tr class="memitem:a261d53be7d210e871741821a126c34d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a261d53be7d210e871741821a126c34d3">reconfig_data_format_srcb</a> (const uint32_t srcb_old_operand, const uint32_t srcb_new_operand)</td></tr>
<tr class="separator:a261d53be7d210e871741821a126c34d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6b64a03989f4fd9c3a8755bae1f370"><td class="memTemplParams" colspan="2">template&lt;bool at_start, PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a3d6b64a03989f4fd9c3a8755bae1f370"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3d6b64a03989f4fd9c3a8755bae1f370">reduce_init</a> (uint32_t icb, uint32_t icb_scaler, uint32_t ocb=16)</td></tr>
<tr class="separator:a3d6b64a03989f4fd9c3a8755bae1f370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb192e99620377ed7ba18b34a1263d48"><td class="memTemplParams" colspan="2">template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:abb192e99620377ed7ba18b34a1263d48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abb192e99620377ed7ba18b34a1263d48">reduce_init_short</a> (uint32_t icb, uint32_t icb_scaler, uint32_t ocb=16)</td></tr>
<tr class="separator:abb192e99620377ed7ba18b34a1263d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bc71a2296a8b19afdcaf438899c771"><td class="memTemplParams" colspan="2">template&lt;bool at_start, PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a04bc71a2296a8b19afdcaf438899c771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a04bc71a2296a8b19afdcaf438899c771">reduce_init_delta</a> (uint32_t ocb=16, uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a04bc71a2296a8b19afdcaf438899c771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08616241482665e17211f3050e640f05"><td class="memTemplParams" colspan="2">template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a08616241482665e17211f3050e640f05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a08616241482665e17211f3050e640f05">reduce_init_delta_no_pack</a> (uint32_t icb0=0, uint32_t icb1=1)</td></tr>
<tr class="separator:a08616241482665e17211f3050e640f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a344e91c5c3a258554c507ae85dd03c"><td class="memTemplParams" colspan="2">template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a1a344e91c5c3a258554c507ae85dd03c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a1a344e91c5c3a258554c507ae85dd03c">reduce_init_delta_math</a> ()</td></tr>
<tr class="separator:a1a344e91c5c3a258554c507ae85dd03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc1a7ae6af7595b5a0a2782e4cbbbb"><td class="memTemplParams" colspan="2">template&lt;ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a13fc1a7ae6af7595b5a0a2782e4cbbbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a13fc1a7ae6af7595b5a0a2782e4cbbbb">reduce_revert_delta</a> (uint32_t ocb=16)</td></tr>
<tr class="separator:a13fc1a7ae6af7595b5a0a2782e4cbbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f4526f08151193fd4a2b8006c3543e"><td class="memTemplParams" colspan="2">template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a38f4526f08151193fd4a2b8006c3543e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a38f4526f08151193fd4a2b8006c3543e">reduce_tile</a> (uint32_t icb0, uint32_t icb1, uint32_t itile0, uint32_t itile1, uint32_t idst)</td></tr>
<tr class="separator:a38f4526f08151193fd4a2b8006c3543e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ea45120e9ffcb785c88effcbd9e42b"><td class="memTemplParams" colspan="2">template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </td></tr>
<tr class="memitem:a12ea45120e9ffcb785c88effcbd9e42b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a12ea45120e9ffcb785c88effcbd9e42b">reduce_tile_math</a> (uint32_t idst, uint32_t num_faces=4)</td></tr>
<tr class="separator:a12ea45120e9ffcb785c88effcbd9e42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e5c0b33fb9768ebd6a7649dca13d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab3e5c0b33fb9768ebd6a7649dca13d56">acquire_dst</a> ()</td></tr>
<tr class="separator:ab3e5c0b33fb9768ebd6a7649dca13d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34467f46da4221ff3a2820ff1baec122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a34467f46da4221ff3a2820ff1baec122">tile_regs_acquire</a> ()</td></tr>
<tr class="separator:a34467f46da4221ff3a2820ff1baec122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5591aaa5084f829a43b6282da1dec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#acc5591aaa5084f829a43b6282da1dec0">tile_regs_wait</a> ()</td></tr>
<tr class="separator:acc5591aaa5084f829a43b6282da1dec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8a1c47b441f374e4ad21ed8d2f8a4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aca8a1c47b441f374e4ad21ed8d2f8a4e">release_dst</a> ()</td></tr>
<tr class="separator:aca8a1c47b441f374e4ad21ed8d2f8a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf34bbf977944a7913f979f709214c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#adaf34bbf977944a7913f979f709214c6">tile_regs_commit</a> ()</td></tr>
<tr class="separator:adaf34bbf977944a7913f979f709214c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd3679665da343bd51f76ced7154c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#addd3679665da343bd51f76ced7154c4a">tile_regs_release</a> ()</td></tr>
<tr class="separator:addd3679665da343bd51f76ced7154c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee656afd9be0e1341190c24a349fe54e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aee656afd9be0e1341190c24a349fe54e">copy_tile_to_dst_init_short</a> (uint32_t cbid=0, uint32_t transpose=0)</td></tr>
<tr class="separator:aee656afd9be0e1341190c24a349fe54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea570483ca5371db26adbdb562bdc640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aea570483ca5371db26adbdb562bdc640">copy_tile_init</a> ()</td></tr>
<tr class="separator:aea570483ca5371db26adbdb562bdc640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de2f4f17e04dc5219e09945e754c6a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a4de2f4f17e04dc5219e09945e754c6a9">copy_tile_to_dst_init_short_with_dt</a> (uint32_t old_cbid, uint32_t new_cbid, uint32_t transpose=0)</td></tr>
<tr class="separator:a4de2f4f17e04dc5219e09945e754c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150166792eaa318a5837165e71e8b44c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a150166792eaa318a5837165e71e8b44c">copy_tile</a> (uint32_t in_cb_id, uint32_t in_tile_index, uint32_t dst_tile_index)</td></tr>
<tr class="separator:a150166792eaa318a5837165e71e8b44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567258ec8567e874535c0e9017e0ca64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a567258ec8567e874535c0e9017e0ca64">copy_block_matmul_partials</a> (uint32_t in_cb_id, uint32_t start_in_tile_index, uint32_t start_dst_tile_index, uint32_t ntiles)</td></tr>
<tr class="separator:a567258ec8567e874535c0e9017e0ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba17d70dc66acc17db5fb7badb16ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8eba17d70dc66acc17db5fb7badb16ae">tilize_init</a> (uint32_t icb, uint32_t block, uint32_t ocb=16)</td></tr>
<tr class="separator:a8eba17d70dc66acc17db5fb7badb16ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f14abbc6a9f82516c94a9c6876d4765"><td class="memTemplParams" colspan="2">template&lt;bool neginf_srcA = true, bool zero_srcA_reduce = false&gt; </td></tr>
<tr class="memitem:a4f14abbc6a9f82516c94a9c6876d4765"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a4f14abbc6a9f82516c94a9c6876d4765">tilizeA_B_reduce_init</a> (uint32_t icb0, uint32_t icb1_scaler, uint32_t block, uint32_t ocb=16, uint32_t num_faces=4, uint32_t face_r_dim=16)</td></tr>
<tr class="separator:a4f14abbc6a9f82516c94a9c6876d4765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649de9891a5d99ebab2c2e1aa75b9a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a649de9891a5d99ebab2c2e1aa75b9a27">tilizeA_B_dot_product_init</a> (uint32_t icb0, uint32_t icb1, uint32_t block, uint32_t ocb=16, uint32_t num_faces=4, uint32_t face_r_dim=16)</td></tr>
<tr class="separator:a649de9891a5d99ebab2c2e1aa75b9a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626e407c919742cff8789652cc08165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2626e407c919742cff8789652cc08165">tilize_init_short</a> (uint32_t icb, uint32_t block, uint32_t ocb=16)</td></tr>
<tr class="separator:a2626e407c919742cff8789652cc08165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3300fef3143945210d4e18f9bcf1760c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3300fef3143945210d4e18f9bcf1760c">tilize_init_unpack</a> (uint32_t icb, uint32_t block)</td></tr>
<tr class="separator:a3300fef3143945210d4e18f9bcf1760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b48db5a98b47825937c82a777a965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a205b48db5a98b47825937c82a777a965">tilize_init_short_with_dt</a> (uint32_t old_icb, uint32_t new_icb, uint32_t block, uint32_t ocb=16)</td></tr>
<tr class="separator:a205b48db5a98b47825937c82a777a965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0827dbb324004596b2971a52c4d0ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aea0827dbb324004596b2971a52c4d0ad">tilize_block</a> (uint32_t icb, uint32_t block, uint32_t ocb)</td></tr>
<tr class="separator:aea0827dbb324004596b2971a52c4d0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9523f37c0573600360754d14776ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8d9523f37c0573600360754d14776ab0">unpack_tilize_block</a> (uint32_t icb, uint32_t block)</td></tr>
<tr class="separator:a8d9523f37c0573600360754d14776ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a976438c3449ea436628357b647852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a17a976438c3449ea436628357b647852">unpack_tilizeA_B_block</a> (uint32_t icb0, uint32_t icb1, uint32_t block, uint32_t tile_idx_b, uint32_t num_faces=4, uint32_t srca_face_r_dim=16)</td></tr>
<tr class="separator:a17a976438c3449ea436628357b647852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100bc7f788be0c8206261722ac613de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a100bc7f788be0c8206261722ac613de7">unpack_tilizeA_B_dot_product_block</a> (uint32_t icb0, uint32_t icb1, uint32_t block, uint32_t tile_idx_b, uint32_t num_faces=4)</td></tr>
<tr class="separator:a100bc7f788be0c8206261722ac613de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be1c47ccd017a1129daf785e15f545c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3be1c47ccd017a1129daf785e15f545c">tilize_uninit</a> (uint32_t icb, uint32_t ocb=16)</td></tr>
<tr class="separator:a3be1c47ccd017a1129daf785e15f545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b2d7e5e9073c4e135581f08657dc3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a40b2d7e5e9073c4e135581f08657dc3b">tilize_uninit_with_dt</a> (uint32_t old_icb=0, uint32_t new_icb=1, uint32_t ocb=16)</td></tr>
<tr class="separator:a40b2d7e5e9073c4e135581f08657dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd30268e7264eac2189db54b6f60f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa5fd30268e7264eac2189db54b6f60f7">transpose_wh_init</a> (uint32_t icb, uint32_t ocb=16)</td></tr>
<tr class="separator:aa5fd30268e7264eac2189db54b6f60f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcfeec0c3262ec9fd53b6dbdc67100c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8fcfeec0c3262ec9fd53b6dbdc67100c">transpose_wh_init_short</a> (uint32_t icb)</td></tr>
<tr class="separator:a8fcfeec0c3262ec9fd53b6dbdc67100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab885f1c61cacad96feb21ff8c9b099aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab885f1c61cacad96feb21ff8c9b099aa">transpose_wh_tile</a> (uint32_t icb, uint32_t itile, uint32_t idst)</td></tr>
<tr class="separator:ab885f1c61cacad96feb21ff8c9b099aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d5a0f5a3a5fa918e9c5d51a7d12ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a74d5a0f5a3a5fa918e9c5d51a7d12ed8">untilize_init</a> (uint32_t icb, uint32_t ocb=16)</td></tr>
<tr class="separator:a74d5a0f5a3a5fa918e9c5d51a7d12ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d031d36cb76c55a761108f7c5dd1a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae4d031d36cb76c55a761108f7c5dd1a5">untilize_init_short</a> (uint32_t icb)</td></tr>
<tr class="separator:ae4d031d36cb76c55a761108f7c5dd1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf529b965f1e85626342a4027d36461"><td class="memTemplParams" colspan="2">template&lt;int N = 1&gt; </td></tr>
<tr class="memitem:abdf529b965f1e85626342a4027d36461"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abdf529b965f1e85626342a4027d36461">untilize_block</a> (uint32_t icb, uint32_t block, uint32_t ocb)</td></tr>
<tr class="separator:abdf529b965f1e85626342a4027d36461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9d99d57d7e3d97a8554498e24b55c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9a9d99d57d7e3d97a8554498e24b55c8">untilize_uninit</a> (uint32_t icb)</td></tr>
<tr class="separator:a9a9d99d57d7e3d97a8554498e24b55c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b982392e5295a3ac4fb3624f984dd4"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a84b982392e5295a3ac4fb3624f984dd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a84b982392e5295a3ac4fb3624f984dd4">rsqrt_tile_init</a> ()</td></tr>
<tr class="separator:a84b982392e5295a3ac4fb3624f984dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b979b10529e525e0e58a0b64dc0cf"><td class="memTemplParams" colspan="2">template&lt;bool fast_and_approx = true&gt; </td></tr>
<tr class="memitem:a9f4b979b10529e525e0e58a0b64dc0cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9f4b979b10529e525e0e58a0b64dc0cf">rsqrt_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a9f4b979b10529e525e0e58a0b64dc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7445ef9a78452c5695742dd3f9163ce1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7445ef9a78452c5695742dd3f9163ce1">sigmoid_tile_init</a> ()</td></tr>
<tr class="separator:a7445ef9a78452c5695742dd3f9163ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0213ec935c1dc8512ab030b6066b36b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a0213ec935c1dc8512ab030b6066b36b1">sigmoid_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a0213ec935c1dc8512ab030b6066b36b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b586e3fde261f186ba8f0e2053a99b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9b586e3fde261f186ba8f0e2053a99b1">log_tile_init</a> ()</td></tr>
<tr class="separator:a9b586e3fde261f186ba8f0e2053a99b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e0a5fd307d540f06493088cf39a4f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a39e0a5fd307d540f06493088cf39a4f0">log_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a39e0a5fd307d540f06493088cf39a4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c75f0f070bb3d196be28db50ec60bcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a1c75f0f070bb3d196be28db50ec60bcd">log_with_base_tile_init</a> ()</td></tr>
<tr class="separator:a1c75f0f070bb3d196be28db50ec60bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3275407181325047284ab43e349a63b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3275407181325047284ab43e349a63b2">log_with_base_tile</a> (uint32_t idst, uint32_t base_scale)</td></tr>
<tr class="separator:a3275407181325047284ab43e349a63b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6ed2b53e52e4d1cc2552443a62c759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3f6ed2b53e52e4d1cc2552443a62c759">tanh_tile_init</a> ()</td></tr>
<tr class="separator:a3f6ed2b53e52e4d1cc2552443a62c759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0ddaa8a8947a0d2e82ad4f4afeb0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aba0ddaa8a8947a0d2e82ad4f4afeb0bb">tanh_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:aba0ddaa8a8947a0d2e82ad4f4afeb0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa745471355960e008e844dc3f313ab05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa745471355960e008e844dc3f313ab05">signbit_tile_init</a> ()</td></tr>
<tr class="separator:aa745471355960e008e844dc3f313ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ebf44b4c1d78c118fce325aff3a709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac6ebf44b4c1d78c118fce325aff3a709">signbit_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ac6ebf44b4c1d78c118fce325aff3a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac709b6fecfd6b34793d44b8a0283530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aac709b6fecfd6b34793d44b8a0283530">abs_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:aac709b6fecfd6b34793d44b8a0283530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9164eb8233a4b5db0165ef3879c13d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac9164eb8233a4b5db0165ef3879c13d3">abs_tile_init</a> ()</td></tr>
<tr class="separator:ac9164eb8233a4b5db0165ef3879c13d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6168b98b6911e7e8d65bcce66a98703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab6168b98b6911e7e8d65bcce66a98703">sign_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ab6168b98b6911e7e8d65bcce66a98703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6854705311e47923c390b236cdcec41e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6854705311e47923c390b236cdcec41e">sign_tile_init</a> ()</td></tr>
<tr class="separator:a6854705311e47923c390b236cdcec41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af987308b41a50236bc0a3850fd7165fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#af987308b41a50236bc0a3850fd7165fb">square_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:af987308b41a50236bc0a3850fd7165fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e08b22bbbbf7960311670af37750e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9d8e08b22bbbbf7960311670af37750e">square_tile_init</a> ()</td></tr>
<tr class="separator:a9d8e08b22bbbbf7960311670af37750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87b691c6559e7b1435d83403abc4301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae87b691c6559e7b1435d83403abc4301">ltz_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ae87b691c6559e7b1435d83403abc4301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f5e45a5227a1378526b21be12d62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa89f5e45a5227a1378526b21be12d62e">ltz_tile_init</a> ()</td></tr>
<tr class="separator:aa89f5e45a5227a1378526b21be12d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77afa61bee15eebd67803d76c955f360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a77afa61bee15eebd67803d76c955f360">eqz_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a77afa61bee15eebd67803d76c955f360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688933a08b41a8d5d283aa75216eae27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a688933a08b41a8d5d283aa75216eae27">eqz_tile_init</a> ()</td></tr>
<tr class="separator:a688933a08b41a8d5d283aa75216eae27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1817972ea6391813a8948bfad83ab981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a1817972ea6391813a8948bfad83ab981">lez_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a1817972ea6391813a8948bfad83ab981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce91ef9087a7c7216fbe8032dafa49e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a5ce91ef9087a7c7216fbe8032dafa49e">lez_tile_init</a> ()</td></tr>
<tr class="separator:a5ce91ef9087a7c7216fbe8032dafa49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015f70b923b3dc75073f42d5be952c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a015f70b923b3dc75073f42d5be952c9a">tiled_prod_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a015f70b923b3dc75073f42d5be952c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5c549b48da0bc2c9c6f22fd7932676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a6b5c549b48da0bc2c9c6f22fd7932676">tiled_prod_tile_init</a> ()</td></tr>
<tr class="separator:a6b5c549b48da0bc2c9c6f22fd7932676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade26cd0bc2247bd4eaf7685eadb88afd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ade26cd0bc2247bd4eaf7685eadb88afd">gtz_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ade26cd0bc2247bd4eaf7685eadb88afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e6fe3d6395ed10fe6c1a3774d0c591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae9e6fe3d6395ed10fe6c1a3774d0c591">gtz_tile_init</a> ()</td></tr>
<tr class="separator:ae9e6fe3d6395ed10fe6c1a3774d0c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114da0de25df24111f54d4ae54daf716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a114da0de25df24111f54d4ae54daf716">nez_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a114da0de25df24111f54d4ae54daf716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724bcc13c2cecd7e12e2efbd31207b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a724bcc13c2cecd7e12e2efbd31207b8f">nez_tile_init</a> ()</td></tr>
<tr class="separator:a724bcc13c2cecd7e12e2efbd31207b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51558a724938976ece1be18997ced97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a51558a724938976ece1be18997ced97f">gez_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a51558a724938976ece1be18997ced97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1406d244d304ea48ce12568911df7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a4e1406d244d304ea48ce12568911df7f">gez_tile_init</a> ()</td></tr>
<tr class="separator:a4e1406d244d304ea48ce12568911df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe18515827e58bdfea82fa99daee38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a61fe18515827e58bdfea82fa99daee38">power_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:a61fe18515827e58bdfea82fa99daee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6f51f9220905884e315442843d2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7cd6f51f9220905884e315442843d2d2">power_tile_init</a> ()</td></tr>
<tr class="separator:a7cd6f51f9220905884e315442843d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1714bd980954724d51080e29b5d0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2d1714bd980954724d51080e29b5d0fd">max_tile</a> (uint32_t idst0, uint32_t idst1)</td></tr>
<tr class="separator:a2d1714bd980954724d51080e29b5d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba747a6e5b80c727984c62b7d0056e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a92ba747a6e5b80c727984c62b7d0056e">max_tile_init</a> ()</td></tr>
<tr class="separator:a92ba747a6e5b80c727984c62b7d0056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2febadfd150cb455955f67746253f116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2febadfd150cb455955f67746253f116">exp2_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a2febadfd150cb455955f67746253f116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae54e275fe6d550c7cb151f24503e958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aae54e275fe6d550c7cb151f24503e958">exp2_tile_init</a> ()</td></tr>
<tr class="separator:aae54e275fe6d550c7cb151f24503e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36c2e30b06007215d6b69568691ed3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ad36c2e30b06007215d6b69568691ed3f">heaviside_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:ad36c2e30b06007215d6b69568691ed3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb18b07f6934634afcb9ed022b36d858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#abb18b07f6934634afcb9ed022b36d858">heaviside_tile_init</a> ()</td></tr>
<tr class="separator:abb18b07f6934634afcb9ed022b36d858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf08edc7ebeb842eb1addfc2ac53da34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#adf08edc7ebeb842eb1addfc2ac53da34">unary_ne_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:adf08edc7ebeb842eb1addfc2ac53da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f5e14f68cb732534c41d400843fced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a86f5e14f68cb732534c41d400843fced">unary_ne_tile_init</a> ()</td></tr>
<tr class="separator:a86f5e14f68cb732534c41d400843fced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e2f1766f4513494f768cffa10b0737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a44e2f1766f4513494f768cffa10b0737">expm1_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a44e2f1766f4513494f768cffa10b0737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7168260d89bae9c8cd208b0a636dc1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7168260d89bae9c8cd208b0a636dc1bf">expm1_tile_init</a> ()</td></tr>
<tr class="separator:a7168260d89bae9c8cd208b0a636dc1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7300e956259f09f938aaf30d266145b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a7300e956259f09f938aaf30d266145b3">asin_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:a7300e956259f09f938aaf30d266145b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae301e69cc106f101a05c17943f50a709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae301e69cc106f101a05c17943f50a709">asin_tile_init</a> ()</td></tr>
<tr class="separator:ae301e69cc106f101a05c17943f50a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada371d824d49e63e32e718eea281959f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ada371d824d49e63e32e718eea281959f">atan_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ada371d824d49e63e32e718eea281959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74eef3940cc3f25fa0c5d99f4e1098ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a74eef3940cc3f25fa0c5d99f4e1098ac">atan_tile_init</a> ()</td></tr>
<tr class="separator:a74eef3940cc3f25fa0c5d99f4e1098ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71f04a726285cd4b0bfadc31eb6cbeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac71f04a726285cd4b0bfadc31eb6cbeb">acos_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:ac71f04a726285cd4b0bfadc31eb6cbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3124122e43788f56d6d93e3e668bd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae3124122e43788f56d6d93e3e668bd0b">acos_tile_init</a> ()</td></tr>
<tr class="separator:ae3124122e43788f56d6d93e3e668bd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4b7d15d9f6ca928626b1a246d7e2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#adc4b7d15d9f6ca928626b1a246d7e2d1">silu_tile</a> (uint32_t idst)</td></tr>
<tr class="separator:adc4b7d15d9f6ca928626b1a246d7e2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f006579d8fe02aa468eb8bf260c47e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a77f006579d8fe02aa468eb8bf260c47e">silu_tile_init</a> ()</td></tr>
<tr class="separator:a77f006579d8fe02aa468eb8bf260c47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5210fb3aea6ef6c09eba614308a25c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa5210fb3aea6ef6c09eba614308a25c5">topk_local_sort</a> (uint32_t idst, int idir, int i_end_phase, int i_start_phase=0, int i_end_step=0, int i_start_step=0)</td></tr>
<tr class="separator:aa5210fb3aea6ef6c09eba614308a25c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938cab3b09934d9f491eb7e8e46a9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2938cab3b09934d9f491eb7e8e46a9c6">topk_merge</a> (uint32_t idst, int m_iter, int k)</td></tr>
<tr class="separator:a2938cab3b09934d9f491eb7e8e46a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cbdb83cc5bc20da93967c2252354b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ae1cbdb83cc5bc20da93967c2252354b8">topk_rebuild</a> (uint32_t idst, bool idir, int m_iter, int k, int logk, int skip_second)</td></tr>
<tr class="separator:ae1cbdb83cc5bc20da93967c2252354b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c812a947f6d756ea625b7361174037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a53c812a947f6d756ea625b7361174037">topk_tile_init</a> ()</td></tr>
<tr class="separator:a53c812a947f6d756ea625b7361174037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27956d536797fa0c3dad4eab6148d731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a27956d536797fa0c3dad4eab6148d731">dbg_halt</a> ()</td></tr>
<tr class="separator:a27956d536797fa0c3dad4eab6148d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73b548e1869c77a4b1d2a4a345b942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa73b548e1869c77a4b1d2a4a345b942d">dbg_unhalt</a> ()</td></tr>
<tr class="separator:aa73b548e1869c77a4b1d2a4a345b942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df20a0a40dac9e97e6b73b0d4fd0c88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a5df20a0a40dac9e97e6b73b0d4fd0c88">dbg_read_dest_acc_row</a> (int row_addr, uint32_t *rd_data)</td></tr>
<tr class="separator:a5df20a0a40dac9e97e6b73b0d4fd0c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb809d58bbce0ee44b0d9f6e3e0caf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3beb809d58bbce0ee44b0d9f6e3e0caf">unary_gt_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:a3beb809d58bbce0ee44b0d9f6e3e0caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a849876763dfccf446df2954aa531d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#aa8a849876763dfccf446df2954aa531d">unary_gt_tile_init</a> ()</td></tr>
<tr class="separator:aa8a849876763dfccf446df2954aa531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efdf48fde7c2df0e8236b387c1ff873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a3efdf48fde7c2df0e8236b387c1ff873">unary_lt_tile</a> (uint32_t idst, uint32_t param0)</td></tr>
<tr class="separator:a3efdf48fde7c2df0e8236b387c1ff873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1307468c0b580c07969a1359769cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a0c1307468c0b580c07969a1359769cff">unary_lt_tile_init</a> ()</td></tr>
<tr class="separator:a0c1307468c0b580c07969a1359769cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a04b6745953bbc4da3c410db3497e39"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a9a04b6745953bbc4da3c410db3497e39">get_compute_special_value_flags</a> ()</td></tr>
<tr class="separator:a9a04b6745953bbc4da3c410db3497e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82cfb17a7aa5f2e577dccb8a109b6a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ab82cfb17a7aa5f2e577dccb8a109b6a1">get_compute_special_value_flags_fpu</a> (uint32_t special_value_flags_reg)</td></tr>
<tr class="separator:ab82cfb17a7aa5f2e577dccb8a109b6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5b8e81326c471d528729eaa179120c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a2b5b8e81326c471d528729eaa179120c">get_compute_special_value_flags_sfpu</a> (uint32_t special_value_flags_reg)</td></tr>
<tr class="separator:a2b5b8e81326c471d528729eaa179120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8babb406a90ed09abdce7a53d3e20b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#a8babb406a90ed09abdce7a53d3e20b84">clear_compute_special_value_flags</a> ()</td></tr>
<tr class="separator:a8babb406a90ed09abdce7a53d3e20b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2326c4eb36719970602e257f21625f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceckernel.html#ac2326c4eb36719970602e257f21625f0">store_compute_special_value_flags_to_l1</a> (uint32_t l1_addr)</td></tr>
<tr class="separator:ac2326c4eb36719970602e257f21625f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aac709b6fecfd6b34793d44b8a0283530" name="aac709b6fecfd6b34793d44b8a0283530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac709b6fecfd6b34793d44b8a0283530">&#9670;&#160;</a></span>abs_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::abs_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of absolute value on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ac9164eb8233a4b5db0165ef3879c13d3" name="ac9164eb8233a4b5db0165ef3879c13d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9164eb8233a4b5db0165ef3879c13d3">&#9670;&#160;</a></span>abs_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::abs_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ac71f04a726285cd4b0bfadc31eb6cbeb" name="ac71f04a726285cd4b0bfadc31eb6cbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71f04a726285cd4b0bfadc31eb6cbeb">&#9670;&#160;</a></span>acos_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::acos_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of arccossine on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae3124122e43788f56d6d93e3e668bd0b" name="ae3124122e43788f56d6d93e3e668bd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3124122e43788f56d6d93e3e668bd0b">&#9670;&#160;</a></span>acos_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::acos_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ab3e5c0b33fb9768ebd6a7649dca13d56" name="ab3e5c0b33fb9768ebd6a7649dca13d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e5c0b33fb9768ebd6a7649dca13d56">&#9670;&#160;</a></span>acquire_dst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::acquire_dst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is deprecated, please use <code><a class="el" href="namespaceckernel.html#a34467f46da4221ff3a2820ff1baec122">tile_regs_acquire()</a></code> instead. See <a href="https://github.com/tenstorrent/tt-metal/issues/5868#issuecomment-2101726935">https://github.com/tenstorrent/tt-metal/issues/5868#issuecomment-2101726935</a></dd></dl>
<p>Acquires an exclusive lock on the internal DST register for the current Tensix core.</p>
<p>This register is an array of 16 tiles of 32x32 elements each. This is a blocking function, i.e. this function will wait until the lock is acquired.</p>
<p>This is only available on the compute engine.</p>
<p>Return value: None</p>
<p>How the destination register will be shared and synchronized between TRISC threads will depend on the compute kernel configuration. </p>

</div>
</div>
<a id="ae985587f12cada5d6a8af4c1a2252e92" name="ae985587f12cada5d6a8af4c1a2252e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae985587f12cada5d6a8af4c1a2252e92">&#9670;&#160;</a></span>add_bcast_cols_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_bcast_cols_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for add_bcast_cols to be executed correctly. Required to be called before add_tiles_bcast if using column as broadcast type </p>

</div>
</div>
<a id="ac8358653b6f7b22d1931166373b21b07" name="ac8358653b6f7b22d1931166373b21b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8358653b6f7b22d1931166373b21b07">&#9670;&#160;</a></span>add_bcast_rows_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_bcast_rows_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for add_bcast_rows to be executed correctly. Required to be called before add_tiles_bcast if using column as broadcast type </p>

</div>
</div>
<a id="a335020a55a6f60210246e438a16bbeee" name="a335020a55a6f60210246e438a16bbeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335020a55a6f60210246e438a16bbeee">&#9670;&#160;</a></span>add_bcast_scalar_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_bcast_scalar_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for add_bcast_scalar to be executed correctly. </p>

</div>
</div>
<a id="a5a091c5371932422fc303adea3eec806" name="a5a091c5371932422fc303adea3eec806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a091c5371932422fc303adea3eec806">&#9670;&#160;</a></span>add_tiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise addition C=A+B of tiles in two CBs at given indices and writes the result to the DST register at index dst_tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of tile B within the second CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result C   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ab69ce76cfa211ae46dea6f04035a8050" name="ab69ce76cfa211ae46dea6f04035a8050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69ce76cfa211ae46dea6f04035a8050">&#9670;&#160;</a></span>add_tiles_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BroadcastType tBcastDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_bcast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This documentation applies to either one of the 3 broadcast operation variants - <em>add_tiles_bcast</em>, <em>sub_tiles_bcast</em> and <em>mul_tiles_bcast</em>.</p>
<p>The description below describes <em>add_tiles_bcast</em>, the other 2 operations use the same definition with the corresponding substitution of the math operator.</p>
<p>Performs a broadcast-operation <em>C=A+B</em> of tiles in two CBs at given indices and writes the result to the DST register at index dst_tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Broadcasting semantics are defined as follows:</p>
<p>For <em>dim==BroadcastType::COL</em>, the input in <em>B</em> is expected to be a single tile with a filled 0-column and zeros elsewhere. The result is <em>C[h, w] = A[h,w] + B[w]</em></p>
<p>For <em>dim==Dim::C</em>, the input in <em>B</em> is expected to be a single tile with a filled 0-row, and zeros elsewhere. The result is <em>C[h, w] = A[h,w] + B[h]</em></p>
<p>For <em>dim==Dim::RC</em>, the input in <em>B</em> is expected to be a single tile with a filled single value at location [0,0], and zeros elsewhere. The result is <em>C[h, w] = A[h,w] + B[0,0]</em></p>
<p>Return value: None</p>
<p>DOX-TODO(AP): verify that the bcast tile is actually required to be filled with zeros.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tBcastDim   </td><td class="markdownTableBodyNone">Broadcast dimension   </td><td class="markdownTableBodyNone">BroadcastType   </td><td class="markdownTableBodyNone">One of Dim::R, Dim::C, Dim::RC.   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The indentifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of tile B within the second CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result C   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ac6a07f0334b79f3a1945e988bed27e95" name="ac6a07f0334b79f3a1945e988bed27e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a07f0334b79f3a1945e988bed27e95">&#9670;&#160;</a></span>add_tiles_bcast_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_bcast_cols </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for sub_tiles_bcast </p>

</div>
</div>
<a id="aab33367f38dde9e23fe6125541eb0568" name="aab33367f38dde9e23fe6125541eb0568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab33367f38dde9e23fe6125541eb0568">&#9670;&#160;</a></span>add_tiles_bcast_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_bcast_rows </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for sub_tiles_bcast </p>

</div>
</div>
<a id="ae0c56cbe89c2bf82e59321407a6397de" name="ae0c56cbe89c2bf82e59321407a6397de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c56cbe89c2bf82e59321407a6397de">&#9670;&#160;</a></span>add_tiles_bcast_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_bcast_scalar </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for add_tiles_bcast </p>

</div>
</div>
<a id="ab15f8bb9e954453c9391caf073cbb2ee" name="ab15f8bb9e954453c9391caf073cbb2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f8bb9e954453c9391caf073cbb2ee">&#9670;&#160;</a></span>add_tiles_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acc_to_dest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Short init function </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">acc_to_dest   </td><td class="markdownTableBodyNone">If true, operation = A + B + dst_tile_idx of add_tiles   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">0,1   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a38862808571447611983528275f91831" name="a38862808571447611983528275f91831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38862808571447611983528275f91831">&#9670;&#160;</a></span>add_tiles_init_nof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::add_tiles_init_nof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. nof means low fidelity with resepect to accuracy this is set during createprogram </p>

</div>
</div>
<a id="a6a7594ecae6f992d81148ab148486906" name="a6a7594ecae6f992d81148ab148486906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7594ecae6f992d81148ab148486906">&#9670;&#160;</a></span>any_tiles_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EltwiseBinaryType tBcastOp, BroadcastType tBcastDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::any_tiles_bcast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7300e956259f09f938aaf30d266145b3" name="a7300e956259f09f938aaf30d266145b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7300e956259f09f938aaf30d266145b3">&#9670;&#160;</a></span>asin_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::asin_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of arcsine on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae301e69cc106f101a05c17943f50a709" name="ae301e69cc106f101a05c17943f50a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae301e69cc106f101a05c17943f50a709">&#9670;&#160;</a></span>asin_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::asin_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ada371d824d49e63e32e718eea281959f" name="ada371d824d49e63e32e718eea281959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada371d824d49e63e32e718eea281959f">&#9670;&#160;</a></span>atan_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::atan_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of arctan on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a74eef3940cc3f25fa0c5d99f4e1098ac" name="a74eef3940cc3f25fa0c5d99f4e1098ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74eef3940cc3f25fa0c5d99f4e1098ac">&#9670;&#160;</a></span>atan_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::atan_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9f5d8b2767ab4f1e188aac1ee4a8c744" name="a9f5d8b2767ab4f1e188aac1ee4a8c744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5d8b2767ab4f1e188aac1ee4a8c744">&#9670;&#160;</a></span>binary_dest_reuse_tiles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EltwiseBinaryType eltwise_binary_type = ELWADD, EltwiseBinaryReuseDestType binary_reuse_dest = EltwiseBinaryReuseDestType::NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::binary_dest_reuse_tiles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_tile_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise binary operations, such as multiply, add, or sub of tiles. If binary_reuse_dest = EltwiseBinaryReuseDestType::DST_TO_SRCA, then the tile specified by idst will be loaded from the DST register buffer into SRCA. The binary operation will operate on SRCA &amp; SRCB inputs, and the result will be written back to the DST register buffer specified by idst. Similar to DST_TO_SRCA, if binary_reuse_dest = EltwiseBinaryReuseDestType::DST_TO_SRCB, then tile specified by idst will be loaded from the DST into SRCB register buffer. DST_TO_SRCB feature is not available for Grayskull, only Wormhole.</p>
<p>EltwiseBinaryReuseDestType::DST_TO_SRCA and EltwiseBinaryReuseDestType::DST_TO_SRCB assume that another operation has populated the dest register, otherwise dest will contain zeroes.</p>
<p>The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of tile B that will be moved to Src reg, and the index of the tile in DST REG for the result C   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a1ca6439309935d12d0f15ca795bb8985" name="a1ca6439309935d12d0f15ca795bb8985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca6439309935d12d0f15ca795bb8985">&#9670;&#160;</a></span>binary_dest_reuse_tiles_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EltwiseBinaryType eltwise_binary_type = ELWADD, EltwiseBinaryReuseDestType binary_reuse_dest = EltwiseBinaryReuseDestType::NONE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::binary_dest_reuse_tiles_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="aa8e3d7d25c1ebd5f6f1e0fe471a502f6" name="aa8e3d7d25c1ebd5f6f1e0fe471a502f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e3d7d25c1ebd5f6f1e0fe471a502f6">&#9670;&#160;</a></span>binary_op_init_common()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::binary_op_init_common </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init function for all binary ops Followed by the specific init required with an opcode (binrary_op_specific_init) </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ocb   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing output   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31, defaults to CB 16   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae239860fe24a16896deca931882e7bd6" name="ae239860fe24a16896deca931882e7bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae239860fe24a16896deca931882e7bd6">&#9670;&#160;</a></span>binary_op_specific_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool full_init = false, EltwiseBinaryType eltwise_binary_op_type = ELWADD&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::binary_op_specific_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init function with a specified op template parameters: full_init: if true, the full init is performed (unpack+math), otherwise a nof init is performed (only math) eltwise_binary_op_type: the binary operation type </p>

</div>
</div>
<a id="a60c38a99abe8e5e072ae3bc9ea35cf23" name="a60c38a99abe8e5e072ae3bc9ea35cf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c38a99abe8e5e072ae3bc9ea35cf23">&#9670;&#160;</a></span>cb_get_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_get_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile void *&#160;</td>
          <td class="paramname"><em>p_tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends the pointer to the given tile index of the specified CB from the UNPACK thread to the MATH and PACK threads, using mailbox writes. Also posts UNPACK_OPERAND_SYNC semaphore for each of these threads.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">index   </td><td class="markdownTableBodyNone">The tile index within the CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">p_tile   </td><td class="markdownTableBodyNone">The pointer that will be populated   </td><td class="markdownTableBodyNone">void*   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a09e8d82ba4b886f8e90eec038735d759" name="a09e8d82ba4b886f8e90eec038735d759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e8d82ba4b886f8e90eec038735d759">&#9670;&#160;</a></span>cb_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_pop_front </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pops a specified number of tiles from the front of the specified CB. This also frees this number of tiles in the circular buffer. This call is used by the consumer to free up the space in the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of reading of the tile data from the CB does not free up the space in the CB. Waiting on available tiles and popping them is separated in order to allow the consumer to: 1) read the tile data from the CB via multiple reads of sub-tiles 2) access the tiles (or their sub-tiles) that are visible to the consumer by random access of the valid section of the CB</p>
<p>Important note: This operation updates the read pointer of the CB, the CB pointer can only be updated from one thread at a time. Example: if compute kernel has cb_pop_front(input_id, 1) and writer kernel also has cb_pop_front(input_id, 1), these calls will produce non-deterministic behavior because cb pointers are not synchronized across threads. Per circular buffer index, only have one thread pop tiles to update the read pointer</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ntiles   </td><td class="markdownTableBodyNone">The number of tiles to be popped   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af6f81e4da52b94a5397f904d446808c9" name="af6f81e4da52b94a5397f904d446808c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f81e4da52b94a5397f904d446808c9">&#9670;&#160;</a></span>cb_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_push_back </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pushes a given number of tiles in the back of the specified CB’s queue. Decreases the available space in the circular buffer by this number of tiles. This call is used by the producer to make the tiles visible to the consumer of the CB.</p>
<p>We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.</p>
<p>Note that the act of writing the tile data into the CB does not make the tiles visible to the consumer. Writing of the tiles and pushing is separated to allow the producer to: 1) write the tile data to the CB via multiple writes of sub-tiles 2) modify tiles (or sub-tiles) by random access of the valid section of the CB</p>
<p>Important note: This operation updates the write pointer of the CB, the CB pointer can only be updated from one thread at a time. Example: if compute kernel has cb_push_back(output_id, 1) and reader kernel also has cb_push_back(output_id, 1), these calls will produce non-deterministic behavior because cb pointers are not synchronized across threads. Per circular buffer index, only have one thread push tiles to update the write pointer</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ntiles   </td><td class="markdownTableBodyNone">The number of tiles to be pushed   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ab833f2a940d6668f992dd77ca06ed03d" name="ab833f2a940d6668f992dd77ca06ed03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab833f2a940d6668f992dd77ca06ed03d">&#9670;&#160;</a></span>cb_release_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_release_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cb_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks UNPACK thread on UNPACK_OPERAND_SYNC semaphore being decremented by MATH and PACK threads.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="af917245b58bfd6176048dc6844a7b7fe" name="af917245b58bfd6176048dc6844a7b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af917245b58bfd6176048dc6844a7b7fe">&#9670;&#160;</a></span>cb_reserve_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_reserve_back </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be free in the specified circular buffer. This call is used by the producer to wait for the consumer to consume (ie. free up) the specified number of tiles.</p>
<p>CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ntiles   </td><td class="markdownTableBodyNone">The number of free tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a2d20635facce5ae4c7ee121028740b38" name="a2d20635facce5ae4c7ee121028740b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d20635facce5ae4c7ee121028740b38">&#9670;&#160;</a></span>cb_wait_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cb_wait_front </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A blocking call that waits for the specified number of tiles to be available in the specified circular buffer (CB). This call is used by the consumer of the CB to wait for the producer to fill the CB with at least the specfied number of tiles. Important note: in case multiple calls of cb_wait_front(n) are issued without a paired <a class="el" href="namespaceckernel.html#a09e8d82ba4b886f8e90eec038735d759">cb_pop_front()</a> call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example: 4 calls of cb_wait_front(8) followed by a cb_pop_front(32) would produce incorrect behavior. Instead 4 calls of <a class="el" href="namespaceckernel.html#a2d20635facce5ae4c7ee121028740b38">cb_wait_front()</a> waiting on 8, 16, 24, 32 tiles should be issued.</p>
<p>Important note: number of tiles used in all cb_* calls must evenly divide the cb size and must be the same number in all cb_wait_front calls in the same kernel. Example 1: cb_wait_front(32), cb_wait_front(40), cb_pop_front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2: cb_wait_front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.</p>
<p>Important note: CB total size must be an even multiple of the argument passed to this call.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cb_id   </td><td class="markdownTableBodyNone">The index of the cirular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ntiles   </td><td class="markdownTableBodyNone">The number of tiles to wait for   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a8babb406a90ed09abdce7a53d3e20b84" name="a8babb406a90ed09abdce7a53d3e20b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8babb406a90ed09abdce7a53d3e20b84">&#9670;&#160;</a></span>clear_compute_special_value_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::clear_compute_special_value_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a567258ec8567e874535c0e9017e0ca64" name="a567258ec8567e874535c0e9017e0ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567258ec8567e874535c0e9017e0ca64">&#9670;&#160;</a></span>copy_block_matmul_partials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::copy_block_matmul_partials </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_in_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_dst_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a150166792eaa318a5837165e71e8b44c" name="a150166792eaa318a5837165e71e8b44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150166792eaa318a5837165e71e8b44c">&#9670;&#160;</a></span>copy_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::copy_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_tile_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a single tile from the specified input CB and writes the result to DST at a specified index. The function will employ unpacker to first unpack into SRC registers and then perform move into DST registers, at a specified index. For the in_tile_index to be valid for this call, cb_wait_front(n) had to be previously called to ensure that at least some number n&gt;0 of tiles are available in the input CB. The CB index 0 then references the first tile in the received section of the CB, up to index n-1 (in a FIFO order). The DST register buffer must be in acquired state via acquire_dst call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Data type   </th><th class="markdownTableHeadNone">Valid range   </th><th class="markdownTableHeadNone">required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in_cb_id   </td><td class="markdownTableBodyNone">The identifier of the source circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in_tile_index   </td><td class="markdownTableBodyNone">The index of the tile to copy from the input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in the DST register   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register (16)   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="aea570483ca5371db26adbdb562bdc640" name="aea570483ca5371db26adbdb562bdc640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea570483ca5371db26adbdb562bdc640">&#9670;&#160;</a></span>copy_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::copy_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a init for the copy tile operation. This calls the short init function and initializes packer dst offset registers. </p>

</div>
</div>
<a id="aee656afd9be0e1341190c24a349fe54e" name="aee656afd9be0e1341190c24a349fe54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee656afd9be0e1341190c24a349fe54e">&#9670;&#160;</a></span>copy_tile_to_dst_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::copy_tile_to_dst_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cbid</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the init short for copy tile. This does not reconfigure the unpacker data types. Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cbid   </td><td class="markdownTableBodyNone">The identifier of the input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">Flag to perform transpose on SrcA   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a4de2f4f17e04dc5219e09945e754c6a9" name="a4de2f4f17e04dc5219e09945e754c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de2f4f17e04dc5219e09945e754c6a9">&#9670;&#160;</a></span>copy_tile_to_dst_init_short_with_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::copy_tile_to_dst_init_short_with_dt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>old_cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>new_cbid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">old_cbid   </td><td class="markdownTableBodyNone">The identifier of the previous input circular buffer (CB) to SrcA   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">new_cbid   </td><td class="markdownTableBodyNone">The identifier of the new input circular buffer (CB) to SrcA   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">Flag to perform transpose on SrcA   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="aeb6b37aa28157a3c79780f7053d752f2" name="aeb6b37aa28157a3c79780f7053d752f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6b37aa28157a3c79780f7053d752f2">&#9670;&#160;</a></span>cos_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cos_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the trigonometric cosine operation on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="abf68d57fea4010334471559c44e7b8b5" name="abf68d57fea4010334471559c44e7b8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf68d57fea4010334471559c44e7b8b5">&#9670;&#160;</a></span>cos_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::cos_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a27956d536797fa0c3dad4eab6148d731" name="a27956d536797fa0c3dad4eab6148d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27956d536797fa0c3dad4eab6148d731">&#9670;&#160;</a></span>dbg_halt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::dbg_halt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the cores so that the debug interface can be used to inspect the value of the registers.</p>
<p>Return value: None </p>

</div>
</div>
<a id="a5df20a0a40dac9e97e6b73b0d4fd0c88" name="a5df20a0a40dac9e97e6b73b0d4fd0c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df20a0a40dac9e97e6b73b0d4fd0c88">&#9670;&#160;</a></span>dbg_read_dest_acc_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::dbg_read_dest_acc_row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rd_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the contents of the specified row of the destination register. It reads 8 dwords at a time.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">row_addr   </td><td class="markdownTableBodyNone">The row address in the destination register to read   </td><td class="markdownTableBodyNone">int   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rd_data   </td><td class="markdownTableBodyNone">The array of 8 dwords to store the data   </td><td class="markdownTableBodyNone">uint32_t*   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>
<p>Return value: None </p>

</div>
</div>
<a id="aa73b548e1869c77a4b1d2a4a345b942d" name="aa73b548e1869c77a4b1d2a4a345b942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73b548e1869c77a4b1d2a4a345b942d">&#9670;&#160;</a></span>dbg_unhalt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::dbg_unhalt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes the execution of the cores after a debug halt.</p>
<p>Return value: None </p>

</div>
</div>
<a id="a7be3d49aef6238fcf0fe4dc67868d3bd" name="a7be3d49aef6238fcf0fe4dc67868d3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be3d49aef6238fcf0fe4dc67868d3bd">&#9670;&#160;</a></span>elu_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::elu_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of elu (relu(x) + slope*(exp(x) - 1)*(x &lt;= 0 )) on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">slope   </td><td class="markdownTableBodyNone">slope used in elu calculation   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Greater than 0   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a53917e4947e7f3de1c5ef5d1a22aecbc" name="a53917e4947e7f3de1c5ef5d1a22aecbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53917e4947e7f3de1c5ef5d1a22aecbc">&#9670;&#160;</a></span>elu_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::elu_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a77afa61bee15eebd67803d76c955f360" name="a77afa61bee15eebd67803d76c955f360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77afa61bee15eebd67803d76c955f360">&#9670;&#160;</a></span>eqz_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::eqz_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element of a equal to zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a688933a08b41a8d5d283aa75216eae27" name="a688933a08b41a8d5d283aa75216eae27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688933a08b41a8d5d283aa75216eae27">&#9670;&#160;</a></span>eqz_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::eqz_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ab2e2745c2e1e812179a659ffac84f231" name="ab2e2745c2e1e812179a659ffac84f231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e2745c2e1e812179a659ffac84f231">&#9670;&#160;</a></span>erf_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erf_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of error function on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a457fed1c2f71b59d1949d93479d54f8c" name="a457fed1c2f71b59d1949d93479d54f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457fed1c2f71b59d1949d93479d54f8c">&#9670;&#160;</a></span>erf_tile_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erf_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a262be4a133a92ad6d55e6f505dfce753" name="a262be4a133a92ad6d55e6f505dfce753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262be4a133a92ad6d55e6f505dfce753">&#9670;&#160;</a></span>erfc_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erfc_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of complimentary error function on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a8d55d9b6ac18b93104f4cddf6da7aea1" name="a8d55d9b6ac18b93104f4cddf6da7aea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55d9b6ac18b93104f4cddf6da7aea1">&#9670;&#160;</a></span>erfc_tile_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erfc_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="acd09eba45c8dd3c153752330aa240433" name="acd09eba45c8dd3c153752330aa240433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd09eba45c8dd3c153752330aa240433">&#9670;&#160;</a></span>erfinv_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erfinv_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the inverse of the error function on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ab511b6e54d4686ab30c35b169dadac56" name="ab511b6e54d4686ab30c35b169dadac56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab511b6e54d4686ab30c35b169dadac56">&#9670;&#160;</a></span>erfinv_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::erfinv_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a2febadfd150cb455955f67746253f116" name="a2febadfd150cb455955f67746253f116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2febadfd150cb455955f67746253f116">&#9670;&#160;</a></span>exp2_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::exp2_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of 2^x value where x is each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aae54e275fe6d550c7cb151f24503e958" name="aae54e275fe6d550c7cb151f24503e958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae54e275fe6d550c7cb151f24503e958">&#9670;&#160;</a></span>exp2_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::exp2_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="acf8ada6cea1eb5bfefab73dcf6f3b7a5" name="acf8ada6cea1eb5bfefab73dcf6f3b7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8ada6cea1eb5bfefab73dcf6f3b7a5">&#9670;&#160;</a></span>exp_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::exp_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of exponential on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fast_and_approx   </td><td class="markdownTableBodyNone">Computation to be done faster and approximate   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="acd7b870d401c7fbed7ae21f8a6616019" name="acd7b870d401c7fbed7ae21f8a6616019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b870d401c7fbed7ae21f8a6616019">&#9670;&#160;</a></span>exp_tile_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::exp_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a44e2f1766f4513494f768cffa10b0737" name="a44e2f1766f4513494f768cffa10b0737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e2f1766f4513494f768cffa10b0737">&#9670;&#160;</a></span>expm1_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::expm1_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of exp(x) - 1, v where x is each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a7168260d89bae9c8cd208b0a636dc1bf" name="a7168260d89bae9c8cd208b0a636dc1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7168260d89bae9c8cd208b0a636dc1bf">&#9670;&#160;</a></span>expm1_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::expm1_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a572012591ff76c4277ed48036399de6e" name="a572012591ff76c4277ed48036399de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572012591ff76c4277ed48036399de6e">&#9670;&#160;</a></span>gelu_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gelu_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of gelu on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fast_and_approx   </td><td class="markdownTableBodyNone">Computation to be done faster and approximate   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a2e0f2cefbe52082482d71f807145de1e" name="a2e0f2cefbe52082482d71f807145de1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0f2cefbe52082482d71f807145de1e">&#9670;&#160;</a></span>gelu_tile_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gelu_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9a04b6745953bbc4da3c410db3497e39" name="a9a04b6745953bbc4da3c410db3497e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a04b6745953bbc4da3c410db3497e39">&#9670;&#160;</a></span>get_compute_special_value_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ckernel::get_compute_special_value_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab82cfb17a7aa5f2e577dccb8a109b6a1" name="ab82cfb17a7aa5f2e577dccb8a109b6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82cfb17a7aa5f2e577dccb8a109b6a1">&#9670;&#160;</a></span>get_compute_special_value_flags_fpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ckernel::get_compute_special_value_flags_fpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>special_value_flags_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b5b8e81326c471d528729eaa179120c" name="a2b5b8e81326c471d528729eaa179120c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5b8e81326c471d528729eaa179120c">&#9670;&#160;</a></span>get_compute_special_value_flags_sfpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ckernel::get_compute_special_value_flags_sfpu </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>special_value_flags_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51558a724938976ece1be18997ced97f" name="a51558a724938976ece1be18997ced97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51558a724938976ece1be18997ced97f">&#9670;&#160;</a></span>gez_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gez_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element is greater than or equal to zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a4e1406d244d304ea48ce12568911df7f" name="a4e1406d244d304ea48ce12568911df7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1406d244d304ea48ce12568911df7f">&#9670;&#160;</a></span>gez_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gez_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ade26cd0bc2247bd4eaf7685eadb88afd" name="ade26cd0bc2247bd4eaf7685eadb88afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade26cd0bc2247bd4eaf7685eadb88afd">&#9670;&#160;</a></span>gtz_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gtz_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element is greater than zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae9e6fe3d6395ed10fe6c1a3774d0c591" name="ae9e6fe3d6395ed10fe6c1a3774d0c591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e6fe3d6395ed10fe6c1a3774d0c591">&#9670;&#160;</a></span>gtz_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::gtz_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ad36c2e30b06007215d6b69568691ed3f" name="ad36c2e30b06007215d6b69568691ed3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36c2e30b06007215d6b69568691ed3f">&#9670;&#160;</a></span>heaviside_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::heaviside_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of: y = 0 if x &lt; 0 , 1 if x &gt; 0 , y= value where x is each element of a tile in DST register at index tile_index. The value is provided as const param0 The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">The value the output is if the input is greater than 0   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="abb18b07f6934634afcb9ed022b36d858" name="abb18b07f6934634afcb9ed022b36d858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb18b07f6934634afcb9ed022b36d858">&#9670;&#160;</a></span>heaviside_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::heaviside_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a08de262ccd14cf8a88f2e74a4d5c5713" name="a08de262ccd14cf8a88f2e74a4d5c5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08de262ccd14cf8a88f2e74a4d5c5713">&#9670;&#160;</a></span>i0_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::i0_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the zeroth order modified Bessel function of the first kind on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa81bbfe5f0f38c17b58d56562e3ec734" name="aa81bbfe5f0f38c17b58d56562e3ec734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81bbfe5f0f38c17b58d56562e3ec734">&#9670;&#160;</a></span>i0_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::i0_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a87794bafca1824e6e8e8a4d8a9f0465c" name="a87794bafca1824e6e8e8a4d8a9f0465c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87794bafca1824e6e8e8a4d8a9f0465c">&#9670;&#160;</a></span>init_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;EltwiseBinaryType tBcastOp, BroadcastType tBcastDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::init_bcast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associated init function that must be called before calling a bcast op.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The indentifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ocb   </td><td class="markdownTableBodyNone">The indentifier of the circular buffer (CB) containing output   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="afb0329908fbe83bd7dc85fe97d621520" name="afb0329908fbe83bd7dc85fe97d621520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0329908fbe83bd7dc85fe97d621520">&#9670;&#160;</a></span>isfinite_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isfinite_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if the input tile is finite The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a475741e5433ee1dc3173fd791b88aa9c" name="a475741e5433ee1dc3173fd791b88aa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475741e5433ee1dc3173fd791b88aa9c">&#9670;&#160;</a></span>isfinite_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isfinite_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a560cbe71d63208236a384c40e6da61a7" name="a560cbe71d63208236a384c40e6da61a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560cbe71d63208236a384c40e6da61a7">&#9670;&#160;</a></span>isinf_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isinf_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if the input tile is infinity. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aff15ecc59d70682ad19f46ae6b3ab169" name="aff15ecc59d70682ad19f46ae6b3ab169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff15ecc59d70682ad19f46ae6b3ab169">&#9670;&#160;</a></span>isinf_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isinf_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a7cb289937576f99d689c1e0340aaa89b" name="a7cb289937576f99d689c1e0340aaa89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb289937576f99d689c1e0340aaa89b">&#9670;&#160;</a></span>isnan_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isnan_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if the input tile is nan. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a753c8882bdd2d9d5ee76f5261143df24" name="a753c8882bdd2d9d5ee76f5261143df24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753c8882bdd2d9d5ee76f5261143df24">&#9670;&#160;</a></span>isnan_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isnan_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a023d3466cbf2b6d0bb6519164f058137" name="a023d3466cbf2b6d0bb6519164f058137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023d3466cbf2b6d0bb6519164f058137">&#9670;&#160;</a></span>isneginf_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isneginf_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if the input tile is negative infinity. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a6293738625933a80a8d3be6ea9090c97" name="a6293738625933a80a8d3be6ea9090c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6293738625933a80a8d3be6ea9090c97">&#9670;&#160;</a></span>isneginf_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isneginf_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9abe529c6f48dc47b3590bddc44f75b9" name="a9abe529c6f48dc47b3590bddc44f75b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abe529c6f48dc47b3590bddc44f75b9">&#9670;&#160;</a></span>isposinf_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isposinf_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if the input tile is positive infinity. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a4903e99b9ac3930660daa6210989adc8" name="a4903e99b9ac3930660daa6210989adc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4903e99b9ac3930660daa6210989adc8">&#9670;&#160;</a></span>isposinf_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::isposinf_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a8f979e18403c78aab904f362ec748f7e" name="a8f979e18403c78aab904f362ec748f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f979e18403c78aab904f362ec748f7e">&#9670;&#160;</a></span>leaky_relu_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::leaky_relu_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of leaky relu (relu(x) + slope*-relu(-x)) on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">slope   </td><td class="markdownTableBodyNone">slope used in leaky relu - will reinterpret unsigned int to float   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Greater than 0   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ac696b79d37bcb5188163ffb166566ca6" name="ac696b79d37bcb5188163ffb166566ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac696b79d37bcb5188163ffb166566ca6">&#9670;&#160;</a></span>leaky_relu_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::leaky_relu_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a1817972ea6391813a8948bfad83ab981" name="a1817972ea6391813a8948bfad83ab981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1817972ea6391813a8948bfad83ab981">&#9670;&#160;</a></span>lez_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::lez_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element is less than or equal to zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a5ce91ef9087a7c7216fbe8032dafa49e" name="a5ce91ef9087a7c7216fbe8032dafa49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce91ef9087a7c7216fbe8032dafa49e">&#9670;&#160;</a></span>lez_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::lez_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a39e0a5fd307d540f06493088cf39a4f0" name="a39e0a5fd307d540f06493088cf39a4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0a5fd307d540f06493088cf39a4f0">&#9670;&#160;</a></span>log_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::log_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of logarithm on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a9b586e3fde261f186ba8f0e2053a99b1" name="a9b586e3fde261f186ba8f0e2053a99b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b586e3fde261f186ba8f0e2053a99b1">&#9670;&#160;</a></span>log_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::log_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a3275407181325047284ab43e349a63b2" name="a3275407181325047284ab43e349a63b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3275407181325047284ab43e349a63b2">&#9670;&#160;</a></span>log_with_base_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::log_with_base_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of logarithm with a specified base on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">base_scale   </td><td class="markdownTableBodyNone">The log base   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Postive integers   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a1c75f0f070bb3d196be28db50ec60bcd" name="a1c75f0f070bb3d196be28db50ec60bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c75f0f070bb3d196be28db50ec60bcd">&#9670;&#160;</a></span>log_with_base_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::log_with_base_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a8eb2237676286e9427ec296e6cc5ab26" name="a8eb2237676286e9427ec296e6cc5ab26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb2237676286e9427ec296e6cc5ab26">&#9670;&#160;</a></span>logical_not_unary_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::logical_not_unary_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the logical not unary operation on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aea8c76b173d12fc2c8d4b6a69268fd90" name="aea8c76b173d12fc2c8d4b6a69268fd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8c76b173d12fc2c8d4b6a69268fd90">&#9670;&#160;</a></span>logical_not_unary_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::logical_not_unary_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ae87b691c6559e7b1435d83403abc4301" name="ae87b691c6559e7b1435d83403abc4301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87b691c6559e7b1435d83403abc4301">&#9670;&#160;</a></span>ltz_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::ltz_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element of a tile is less than zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa89f5e45a5227a1378526b21be12d62e" name="aa89f5e45a5227a1378526b21be12d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89f5e45a5227a1378526b21be12d62e">&#9670;&#160;</a></span>ltz_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::ltz_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="aaf96a5576438c50eba97c7669ec2ebdb" name="aaf96a5576438c50eba97c7669ec2ebdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf96a5576438c50eba97c7669ec2ebdb">&#9670;&#160;</a></span>matmul_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::matmul_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ct_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rt_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kt_dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs block-sized matrix multiplication <em>C=A*B</em> between the blocks in two different input CBs and writes the result to DST. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in block A from the first input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in block B from the second input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST REG to which the result C will be written.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">The transpose flag for performing transpose operation on tiles in B.   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Must be true or false   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ct_dim   </td><td class="markdownTableBodyNone">The coloumn dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block B column dimension   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rt_dim   </td><td class="markdownTableBodyNone">The row dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A row dimension   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kt_dim   </td><td class="markdownTableBodyNone">The inner dimension.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A column dimension   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aac63a0fae82e1b790a1f6b3a3d8d600f" name="aac63a0fae82e1b790a1f6b3a3d8d600f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac63a0fae82e1b790a1f6b3a3d8d600f">&#9670;&#160;</a></span>matmul_pack_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::matmul_pack_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifrom_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ntiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a block of tiles from the DST register buffer at a start index to a specified CB at a given start index. cb_reserve_back(n) had to be called first to reserve at least some number n&gt;0 of tiles in the output CB. The out_tile_index = 0 then references the first tile in the reserved section of the CB, up to index n-1 that will then be visible to the consumer in the same order after a cb_push_back call. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Each subsequent pack call will increment the write pointer in the cb by ntiles size. The pointer is then again set to a valid position with space for n reserved tiles by another cb_reserve_back call.</p>
<p>Operates in tandem with functions cb_reserve_back and cb_push_back.</p>
<p>A typical use case is first the producer ensures that there is a number of tiles available in the buffer via cb_reserve_back, then the producer uses the matmul_pack_tile call to copy a block of tiles from the DST slots to the slots in reserved space and finally cb_push_back is called to announce visibility of the reserved section of the circular buffer to the consumer.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ifrom_dst   </td><td class="markdownTableBodyNone">The index of the tile in the DST register   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register (16)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb   </td><td class="markdownTableBodyNone">The identifier of the output circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ntiles   </td><td class="markdownTableBodyNone">The number of tiles to copy from DST to CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae3b5c274614aec08a77df1f78829c39d" name="ae3b5c274614aec08a77df1f78829c39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b5c274614aec08a77df1f78829c39d">&#9670;&#160;</a></span>matmul_tiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::matmul_tiles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_tile_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs tile-sized matrix multiplication <em>C=A*B</em> between the tiles in two specified input CBs and writes the result to DST. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of the tile A from the first input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of the tile B from the second input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG to which the result C will be written.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a11c225636a89c5fbc8e3ab0f17902f88" name="a11c225636a89c5fbc8e3ab0f17902f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c225636a89c5fbc8e3ab0f17902f88">&#9670;&#160;</a></span>matmul_tiles_math()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint32_t num_faces = 4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::matmul_tiles_math </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs tile-sized matrix multiplication <em>C=A*B</em> between the tiles located in SRCA and SRCB and writes the result to DST. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST REG to which the result C will be written.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a2d1714bd980954724d51080e29b5d0fd" name="a2d1714bd980954724d51080e29b5d0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1714bd980954724d51080e29b5d0fd">&#9670;&#160;</a></span>max_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::max_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of max value on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>TODO: fix idst1. currently idst1 is not used and (idst0 + 1) is used for max. because don't know how to use 2 dst register with sfpu.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst0   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">idst1   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a92ba747a6e5b80c727984c62b7d0056e" name="a92ba747a6e5b80c727984c62b7d0056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ba747a6e5b80c727984c62b7d0056e">&#9670;&#160;</a></span>max_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::max_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="af455b928c9eb2b460ea9d3816f84c652" name="af455b928c9eb2b460ea9d3816f84c652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af455b928c9eb2b460ea9d3816f84c652">&#9670;&#160;</a></span>mm_block_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_block_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>out_cb_id</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ct_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rt_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kt_dim</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization for matmul_block operation. Must be called before matmul_block.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">out_cb_id   </td><td class="markdownTableBodyNone">The identifier of the output circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ct_dim   </td><td class="markdownTableBodyNone">the number of columns of the output matrix in tiles   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 8 in half-sync mode, 1 to 16 in full-sync mode   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rt_dim   </td><td class="markdownTableBodyNone">the number of rows of the output matrix in tiles   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 8 in half-sync mode, 1 to 16 in full-sync mode   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kt_dim   </td><td class="markdownTableBodyNone">the inner dim of the input matrices in tiles   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 2^32-1   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a6a95a903f77a9f781fbabd4f083b743f" name="a6a95a903f77a9f781fbabd4f083b743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95a903f77a9f781fbabd4f083b743f">&#9670;&#160;</a></span>mm_block_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_block_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ct_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rt_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kt_dim</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A short version of matmul_block initialization. Configure the unpacker and math engine to matmul mode.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">The transpose flag for performing transpose operation on B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ct_dim   </td><td class="markdownTableBodyNone">The coloumn dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block B column dimension   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rt_dim   </td><td class="markdownTableBodyNone">The row dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A row dimension   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kt_dim   </td><td class="markdownTableBodyNone">The inner dimension.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A column dimension   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a0ae4aa02b645cb258c3c763d4ffc5c1c" name="a0ae4aa02b645cb258c3c763d4ffc5c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae4aa02b645cb258c3c763d4ffc5c1c">&#9670;&#160;</a></span>mm_block_init_short_with_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_block_init_short_with_dt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>old_in1_cb_id</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ct_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rt_dim</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>kt_dim</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A short version of matmul_block initialization. It is used to reconfigure srcA of the compute engine back to matmul mode.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">old_in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the old in1_cb_id circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ct_dim   </td><td class="markdownTableBodyNone">The coloumn dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block B column dimension   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rt_dim   </td><td class="markdownTableBodyNone">The row dimension for the output block.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A row dimension   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kt_dim   </td><td class="markdownTableBodyNone">The inner dimension.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be equal to block A column dimension   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="adeadefda1b391d2924a635b87f264c9f" name="adeadefda1b391d2924a635b87f264c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeadefda1b391d2924a635b87f264c9f">&#9670;&#160;</a></span>mm_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>out_cb_id</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization for matmul_tiles operation. Must be called before matmul_tiles.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">out_cb_id   </td><td class="markdownTableBodyNone">The identifier of the output circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">The transpose flag for performing transpose operation on B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a035a5d432eee641ae14275669d349f9e" name="a035a5d432eee641ae14275669d349f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035a5d432eee641ae14275669d349f9e">&#9670;&#160;</a></span>mm_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A short version of matmul_tiles initialization. Configure the unpacker and math engine to matmul mode.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">The transpose flag for performing transpose operation on B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="acc9da9bf23131b50fcd49cff381df661" name="acc9da9bf23131b50fcd49cff381df661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9da9bf23131b50fcd49cff381df661">&#9670;&#160;</a></span>mm_init_short_with_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mm_init_short_with_dt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in0_cb_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>in1_cb_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>c_in_old_srca</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A short version of matmul_tiles initialization. It is used to reconfigure srcA of the compute engine back to matmul mode.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the first input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the second input circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">c_in_old_srca   </td><td class="markdownTableBodyNone">The identifier of the old input to src A circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose   </td><td class="markdownTableBodyNone">The transpose flag for performing transpose operation on B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Any positive value will indicate tranpose is set   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="aab5aa9bbc1b46b6135b629d0f1278a86" name="aab5aa9bbc1b46b6135b629d0f1278a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5aa9bbc1b46b6135b629d0f1278a86">&#9670;&#160;</a></span>mul_bcast_cols_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_bcast_cols_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for mul_bcast_cols to be executed correctly. </p>

</div>
</div>
<a id="afb428b7e7ac6982665a7facc912fd9a5" name="afb428b7e7ac6982665a7facc912fd9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb428b7e7ac6982665a7facc912fd9a5">&#9670;&#160;</a></span>mul_bcast_rows_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_bcast_rows_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a switch-from-another-op tile hw reconfiguration step needed for mul_bcast_rows to be executed correctly. </p>

</div>
</div>
<a id="a5d86448b624a24f6bf77c45334590835" name="a5d86448b624a24f6bf77c45334590835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d86448b624a24f6bf77c45334590835">&#9670;&#160;</a></span>mul_tiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise multiplication C=A*B of tiles in two CBs at given indices and writes the result to the DST register at index dst_tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of tile B within the second CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result C   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="abcb3059dafd1abba339a9ab4218bf873" name="abcb3059dafd1abba339a9ab4218bf873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb3059dafd1abba339a9ab4218bf873">&#9670;&#160;</a></span>mul_tiles_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BroadcastType tBcastDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_bcast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for <em>add_tiles_bcast</em>. </p>

</div>
</div>
<a id="aec9c6f83f3bb8ee245c6e81d78512498" name="aec9c6f83f3bb8ee245c6e81d78512498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9c6f83f3bb8ee245c6e81d78512498">&#9670;&#160;</a></span>mul_tiles_bcast_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_bcast_cols </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand template instantiation of mul_tiles_bcast. </p>

</div>
</div>
<a id="a676bdf18fdcf79931c618493b7b06438" name="a676bdf18fdcf79931c618493b7b06438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676bdf18fdcf79931c618493b7b06438">&#9670;&#160;</a></span>mul_tiles_bcast_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_bcast_rows </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand template instantiation of mul_tiles_bcast. </p>

</div>
</div>
<a id="aadf053fb4909a8dde19f43d65823a784" name="aadf053fb4909a8dde19f43d65823a784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf053fb4909a8dde19f43d65823a784">&#9670;&#160;</a></span>mul_tiles_bcast_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_bcast_scalar </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a broadcast-multiply of a tile from icb0[itile0] with a scalar encoded as a tile from icb1[itile1]. </p>

</div>
</div>
<a id="ab35ea7911483802a312e9d8667316bc4" name="ab35ea7911483802a312e9d8667316bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ea7911483802a312e9d8667316bc4">&#9670;&#160;</a></span>mul_tiles_bcast_scalar_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_bcast_scalar_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for mul_bcast_cols to be executed correctly. </p>

</div>
</div>
<a id="a5d7722fc6c62a98e87aa80dfd4addc04" name="a5d7722fc6c62a98e87aa80dfd4addc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7722fc6c62a98e87aa80dfd4addc04">&#9670;&#160;</a></span>mul_tiles_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="af20703c9d347ca4c998ca32e38762cd5" name="af20703c9d347ca4c998ca32e38762cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20703c9d347ca4c998ca32e38762cd5">&#9670;&#160;</a></span>mul_tiles_init_f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::mul_tiles_init_f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. f means high fidelity with resepect to accuracy this is set during createprogram </p>

</div>
</div>
<a id="a114da0de25df24111f54d4ae54daf716" name="a114da0de25df24111f54d4ae54daf716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114da0de25df24111f54d4ae54daf716">&#9670;&#160;</a></span>nez_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::nez_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core True if each element is not equal to zero. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a724bcc13c2cecd7e12e2efbd31207b8f" name="a724bcc13c2cecd7e12e2efbd31207b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724bcc13c2cecd7e12e2efbd31207b8f">&#9670;&#160;</a></span>nez_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::nez_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9bf446c6f981d4fac592dd761236d013" name="a9bf446c6f981d4fac592dd761236d013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf446c6f981d4fac592dd761236d013">&#9670;&#160;</a></span>pack_reconfig_data_format() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::pack_reconfig_data_format </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>new_operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure packer output data format. </p>

</div>
</div>
<a id="aa72f60c412aeb6d07dfc4b72e1c6370d" name="aa72f60c412aeb6d07dfc4b72e1c6370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72f60c412aeb6d07dfc4b72e1c6370d">&#9670;&#160;</a></span>pack_reconfig_data_format() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::pack_reconfig_data_format </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>old_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>new_operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure packer output data format. </p>

</div>
</div>
<a id="ad0c6749f2bb88aafc343a6bd67911d66" name="ad0c6749f2bb88aafc343a6bd67911d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c6749f2bb88aafc343a6bd67911d66">&#9670;&#160;</a></span>pack_reconfig_l1_acc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::pack_reconfig_l1_acc </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>l1_acc_en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure packer l1 accumulation flag </p>

</div>
</div>
<a id="a63c43acd48809eac8f0fd79a09cac7b7" name="a63c43acd48809eac8f0fd79a09cac7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c43acd48809eac8f0fd79a09cac7b7">&#9670;&#160;</a></span>pack_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool out_of_order_output = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::pack_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ifrom_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>output_tile_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a single tile from the DST register buffer at a specified index to a specified CB at a given index. For the out_tile_index to be valid for this call, cb_reserve_back(n) has to be called first to reserve at least some number n &gt; 0 of tiles in the output CB. out_tile_index = 0 then references the first tile in the reserved section of the CB, up to index n - 1, which will then be visible to the consumer in the same order after a cb_push_back call. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Each subsequent pack call will increment the write pointer in the cb by single tile size. The pointer is then again set to a valid position with space for n reserved tiles by another cb_reserve_back call.</p>
<p>Operates in tandem with functions cb_reserve_back and cb_push_back.</p>
<p>A typical use case is first the producer ensures that there is a number of tiles available in the buffer via cb_reserve_back, then the producer uses the pack_tile call to copy a tile from one of DST slots to a slot in reserved space and finally cb_push_back is called to announce visibility of the reserved section of the circular buffer to the consumer.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ifrom_dst   </td><td class="markdownTableBodyNone">The index of the tile in the DST register   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register (16)   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb   </td><td class="markdownTableBodyNone">The identifier of the output circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb_tile   </td><td class="markdownTableBodyNone">The index of the tile in the output CB to copy to   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a61fe18515827e58bdfea82fa99daee38" name="a61fe18515827e58bdfea82fa99daee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fe18515827e58bdfea82fa99daee38">&#9670;&#160;</a></span>power_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::power_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of power operation (x ^(const param0)) value on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">The value of the exponent in the power operation   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a7cd6f51f9220905884e315442843d2d2" name="a7cd6f51f9220905884e315442843d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd6f51f9220905884e315442843d2d2">&#9670;&#160;</a></span>power_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::power_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a31441a86e04985c013f03fca3c59f55d" name="a31441a86e04985c013f03fca3c59f55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31441a86e04985c013f03fca3c59f55d">&#9670;&#160;</a></span>recip_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::recip_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the reciprocal on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine. Only works for Float32, Float16_b, Bfp8_b data formats for full accuracy.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a506824a7a457435e622ba1fffc8d8678" name="a506824a7a457435e622ba1fffc8d8678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506824a7a457435e622ba1fffc8d8678">&#9670;&#160;</a></span>recip_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::recip_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9a5800c870a89695e8de483bfdec9d8c" name="a9a5800c870a89695e8de483bfdec9d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5800c870a89695e8de483bfdec9d8c">&#9670;&#160;</a></span>reconfig_data_format() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_new_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_new_operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srca and srcb data formats. </p>

</div>
</div>
<a id="a94bb6b25a9a51fd1949d929fecd4e1a8" name="a94bb6b25a9a51fd1949d929fecd4e1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb6b25a9a51fd1949d929fecd4e1a8">&#9670;&#160;</a></span>reconfig_data_format() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_old_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_new_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_old_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_new_operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srca/srcb data formats, only if they differ from existing formats. </p>

</div>
</div>
<a id="a0bb205e7b72524a5e756c97070b2f75e" name="a0bb205e7b72524a5e756c97070b2f75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb205e7b72524a5e756c97070b2f75e">&#9670;&#160;</a></span>reconfig_data_format_srca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format_srca </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_new_operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srca data format. </p>

</div>
</div>
<a id="aaa0577f32a4e70d8ab0d4bbc70e929bc" name="aaa0577f32a4e70d8ab0d4bbc70e929bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0577f32a4e70d8ab0d4bbc70e929bc">&#9670;&#160;</a></span>reconfig_data_format_srca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format_srca </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_old_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srca_new_operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srca input data format, only if it differs from existing format. </p>

</div>
</div>
<a id="a920d5a56cc4204d7fb4dae0c0629e8d1" name="a920d5a56cc4204d7fb4dae0c0629e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920d5a56cc4204d7fb4dae0c0629e8d1">&#9670;&#160;</a></span>reconfig_data_format_srcb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format_srcb </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_new_operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srcb input data format. </p>

</div>
</div>
<a id="a261d53be7d210e871741821a126c34d3" name="a261d53be7d210e871741821a126c34d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261d53be7d210e871741821a126c34d3">&#9670;&#160;</a></span>reconfig_data_format_srcb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool to_from_int8 = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reconfig_data_format_srcb </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_old_operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>srcb_new_operand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to reconfigure srcb input data format, only if it differs from existing format. </p>

</div>
</div>
<a id="a3d6b64a03989f4fd9c3a8755bae1f370" name="a3d6b64a03989f4fd9c3a8755bae1f370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6b64a03989f4fd9c3a8755bae1f370">&#9670;&#160;</a></span>reduce_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool at_start, PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb_scaler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04bc71a2296a8b19afdcaf438899c771" name="a04bc71a2296a8b19afdcaf438899c771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bc71a2296a8b19afdcaf438899c771">&#9670;&#160;</a></span>reduce_init_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool at_start, PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_init_delta </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a344e91c5c3a258554c507ae85dd03c" name="a1a344e91c5c3a258554c507ae85dd03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a344e91c5c3a258554c507ae85dd03c">&#9670;&#160;</a></span>reduce_init_delta_math()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_init_delta_math </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08616241482665e17211f3050e640f05" name="a08616241482665e17211f3050e640f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08616241482665e17211f3050e640f05">&#9670;&#160;</a></span>reduce_init_delta_no_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_init_delta_no_pack </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb192e99620377ed7ba18b34a1263d48" name="abb192e99620377ed7ba18b34a1263d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb192e99620377ed7ba18b34a1263d48">&#9670;&#160;</a></span>reduce_init_short()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb_scaler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13fc1a7ae6af7595b5a0a2782e4cbbbb" name="a13fc1a7ae6af7595b5a0a2782e4cbbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fc1a7ae6af7595b5a0a2782e4cbbbb">&#9670;&#160;</a></span>reduce_revert_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_revert_delta </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38f4526f08151193fd4a2b8006c3543e" name="a38f4526f08151193fd4a2b8006c3543e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f4526f08151193fd4a2b8006c3543e">&#9670;&#160;</a></span>reduce_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction operation <em>B = reduce(A)</em> using reduce_func for dimension reduction on a tile in the CB at a given index and writes the result to the DST register at index <em>dst_tile_index</em>. Reduction can be either of type <em>Reduce::R</em>, <em>Reduce::C</em> or <em>Reduce::RC</em>, identifying the dimension(s) to be reduced in size to 1. The DST register buffer must be in acquired state via <em>acquire_dst</em> call.</p>
<p>The templates takes reduce_type which can be ReduceFunc::Sum, ReduceFunc::Max and reduce_dim which can be Reduce::R, Reduce::C, Reduce::RC. They can also be specified by defines REDUCE_OP and REDUCE_DIM.</p>
<p>This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">CB for Scaling factor applied to each element of the result.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">itile0   </td><td class="markdownTableBodyNone">The index of the tile within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">itile1   </td><td class="markdownTableBodyNone">The index of the tile within the scaling factor CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a12ea45120e9ffcb785c88effcbd9e42b" name="a12ea45120e9ffcb785c88effcbd9e42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ea45120e9ffcb785c88effcbd9e42b">&#9670;&#160;</a></span>reduce_tile_math()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PoolType reduce_type = REDUCE_OP, ReduceDim reduce_dim = REDUCE_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::reduce_tile_math </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_faces</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8a1c47b441f374e4ad21ed8d2f8a4e" name="aca8a1c47b441f374e4ad21ed8d2f8a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8a1c47b441f374e4ad21ed8d2f8a4e">&#9670;&#160;</a></span>release_dst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::release_dst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function is deprecated, please use <code><a class="el" href="namespaceckernel.html#addd3679665da343bd51f76ced7154c4a">tile_regs_release()</a></code> instead. See <a href="https://github.com/tenstorrent/tt-metal/issues/5868#issuecomment-2101726935">https://github.com/tenstorrent/tt-metal/issues/5868#issuecomment-2101726935</a></dd></dl>
<p>Releases the exclusive lock on the internal DST register for the current Tensix core. This lock had to be previously acquired with acquire_dst. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<p>How the destination register will be shared and synchronized between TRISC threads will depend on the compute kernel configuration. </p>

</div>
</div>
<a id="ab022361921e28e620e0aa64449d707a8" name="ab022361921e28e620e0aa64449d707a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab022361921e28e620e0aa64449d707a8">&#9670;&#160;</a></span>relu_max_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_max_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of relu max (relu(max(x, upper_limit))) on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">upper_limit   </td><td class="markdownTableBodyNone">Upper limit of relu_min   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Greater than 0   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aebd335c04a4da54f27b29814dc3ba06c" name="aebd335c04a4da54f27b29814dc3ba06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd335c04a4da54f27b29814dc3ba06c">&#9670;&#160;</a></span>relu_max_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_max_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a2055cc5f849f59581322d4f99aafe7fd" name="a2055cc5f849f59581322d4f99aafe7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2055cc5f849f59581322d4f99aafe7fd">&#9670;&#160;</a></span>relu_min_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_min_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of relu min (relu(min(x, lower_limit))) on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">lower_limit   </td><td class="markdownTableBodyNone">Upper limit of relu_min   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Greater than 0   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="accf551de7b8a1527a9f8d2ffde7ec468" name="accf551de7b8a1527a9f8d2ffde7ec468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf551de7b8a1527a9f8d2ffde7ec468">&#9670;&#160;</a></span>relu_min_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_min_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="abb21cee43ed0d618c23762c357dcf1c2" name="abb21cee43ed0d618c23762c357dcf1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21cee43ed0d618c23762c357dcf1c2">&#9670;&#160;</a></span>relu_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of relu (0 if negative else 1) on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a6a214735fbd70467722ab3af7f2fb87b" name="a6a214735fbd70467722ab3af7f2fb87b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a214735fbd70467722ab3af7f2fb87b">&#9670;&#160;</a></span>relu_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::relu_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a9f4b979b10529e525e0e58a0b64dc0cf" name="a9f4b979b10529e525e0e58a0b64dc0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b979b10529e525e0e58a0b64dc0cf">&#9670;&#160;</a></span>rsqrt_tile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::rsqrt_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of reciprocal sqrt on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fast_and_approx   </td><td class="markdownTableBodyNone">Computation to be done faster and approximate   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a84b982392e5295a3ac4fb3624f984dd4" name="a84b982392e5295a3ac4fb3624f984dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b982392e5295a3ac4fb3624f984dd4">&#9670;&#160;</a></span>rsqrt_tile_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool fast_and_approx = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::rsqrt_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ae56fe236cbce161cc69af6a64abd6580" name="ae56fe236cbce161cc69af6a64abd6580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56fe236cbce161cc69af6a64abd6580">&#9670;&#160;</a></span>rsub_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::rsub_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of rsub ( rsub(x,y) = y -x) on each element of a tile and y is a constant param in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">Constant value that is being subtracted from   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae67bbff0728951b06c54865adb9b1e6d" name="ae67bbff0728951b06c54865adb9b1e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67bbff0728951b06c54865adb9b1e6d">&#9670;&#160;</a></span>rsub_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::rsub_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a0213ec935c1dc8512ab030b6066b36b1" name="a0213ec935c1dc8512ab030b6066b36b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0213ec935c1dc8512ab030b6066b36b1">&#9670;&#160;</a></span>sigmoid_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sigmoid_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of sigmoid on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a7445ef9a78452c5695742dd3f9163ce1" name="a7445ef9a78452c5695742dd3f9163ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7445ef9a78452c5695742dd3f9163ce1">&#9670;&#160;</a></span>sigmoid_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sigmoid_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ab6168b98b6911e7e8d65bcce66a98703" name="ab6168b98b6911e7e8d65bcce66a98703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6168b98b6911e7e8d65bcce66a98703">&#9670;&#160;</a></span>sign_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sign_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will store in the output of the compute core the signum of the tile. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a6854705311e47923c390b236cdcec41e" name="a6854705311e47923c390b236cdcec41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6854705311e47923c390b236cdcec41e">&#9670;&#160;</a></span>sign_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sign_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ac6ebf44b4c1d78c118fce325aff3a709" name="ac6ebf44b4c1d78c118fce325aff3a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ebf44b4c1d78c118fce325aff3a709">&#9670;&#160;</a></span>signbit_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::signbit_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sign bit of each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to modify the sign bit of   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa745471355960e008e844dc3f313ab05" name="aa745471355960e008e844dc3f313ab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa745471355960e008e844dc3f313ab05">&#9670;&#160;</a></span>signbit_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::signbit_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="adc4b7d15d9f6ca928626b1a246d7e2d1" name="adc4b7d15d9f6ca928626b1a246d7e2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4b7d15d9f6ca928626b1a246d7e2d1">&#9670;&#160;</a></span>silu_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::silu_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77f006579d8fe02aa468eb8bf260c47e" name="a77f006579d8fe02aa468eb8bf260c47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f006579d8fe02aa468eb8bf260c47e">&#9670;&#160;</a></span>silu_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::silu_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47a673f6f27ef504770b0b47891cea9c" name="a47a673f6f27ef504770b0b47891cea9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a673f6f27ef504770b0b47891cea9c">&#9670;&#160;</a></span>sin_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sin_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the trigonometric sine operation on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a060c4ee2f9fd4e95f083612d0e5462d7" name="a060c4ee2f9fd4e95f083612d0e5462d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060c4ee2f9fd4e95f083612d0e5462d7">&#9670;&#160;</a></span>sin_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sin_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ad7c2391b46aa28abea6e13bbe7610780" name="ad7c2391b46aa28abea6e13bbe7610780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c2391b46aa28abea6e13bbe7610780">&#9670;&#160;</a></span>sqrt_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sqrt_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the square root on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a54e1e97c019937643933a7b5ec4a73ff" name="a54e1e97c019937643933a7b5ec4a73ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e1e97c019937643933a7b5ec4a73ff">&#9670;&#160;</a></span>sqrt_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sqrt_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="af987308b41a50236bc0a3850fd7165fb" name="af987308b41a50236bc0a3850fd7165fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af987308b41a50236bc0a3850fd7165fb">&#9670;&#160;</a></span>square_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::square_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of square value on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a9d8e08b22bbbbf7960311670af37750e" name="a9d8e08b22bbbbf7960311670af37750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8e08b22bbbbf7960311670af37750e">&#9670;&#160;</a></span>square_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::square_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="ac2326c4eb36719970602e257f21625f0" name="ac2326c4eb36719970602e257f21625f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2326c4eb36719970602e257f21625f0">&#9670;&#160;</a></span>store_compute_special_value_flags_to_l1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::store_compute_special_value_flags_to_l1 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>l1_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f808cf8022ca4533ca149257ffa779b" name="a3f808cf8022ca4533ca149257ffa779b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f808cf8022ca4533ca149257ffa779b">&#9670;&#160;</a></span>sub_bcast_cols_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_bcast_cols_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for sub_bcast_cols to be executed correctly. </p>

</div>
</div>
<a id="acc846385166d37dbbab9e602e44e1fb3" name="acc846385166d37dbbab9e602e44e1fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc846385166d37dbbab9e602e44e1fb3">&#9670;&#160;</a></span>sub_tiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise subtraction C=A-B of tiles in two CBs at given indices and writes the result to the DST register at index dst_tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in0_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in1_tile_index   </td><td class="markdownTableBodyNone">The index of tile B within the second CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result C   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a045c8a2d7ddbb1993bbeceaff52b3185" name="a045c8a2d7ddbb1993bbeceaff52b3185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045c8a2d7ddbb1993bbeceaff52b3185">&#9670;&#160;</a></span>sub_tiles_bcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BroadcastType tBcastDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_bcast </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for <em>add_tiles_bcast</em>. </p>

</div>
</div>
<a id="a9732357a3d198fca729c337979f0c374" name="a9732357a3d198fca729c337979f0c374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9732357a3d198fca729c337979f0c374">&#9670;&#160;</a></span>sub_tiles_bcast_cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_bcast_cols </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand template instantiation of sub_tiles_bcast. </p>

</div>
</div>
<a id="a4d2d1f70dd8d9cba1330480bda3fe9cf" name="a4d2d1f70dd8d9cba1330480bda3fe9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2d1f70dd8d9cba1330480bda3fe9cf">&#9670;&#160;</a></span>sub_tiles_bcast_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_bcast_scalar </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand template instantiation of sub_tiles_bcast. </p>

</div>
</div>
<a id="a2071bf381ca9dc8ed656c3cf8f7ea746" name="a2071bf381ca9dc8ed656c3cf8f7ea746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2071bf381ca9dc8ed656c3cf8f7ea746">&#9670;&#160;</a></span>sub_tiles_bcast_scalar_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_bcast_scalar_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for sub_tiles_bcast_scalar to be executed correctly. </p>

</div>
</div>
<a id="a1b96384bfa2d9947faea6cd7d7f61b6c" name="a1b96384bfa2d9947faea6cd7d7f61b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b96384bfa2d9947faea6cd7d7f61b6c">&#9670;&#160;</a></span>sub_tiles_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acc_to_dest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Short init function </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">acc_to_dest   </td><td class="markdownTableBodyNone">If true, operation = A - B + dst_tile_idx of sub_tiles   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">0,1   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a136179be2361633cae3291b6d25fa2a5" name="a136179be2361633cae3291b6d25fa2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136179be2361633cae3291b6d25fa2a5">&#9670;&#160;</a></span>sub_tiles_init_nof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::sub_tiles_init_nof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. nof means low fidelity with respect to accuracy this is set during createprogram </p>

</div>
</div>
<a id="a340b3d31ff3f60adb500d58dbca820b7" name="a340b3d31ff3f60adb500d58dbca820b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340b3d31ff3f60adb500d58dbca820b7">&#9670;&#160;</a></span>tan_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tan_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of the trigonometric tan operation on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ab8e56f700e9f9c0d201dc4cfa63ecbf9" name="ab8e56f700e9f9c0d201dc4cfa63ecbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e56f700e9f9c0d201dc4cfa63ecbf9">&#9670;&#160;</a></span>tan_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tan_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="aba0ddaa8a8947a0d2e82ad4f4afeb0bb" name="aba0ddaa8a8947a0d2e82ad4f4afeb0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0ddaa8a8947a0d2e82ad4f4afeb0bb">&#9670;&#160;</a></span>tanh_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tanh_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of tanh on each element of a tile in DST register at index tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a3f6ed2b53e52e4d1cc2552443a62c759" name="a3f6ed2b53e52e4d1cc2552443a62c759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6ed2b53e52e4d1cc2552443a62c759">&#9670;&#160;</a></span>tanh_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tanh_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a34467f46da4221ff3a2820ff1baec122" name="a34467f46da4221ff3a2820ff1baec122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34467f46da4221ff3a2820ff1baec122">&#9670;&#160;</a></span>tile_regs_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tile_regs_acquire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire an exclusive lock on the DST register for the MATH thread. This register is an array of 16 tiles of 32x32 elements each. This is a blocking function, i.e. this function will wait until the lock is acquired. </p>

</div>
</div>
<a id="adaf34bbf977944a7913f979f709214c6" name="adaf34bbf977944a7913f979f709214c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf34bbf977944a7913f979f709214c6">&#9670;&#160;</a></span>tile_regs_commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tile_regs_commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release lock on DST register by MATH thread. The lock had to be previously acquired with tile_regs_acquire. </p>

</div>
</div>
<a id="addd3679665da343bd51f76ced7154c4a" name="addd3679665da343bd51f76ced7154c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd3679665da343bd51f76ced7154c4a">&#9670;&#160;</a></span>tile_regs_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tile_regs_release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release lock on DST register by PACK thread. The lock had to be previously acquired with tile_regs_wait. </p>

</div>
</div>
<a id="acc5591aaa5084f829a43b6282da1dec0" name="acc5591aaa5084f829a43b6282da1dec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5591aaa5084f829a43b6282da1dec0">&#9670;&#160;</a></span>tile_regs_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tile_regs_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire an exclusive lock on the DST register for the PACK thread. It waits for the MATH thread to commit the DST register. This is a blocking function, i.e. this function will wait until the lock is acquired. </p>

</div>
</div>
<a id="a015f70b923b3dc75073f42d5be952c9a" name="a015f70b923b3dc75073f42d5be952c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015f70b923b3dc75073f42d5be952c9a">&#9670;&#160;</a></span>tiled_prod_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tiled_prod_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise multiplication on each row of a tile. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a6b5c549b48da0bc2c9c6f22fd7932676" name="a6b5c549b48da0bc2c9c6f22fd7932676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5c549b48da0bc2c9c6f22fd7932676">&#9670;&#160;</a></span>tiled_prod_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tiled_prod_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="aea0827dbb324004596b2971a52c4d0ad" name="aea0827dbb324004596b2971a52c4d0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0827dbb324004596b2971a52c4d0ad">&#9670;&#160;</a></span>tilize_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform tilize operation on a block. This simply loops over the provided blocks. </p>

</div>
</div>
<a id="a8eba17d70dc66acc17db5fb7badb16ae" name="a8eba17d70dc66acc17db5fb7badb16ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eba17d70dc66acc17db5fb7badb16ae">&#9670;&#160;</a></span>tilize_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tilize operation. To be called once at beginning of a kernel. </p>

</div>
</div>
<a id="a2626e407c919742cff8789652cc08165" name="a2626e407c919742cff8789652cc08165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2626e407c919742cff8789652cc08165">&#9670;&#160;</a></span>tilize_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-initialize for the tilize operation. This can be called after a full init. </p>

</div>
</div>
<a id="a205b48db5a98b47825937c82a777a965" name="a205b48db5a98b47825937c82a777a965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205b48db5a98b47825937c82a777a965">&#9670;&#160;</a></span>tilize_init_short_with_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_init_short_with_dt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>old_icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>new_icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Re-initialize for the tilize operation. This also reconfigure the unpacker with CB data type. </p>

</div>
</div>
<a id="a3300fef3143945210d4e18f9bcf1760c" name="a3300fef3143945210d4e18f9bcf1760c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3300fef3143945210d4e18f9bcf1760c">&#9670;&#160;</a></span>tilize_init_unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_init_unpack </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3be1c47ccd017a1129daf785e15f545c" name="a3be1c47ccd017a1129daf785e15f545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be1c47ccd017a1129daf785e15f545c">&#9670;&#160;</a></span>tilize_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_uninit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninitialize tilize operation before re-initializing for another operation. </p>

</div>
</div>
<a id="a40b2d7e5e9073c4e135581f08657dc3b" name="a40b2d7e5e9073c4e135581f08657dc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b2d7e5e9073c4e135581f08657dc3b">&#9670;&#160;</a></span>tilize_uninit_with_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilize_uninit_with_dt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>old_icb</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>new_icb</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninitialize the tilize operation along with re-configuring unpacker with the CB data types. </p>

</div>
</div>
<a id="a649de9891a5d99ebab2c2e1aa75b9a27" name="a649de9891a5d99ebab2c2e1aa75b9a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649de9891a5d99ebab2c2e1aa75b9a27">&#9670;&#160;</a></span>tilizeA_B_dot_product_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilizeA_B_dot_product_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_faces</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face_r_dim</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize unpack_tilizeA_B and matmul for the dot product operation. To be called once at beginning of a kernel.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Data type   </th><th class="markdownTableHeadNone">Valid range   </th><th class="markdownTableHeadNone">required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the source A circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The identifier of the source B circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">block   </td><td class="markdownTableBodyNone">Size of tile block to work on for source A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">&gt; 0   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ocb   </td><td class="markdownTableBodyNone">The identifier of the output circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_faces   </td><td class="markdownTableBodyNone">The number of faces to in each tile being unpacked   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 4   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">face_r_dim   </td><td class="markdownTableBodyNone">The number of rows in each face   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 16   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a4f14abbc6a9f82516c94a9c6876d4765" name="a4f14abbc6a9f82516c94a9c6876d4765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f14abbc6a9f82516c94a9c6876d4765">&#9670;&#160;</a></span>tilizeA_B_reduce_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool neginf_srcA = true, bool zero_srcA_reduce = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::tilizeA_B_reduce_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1_scaler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_faces</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face_r_dim</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tilize operation. To be called once at beginning of a kernel. </p>

</div>
</div>
<a id="aa5210fb3aea6ef6c09eba614308a25c5" name="aa5210fb3aea6ef6c09eba614308a25c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5210fb3aea6ef6c09eba614308a25c5">&#9670;&#160;</a></span>topk_local_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::topk_local_sort </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_end_phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_start_phase</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_end_step</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_start_step</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs local sort stage of TopK algorithm on the two data tiles and two index tiles that are pre-loaded in DST register. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>The algorithm used to implement TopK is found here: <a href="https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf">https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf</a></p>
<p>The local sort stage sorts the data into length-K subsequences of alternating directions, in place. If i_start_phase != i_end_phase, all phases in the range i_start_phase to i_end_phase (inclusive) are computed. If i_start_phase == i_end_phase, only that phase is computed, with i_start_step and i_end_step defining how many steps are computed. This can be used to extend the OP support for cases when K &gt; 64.</p>
<p>Note that the two data tiles need to be loaded into the DST register before the invocation of this call. The corresponding index tiles should also be loaded in with the data tiles, at a DST offset of 2 tiles.</p>
<p>Note that local sort is done across columns on 64 values spanning across 2 tiles.</p>
<p>Note: idist should be set to 0</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">idir   </td><td class="markdownTableBodyNone">The sorting direction of the local sort (0 == decreasing, 1 == increasing)   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">0 to 1   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">i_end_phase   </td><td class="markdownTableBodyNone">The end phase of the local sort (should be set to log(K)-1)   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">1 to 5   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">i_start_phase   </td><td class="markdownTableBodyNone">The start phase of the local sort (should be set to 0)   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">0 to 5   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">i_end_step   </td><td class="markdownTableBodyNone">The end step to perform if i_start_phase == i_end_phase   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">4 to 6   </td><td class="markdownTableBodyNone">False    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">i_start_step   </td><td class="markdownTableBodyNone">The start step to perform if i_start_phase == i_end_phase   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">4 to 6   </td><td class="markdownTableBodyNone">False   </td></tr>
</table>

</div>
</div>
<a id="a2938cab3b09934d9f491eb7e8e46a9c6" name="a2938cab3b09934d9f491eb7e8e46a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2938cab3b09934d9f491eb7e8e46a9c6">&#9670;&#160;</a></span>topk_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::topk_merge </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs merge stage of TopK algorithm on the two data tiles and two index tiles that are pre-loaded in DST register. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>The merge stage combines length-K subsequences that are 2^m_iter apart, such that the first subsequence receives the top K values, and the second subsequence receives the bottom K values.</p>
<p>Note that the two data tiles need to be loaded into the DST register before the invocation of this call. The corresponding index tiles should also be loaded in with the data tiles, at a DST offset of 2 tiles.</p>
<p>Note that merge is done across columns on values spanning across 2 tiles.</p>
<p>Note: idist should be set to 0</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">m_iter   </td><td class="markdownTableBodyNone">The index of the merge &amp; rebuild iteration of the algorithm   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">0 to 9   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">k   </td><td class="markdownTableBodyNone">The number of sorted values to return   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">{4, 8, 16, 32, 64}   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="ae1cbdb83cc5bc20da93967c2252354b8" name="ae1cbdb83cc5bc20da93967c2252354b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cbdb83cc5bc20da93967c2252354b8">&#9670;&#160;</a></span>topk_rebuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::topk_rebuild </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>idir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>logk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>skip_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs rebuild stage of TopK algorithm on the two data tiles and two index tiles that are pre-loaded in DST register. The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>The rebuild stage sorts the length-K subsequences that are 2^(m_iter+1) apart, such that they alternate directions.</p>
<p>Note that the two data tiles need to be loaded into the DST register before the invocation of this call. The corresponding index tiles should also be loaded in with the data tiles, at a DST offset of 2 tiles.</p>
<p>Note that rebuild is done across columns on values spanning across 2 tiles.</p>
<p>Note: idist should be set to 0</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">idir   </td><td class="markdownTableBodyNone">The sorting direction of the local sort (0 == decreasing, 1 == increasing)   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">0 to 1   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m_iter   </td><td class="markdownTableBodyNone">The index of the merge &amp; rebuild iteration of the algorithm   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">0 to 9   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">k   </td><td class="markdownTableBodyNone">The number of sorted values to return   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">{4, 8, 16, 32, 64}   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">logk   </td><td class="markdownTableBodyNone">The log of K   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">2 to 6   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">skip_second   </td><td class="markdownTableBodyNone">Whether or not to skip second tile   </td><td class="markdownTableBodyNone">int32   </td><td class="markdownTableBodyNone">0 to 1   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a53c812a947f6d756ea625b7361174037" name="a53c812a947f6d756ea625b7361174037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c812a947f6d756ea625b7361174037">&#9670;&#160;</a></span>topk_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::topk_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="aa5fd30268e7264eac2189db54b6f60f7" name="aa5fd30268e7264eac2189db54b6f60f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fd30268e7264eac2189db54b6f60f7">&#9670;&#160;</a></span>transpose_wh_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::transpose_wh_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Paired Init function for transpose_wh. For general information on init functions refer to any_init.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing input   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a8fcfeec0c3262ec9fd53b6dbdc67100c" name="a8fcfeec0c3262ec9fd53b6dbdc67100c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcfeec0c3262ec9fd53b6dbdc67100c">&#9670;&#160;</a></span>transpose_wh_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::transpose_wh_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a first-call or switch-from-another-op tile hw reconfiguration step needed for transpose_wh to be executed correctly. </p>

</div>
</div>
<a id="ab885f1c61cacad96feb21ff8c9b099aa" name="ab885f1c61cacad96feb21ff8c9b099aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab885f1c61cacad96feb21ff8c9b099aa">&#9670;&#160;</a></span>transpose_wh_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::transpose_wh_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>itile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a 32x32 transpose operation <em>B[w,h] = A[h,w]</em> on a tile in the CB at a given index and writes the result to the DST register at index dst_tile_index. The DST register buffer must be in acquired state via <em>acquire_dst</em> call.</p>
<p>This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">in_cb_id   </td><td class="markdownTableBodyNone">The identifier of the circular buffer (CB) containing A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">in_tile_index   </td><td class="markdownTableBodyNone">The index of tile A within the first CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst_tile_index   </td><td class="markdownTableBodyNone">The index of the tile in DST REG for the result B   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the acquired size of DST REG   </td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a3beb809d58bbce0ee44b0d9f6e3e0caf" name="a3beb809d58bbce0ee44b0d9f6e3e0caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3beb809d58bbce0ee44b0d9f6e3e0caf">&#9670;&#160;</a></span>unary_gt_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_gt_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of: result = 1 if x &gt; value , where x is each element of a tile in DST register at index tile_index. The value is provided as const param0 The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">The value to be compared with the input tensor   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aa8a849876763dfccf446df2954aa531d" name="aa8a849876763dfccf446df2954aa531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a849876763dfccf446df2954aa531d">&#9670;&#160;</a></span>unary_gt_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_gt_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a3efdf48fde7c2df0e8236b387c1ff873" name="a3efdf48fde7c2df0e8236b387c1ff873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efdf48fde7c2df0e8236b387c1ff873">&#9670;&#160;</a></span>unary_lt_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_lt_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of: result = 1 if x &lt; value , where x is each element of a tile in DST register at index tile_index. The value is provided as const param0 The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">The value to be compared with the input tensor   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a0c1307468c0b580c07969a1359769cff" name="a0c1307468c0b580c07969a1359769cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1307468c0b580c07969a1359769cff">&#9670;&#160;</a></span>unary_lt_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_lt_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="adf08edc7ebeb842eb1addfc2ac53da34" name="adf08edc7ebeb842eb1addfc2ac53da34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf08edc7ebeb842eb1addfc2ac53da34">&#9670;&#160;</a></span>unary_ne_tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_ne_tile </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>param0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs element-wise computation of: result = 1 if x!=value , where x is each element of a tile in DST register at index tile_index. The value is provided as const param0 The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">idst   </td><td class="markdownTableBodyNone">The index of the tile in DST register buffer to perform the computation on   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the DST register buffer   </td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">param0   </td><td class="markdownTableBodyNone">The value to be compared with the input tensor   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a86f5e14f68cb732534c41d400843fced" name="a86f5e14f68cb732534c41d400843fced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f5e14f68cb732534c41d400843fced">&#9670;&#160;</a></span>unary_ne_tile_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unary_ne_tile_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Please refer to documentation for any_init. </p>

</div>
</div>
<a id="a8d9523f37c0573600360754d14776ab0" name="a8d9523f37c0573600360754d14776ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9523f37c0573600360754d14776ab0">&#9670;&#160;</a></span>unpack_tilize_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unpack_tilize_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17a976438c3449ea436628357b647852" name="a17a976438c3449ea436628357b647852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a976438c3449ea436628357b647852">&#9670;&#160;</a></span>unpack_tilizeA_B_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unpack_tilizeA_B_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tile_idx_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_faces</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srca_face_r_dim</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a100bc7f788be0c8206261722ac613de7" name="a100bc7f788be0c8206261722ac613de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100bc7f788be0c8206261722ac613de7">&#9670;&#160;</a></span>unpack_tilizeA_B_dot_product_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::unpack_tilizeA_B_dot_product_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tile_idx_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_faces</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a single tile from the specified input CBs into SRCA and SRCB. The function will employ one unpacker to unpack and tilize data from the first input CB into SRCA, and the second unpacker to unpack from the second input CB into SRCB. For the tile_idx_b and block to be valid for this call, cb_wait_front(n) had to be previously called on each input CB to ensure that at least some number n&gt;0 of tiles are available in the input CBs. The CB index 0 then references the first tile in the received section of the CB, up to index n-1 (in a FIFO order). The DST register buffer must be in acquired state via <em>acquire_dst</em> call. This call is blocking and is only available on the compute engine.</p>
<p>Return value: None</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Data type   </th><th class="markdownTableHeadNone">Valid range   </th><th class="markdownTableHeadNone">required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">icb0   </td><td class="markdownTableBodyNone">The identifier of the source A circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">icb1   </td><td class="markdownTableBodyNone">The identifier of the source B circular buffer (CB)   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">0 to 31   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">block   </td><td class="markdownTableBodyNone">Size of tile block to work on for source A   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">&gt; 0   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">tile_idx_b   </td><td class="markdownTableBodyNone">The index of the tile to copy from the source B input CB   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">Must be less than the size of the CB   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_faces   </td><td class="markdownTableBodyNone">The number of faces to in each tile being unpacked   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone">1 to 4   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="abdf529b965f1e85626342a4027d36461" name="abdf529b965f1e85626342a4027d36461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf529b965f1e85626342a4027d36461">&#9670;&#160;</a></span>untilize_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::untilize_block </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the untilize operation on a block of tiles. This simply loops over the provided block size. </p>

</div>
</div>
<a id="a74d5a0f5a3a5fa918e9c5d51a7d12ed8" name="a74d5a0f5a3a5fa918e9c5d51a7d12ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d5a0f5a3a5fa918e9c5d51a7d12ed8">&#9670;&#160;</a></span>untilize_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::untilize_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ocb</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init function for untilize operations, to be used at the beginning of the kernel. </p>

</div>
</div>
<a id="ae4d031d36cb76c55a761108f7c5dd1a5" name="ae4d031d36cb76c55a761108f7c5dd1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d031d36cb76c55a761108f7c5dd1a5">&#9670;&#160;</a></span>untilize_init_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::untilize_init_short </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Short init function to initialize untilize op, after a full init is already performed. </p>

</div>
</div>
<a id="a9a9d99d57d7e3d97a8554498e24b55c8" name="a9a9d99d57d7e3d97a8554498e24b55c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9d99d57d7e3d97a8554498e24b55c8">&#9670;&#160;</a></span>untilize_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ckernel::untilize_uninit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>icb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninitialize untilize operation, to allow initializing another operation. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
