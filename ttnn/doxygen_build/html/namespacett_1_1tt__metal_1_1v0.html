<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tt-metal: tt::tt_metal::v0 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">tt-metal
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacett.html">tt</a></li><li class="navelem"><a class="el" href="namespacett_1_1tt__metal.html">tt_metal</a></li><li class="navelem"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html">v0</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tt::tt_metal::v0 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5d1cfea010cb740e7307b18b4a7ec9e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">RuntimeArgs</a> = std::vector&lt; std::variant&lt; Buffer *, uint32_t &gt; &gt;</td></tr>
<tr class="separator:a5d1cfea010cb740e7307b18b4a7ec9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e4322b747fd7823e878c3e2ae729e27"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a1e4322b747fd7823e878c3e2ae729e27">GetNumAvailableDevices</a> ()</td></tr>
<tr class="separator:a1e4322b747fd7823e878c3e2ae729e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ede0a0180762c7d1f091176738237c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a63ede0a0180762c7d1f091176738237c">IsGalaxyCluster</a> ()</td></tr>
<tr class="separator:a63ede0a0180762c7d1f091176738237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f05b332fd6f861bb3540dbe2af433be"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a4f05b332fd6f861bb3540dbe2af433be">GetNumPCIeDevices</a> ()</td></tr>
<tr class="separator:a4f05b332fd6f861bb3540dbe2af433be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46d5827805ba92482cddb5591c69a45"><td class="memItemLeft" align="right" valign="top">chip_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#af46d5827805ba92482cddb5591c69a45">GetPCIeDeviceID</a> (chip_id_t device_id)</td></tr>
<tr class="separator:af46d5827805ba92482cddb5591c69a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3488f7ac4863b7b372f344f863bc84"><td class="memItemLeft" align="right" valign="top">Device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#abe3488f7ac4863b7b372f344f863bc84">CreateDevice</a> (chip_id_t device_id, const uint8_t num_hw_cqs=1, const size_t l1_small_size=DEFAULT_L1_SMALL_SIZE, const size_t trace_region_size=DEFAULT_TRACE_REGION_SIZE, DispatchCoreType dispatch_core_type=DispatchCoreType::WORKER, const std::vector&lt; uint32_t &gt; &amp;l1_bank_remap={})</td></tr>
<tr class="separator:abe3488f7ac4863b7b372f344f863bc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1690575bfc5a81f0a7bc44b0a1f4780b"><td class="memItemLeft" align="right" valign="top">Device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a1690575bfc5a81f0a7bc44b0a1f4780b">CreateDeviceMinimal</a> (chip_id_t device_id, const uint8_t num_hw_cqs=1, DispatchCoreType dispatch_core_type=DispatchCoreType::WORKER)</td></tr>
<tr class="separator:a1690575bfc5a81f0a7bc44b0a1f4780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cb44c89e3231cade68dca1a6990bbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a26cb44c89e3231cade68dca1a6990bbb">CloseDevice</a> (Device *device)</td></tr>
<tr class="separator:a26cb44c89e3231cade68dca1a6990bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826db8a9c40c91034bc2a5f0f6e9b75e"><td class="memItemLeft" align="right" valign="top">Program&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a826db8a9c40c91034bc2a5f0f6e9b75e">CreateProgram</a> ()</td></tr>
<tr class="separator:a826db8a9c40c91034bc2a5f0f6e9b75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e68e0e2cb813bf5814ddb02d82cd1d0"><td class="memItemLeft" align="right" valign="top">KernelHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a0e68e0e2cb813bf5814ddb02d82cd1d0">CreateKernel</a> (Program &amp;program, const std::string &amp;file_name, const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;core_spec, const std::variant&lt; DataMovementConfig, ComputeConfig, EthernetConfig &gt; &amp;config)</td></tr>
<tr class="separator:a0e68e0e2cb813bf5814ddb02d82cd1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aefd0f3f82e3dd0d66ff2ca72453c8"><td class="memItemLeft" align="right" valign="top">KernelHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a63aefd0f3f82e3dd0d66ff2ca72453c8">CreateKernelFromString</a> (Program &amp;program, const std::string &amp;kernel_src_code, const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;core_spec, const std::variant&lt; DataMovementConfig, ComputeConfig, EthernetConfig &gt; &amp;config)</td></tr>
<tr class="separator:a63aefd0f3f82e3dd0d66ff2ca72453c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1e837406fd39ad2b671b7836ce3e4c"><td class="memItemLeft" align="right" valign="top">CBHandle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a4b1e837406fd39ad2b671b7836ce3e4c">CreateCircularBuffer</a> (Program &amp;program, const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;core_spec, const CircularBufferConfig &amp;config)</td></tr>
<tr class="separator:a4b1e837406fd39ad2b671b7836ce3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b1a13298da52770f32ddeeabd2c65a"><td class="memItemLeft" align="right" valign="top">const CircularBufferConfig &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ac4b1a13298da52770f32ddeeabd2c65a">GetCircularBufferConfig</a> (Program &amp;program, CBHandle cb_handle)</td></tr>
<tr class="separator:ac4b1a13298da52770f32ddeeabd2c65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220dc8a16809c1c12a44348b9a76ab08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a220dc8a16809c1c12a44348b9a76ab08">UpdateCircularBufferTotalSize</a> (Program &amp;program, CBHandle cb_handle, uint32_t total_size)</td></tr>
<tr class="separator:a220dc8a16809c1c12a44348b9a76ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3831e993c64a578637c9fc73b059412d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a3831e993c64a578637c9fc73b059412d">UpdateCircularBufferPageSize</a> (Program &amp;program, CBHandle cb_handle, uint8_t buffer_index, uint32_t page_size)</td></tr>
<tr class="separator:a3831e993c64a578637c9fc73b059412d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf0d51e979e755908ee29c30401ee53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a0cf0d51e979e755908ee29c30401ee53">UpdateDynamicCircularBufferAddress</a> (Program &amp;program, CBHandle cb_handle, const Buffer &amp;buffer)</td></tr>
<tr class="separator:a0cf0d51e979e755908ee29c30401ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce765d28d851983f910495c44411cd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ad7ce765d28d851983f910495c44411cd">CreateSemaphore</a> (Program &amp;program, const std::variant&lt; CoreRange, CoreRangeSet &gt; &amp;core_spec, uint32_t initial_value, CoreType core_type=CoreType::WORKER)</td></tr>
<tr class="separator:ad7ce765d28d851983f910495c44411cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c394c5ec94274c150ee18ef88ef78"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; GlobalSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a087c394c5ec94274c150ee18ef88ef78">CreateGlobalSemaphore</a> (Device *device, const CoreRangeSet &amp;cores, uint32_t initial_value, BufferType buffer_type=BufferType::L1)</td></tr>
<tr class="separator:a087c394c5ec94274c150ee18ef88ef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4672dc795d11eeac8c1c45bfed6a87"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; GlobalSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#acd4672dc795d11eeac8c1c45bfed6a87">CreateGlobalSemaphore</a> (Device *device, CoreRangeSet &amp;&amp;cores, uint32_t initial_value, BufferType buffer_type=BufferType::L1)</td></tr>
<tr class="separator:acd4672dc795d11eeac8c1c45bfed6a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7794124ecb8f3b20ffe95a4c8b390d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#aec7794124ecb8f3b20ffe95a4c8b390d">CreateBuffer</a> (const InterleavedBufferConfig &amp;config)</td></tr>
<tr class="separator:aec7794124ecb8f3b20ffe95a4c8b390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ad24acd85d50aebe09a2220fd1237c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a74ad24acd85d50aebe09a2220fd1237c">CreateBuffer</a> (const InterleavedBufferConfig &amp;config, DeviceAddr address)</td></tr>
<tr class="separator:a74ad24acd85d50aebe09a2220fd1237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88eb77e75d74b91bec6ad22064eb3b38"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a88eb77e75d74b91bec6ad22064eb3b38">CreateBuffer</a> (const InterleavedBufferConfig &amp;config, SubDeviceId sub_device_id)</td></tr>
<tr class="separator:a88eb77e75d74b91bec6ad22064eb3b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c254d5b77d19539fd7999c73b7606ad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a6c254d5b77d19539fd7999c73b7606ad">CreateBuffer</a> (const ShardedBufferConfig &amp;config)</td></tr>
<tr class="separator:a6c254d5b77d19539fd7999c73b7606ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9703a61146ccd855bea828aade6a720"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ac9703a61146ccd855bea828aade6a720">CreateBuffer</a> (const ShardedBufferConfig &amp;config, DeviceAddr address)</td></tr>
<tr class="separator:ac9703a61146ccd855bea828aade6a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b0f4582de81688db0f46ab932f74f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; Buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ac9b0f4582de81688db0f46ab932f74f8">CreateBuffer</a> (const ShardedBufferConfig &amp;config, SubDeviceId sub_device_id)</td></tr>
<tr class="separator:ac9b0f4582de81688db0f46ab932f74f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce385d98e86cf18acb680f183039cb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#abce385d98e86cf18acb680f183039cb5">DeallocateBuffer</a> (Buffer &amp;buffer)</td></tr>
<tr class="separator:abce385d98e86cf18acb680f183039cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebc34320ecacb398a25f67c206422d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a1ebc34320ecacb398a25f67c206422d5">AssignGlobalBufferToProgram</a> (std::shared_ptr&lt; Buffer &gt; buffer, Program &amp;program)</td></tr>
<tr class="separator:a1ebc34320ecacb398a25f67c206422d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2ca08d5f123ed98b99498324061ba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#afb2ca08d5f123ed98b99498324061ba4">SetRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel, const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;core_spec, stl::Span&lt; const uint32_t &gt; runtime_args)</td></tr>
<tr class="separator:afb2ca08d5f123ed98b99498324061ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ca7c2b7c798d3c16af2dc931d68df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a74ca7c2b7c798d3c16af2dc931d68df0">SetRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel, const std::vector&lt; CoreCoord &gt; &amp;core_spec, const std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;runtime_args)</td></tr>
<tr class="separator:a74ca7c2b7c798d3c16af2dc931d68df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb3df50326c491a4612d21ce45a518a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#afdb3df50326c491a4612d21ce45a518a">SetRuntimeArgs</a> (Device *device, const std::shared_ptr&lt; Kernel &gt; kernel, const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;core_spec, std::shared_ptr&lt; <a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">RuntimeArgs</a> &gt; runtime_args)</td></tr>
<tr class="separator:afdb3df50326c491a4612d21ce45a518a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774adf0f130e4a8f75007cca0a33fcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a774adf0f130e4a8f75007cca0a33fcb6">SetRuntimeArgs</a> (Device *device, const std::shared_ptr&lt; Kernel &gt; kernel, const std::vector&lt; CoreCoord &gt; &amp;core_spec, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">RuntimeArgs</a> &gt; &gt; runtime_args)</td></tr>
<tr class="separator:a774adf0f130e4a8f75007cca0a33fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8263eba8cd8279b6c1e6db233ec5f133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a8263eba8cd8279b6c1e6db233ec5f133">SetCommonRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel_id, stl::Span&lt; const uint32_t &gt; runtime_args)</td></tr>
<tr class="separator:a8263eba8cd8279b6c1e6db233ec5f133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609d42acfdab49842d577aae66de2e67"><td class="memItemLeft" align="right" valign="top">RuntimeArgsData &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a609d42acfdab49842d577aae66de2e67">GetRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel_id, const CoreCoord &amp;logical_core)</td></tr>
<tr class="separator:a609d42acfdab49842d577aae66de2e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65abc534c2bbbe36d118c3b844350a72"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; RuntimeArgsData &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a65abc534c2bbbe36d118c3b844350a72">GetRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel_id)</td></tr>
<tr class="separator:a65abc534c2bbbe36d118c3b844350a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9117d8f938e3b0c3e6b146f960eafa2f"><td class="memItemLeft" align="right" valign="top">RuntimeArgsData &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a9117d8f938e3b0c3e6b146f960eafa2f">GetCommonRuntimeArgs</a> (const Program &amp;program, KernelHandle kernel_id)</td></tr>
<tr class="separator:a9117d8f938e3b0c3e6b146f960eafa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb833452d2265a33a294eef1140782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a76bb833452d2265a33a294eef1140782">EnqueueReadBuffer</a> (CommandQueue &amp;cq, std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt; buffer, void *dst, bool blocking, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:a76bb833452d2265a33a294eef1140782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6950194c0970fe3d6f35657524e44b"><td class="memTemplParams" colspan="2">template&lt;typename DType &gt; </td></tr>
<tr class="memitem:aed6950194c0970fe3d6f35657524e44b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#aed6950194c0970fe3d6f35657524e44b">EnqueueReadBuffer</a> (CommandQueue &amp;cq, Buffer &amp;buffer, std::vector&lt; DType &gt; &amp;dst, bool blocking, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:aed6950194c0970fe3d6f35657524e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbc3816d634690201a2864b0e6ea1d8"><td class="memTemplParams" colspan="2">template&lt;typename DType &gt; </td></tr>
<tr class="memitem:adfbc3816d634690201a2864b0e6ea1d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#adfbc3816d634690201a2864b0e6ea1d8">EnqueueReadBuffer</a> (CommandQueue &amp;cq, std::shared_ptr&lt; Buffer &gt; buffer, std::vector&lt; DType &gt; &amp;dst, bool blocking, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:adfbc3816d634690201a2864b0e6ea1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3bea917e3563c642147c3f34911270"><td class="memTemplParams" colspan="2">template&lt;typename DType &gt; </td></tr>
<tr class="memitem:a7c3bea917e3563c642147c3f34911270"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a7c3bea917e3563c642147c3f34911270">EnqueueWriteBuffer</a> (CommandQueue &amp;cq, std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt; buffer, std::vector&lt; DType &gt; &amp;src, bool blocking, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:a7c3bea917e3563c642147c3f34911270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634370b608fd0b78795ab3d7b128c9f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a634370b608fd0b78795ab3d7b128c9f0">EnqueueWriteBuffer</a> (CommandQueue &amp;cq, std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt; buffer, HostDataType src, bool blocking, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:a634370b608fd0b78795ab3d7b128c9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74d31b79ae9a8fe25468bc95b13ee2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ab74d31b79ae9a8fe25468bc95b13ee2a">EnqueueProgram</a> (CommandQueue &amp;cq, Program &amp;program, bool blocking)</td></tr>
<tr class="separator:ab74d31b79ae9a8fe25468bc95b13ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ad47ba118422cf5d162a24289f53cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a41ad47ba118422cf5d162a24289f53cb">Finish</a> (CommandQueue &amp;cq, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:a41ad47ba118422cf5d162a24289f53cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe853244ec21092c0a4c24a76ac9d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a2ebe853244ec21092c0a4c24a76ac9d7">BeginTraceCapture</a> (Device *device, const uint8_t cq_id)</td></tr>
<tr class="separator:a2ebe853244ec21092c0a4c24a76ac9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868dff83af5a6f69735afddfb8123016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a868dff83af5a6f69735afddfb8123016">EndTraceCapture</a> (Device *device, const uint8_t cq_id, const uint32_t tid)</td></tr>
<tr class="separator:a868dff83af5a6f69735afddfb8123016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7e23130adb368821457f261e37cd9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#aaf7e23130adb368821457f261e37cd9b">ReplayTrace</a> (Device *device, const uint8_t cq_id, const uint32_t tid, const bool blocking)</td></tr>
<tr class="separator:aaf7e23130adb368821457f261e37cd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8540d48e27a58a9519483782991eba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#ad8540d48e27a58a9519483782991eba0">ReleaseTrace</a> (Device *device, const uint32_t tid)</td></tr>
<tr class="separator:ad8540d48e27a58a9519483782991eba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c2d778c2f00844d1113c0e011522f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a35c2d778c2f00844d1113c0e011522f2">EnqueueTrace</a> (CommandQueue &amp;cq, uint32_t trace_id, bool blocking)</td></tr>
<tr class="separator:a35c2d778c2f00844d1113c0e011522f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617bb9ae1b430271808f81999a4ef53e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a617bb9ae1b430271808f81999a4ef53e">DumpDeviceProfileResults</a> (Device *device, const Program &amp;program)</td></tr>
<tr class="separator:a617bb9ae1b430271808f81999a4ef53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb44e976abef6030c7dbb73970d800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a57cb44e976abef6030c7dbb73970d800">EnqueueRecordEvent</a> (CommandQueue &amp;cq, const std::shared_ptr&lt; Event &gt; &amp;event, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:a57cb44e976abef6030c7dbb73970d800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0348eff37a292f881b5b88193d8196f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a0348eff37a292f881b5b88193d8196f6">EnqueueWaitForEvent</a> (CommandQueue &amp;cq, const std::shared_ptr&lt; Event &gt; &amp;event)</td></tr>
<tr class="separator:a0348eff37a292f881b5b88193d8196f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7965734b9b4f42fd7b96da7cdcc45927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a7965734b9b4f42fd7b96da7cdcc45927">EventSynchronize</a> (const std::shared_ptr&lt; Event &gt; &amp;event)</td></tr>
<tr class="separator:a7965734b9b4f42fd7b96da7cdcc45927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fd82461b3734afccb8f11427564181"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a51fd82461b3734afccb8f11427564181">EventQuery</a> (const std::shared_ptr&lt; Event &gt; &amp;event)</td></tr>
<tr class="separator:a51fd82461b3734afccb8f11427564181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef214f3ba879469488d367053046cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacett_1_1tt__metal_1_1v0.html#abbef214f3ba879469488d367053046cb">Synchronize</a> (Device *device, const std::optional&lt; uint8_t &gt; cq_id=std::nullopt, tt::stl::Span&lt; const SubDeviceId &gt; sub_device_ids={})</td></tr>
<tr class="separator:abbef214f3ba879469488d367053046cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a5d1cfea010cb740e7307b18b4a7ec9e8" name="a5d1cfea010cb740e7307b18b4a7ec9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1cfea010cb740e7307b18b4a7ec9e8">&#9670;&#160;</a></span>RuntimeArgs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">tt::tt_metal::v0::RuntimeArgs</a> = typedef std::vector&lt;std::variant&lt;Buffer *, uint32_t&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1ebc34320ecacb398a25f67c206422d5" name="a1ebc34320ecacb398a25f67c206422d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebc34320ecacb398a25f67c206422d5">&#9670;&#160;</a></span>AssignGlobalBufferToProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::AssignGlobalBufferToProgram </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Buffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the specified program ownership of the buffer: the buffer will remain on device at least until the program is enqueued. This is required for asynchronous Command Queues.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The buffer that will be owned by the program   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Buffer&gt; buffer   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program getting ownership of the buffer   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a2ebe853244ec21092c0a4c24a76ac9d7" name="a2ebe853244ec21092c0a4c24a76ac9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe853244ec21092c0a4c24a76ac9d7">&#9670;&#160;</a></span>BeginTraceCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tt::tt_metal::v0::BeginTraceCapture </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cq_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins capture on a trace, when the trace is in capture mode all programs pushed into the trace queue will have their execution delayed until the trace is instantiated and enqueued. The capture must be later ended via EndTraceCapture, and finally scheduled to be executed via ReplayTrace. Beginning a trace capture enabled buffer allocations until capture has ended.</p>
<p>Return value: Trace ID</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device holding being traced.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cq_id   </td><td class="markdownTableBodyNone">The command queue id associated with the trace.   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a26cb44c89e3231cade68dca1a6990bbb" name="a26cb44c89e3231cade68dca1a6990bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cb44c89e3231cade68dca1a6990bbb">&#9670;&#160;</a></span>CloseDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tt::tt_metal::v0::CloseDevice </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets device and closes device</p>
<p>Return value: bool</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">Pointer to a device object   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="aec7794124ecb8f3b20ffe95a4c8b390d" name="aec7794124ecb8f3b20ffe95a4c8b390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7794124ecb8f3b20ffe95a4c8b390d">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const InterleavedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated interleaved DRAM or L1 buffer with the global allocator on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">InterleavedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a74ad24acd85d50aebe09a2220fd1237c" name="a74ad24acd85d50aebe09a2220fd1237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ad24acd85d50aebe09a2220fd1237c">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const InterleavedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeviceAddr&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated interleaved DRAM or L1 buffer with the global allocator on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">InterleavedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">address   </td><td class="markdownTableBodyNone">Device address of the buffer   </td><td class="markdownTableBodyNone">DeviceAddr   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a88eb77e75d74b91bec6ad22064eb3b38" name="a88eb77e75d74b91bec6ad22064eb3b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88eb77e75d74b91bec6ad22064eb3b38">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const InterleavedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubDeviceId&#160;</td>
          <td class="paramname"><em>sub_device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated interleaved DRAM or L1 buffer on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">InterleavedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sub_device_id   </td><td class="markdownTableBodyNone">The sub-device id to allocate on   </td><td class="markdownTableBodyNone">SubDeviceId   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a6c254d5b77d19539fd7999c73b7606ad" name="a6c254d5b77d19539fd7999c73b7606ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c254d5b77d19539fd7999c73b7606ad">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const ShardedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated sharded DRAM or L1 buffer with the global allocator on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">ShardedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="ac9703a61146ccd855bea828aade6a720" name="ac9703a61146ccd855bea828aade6a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9703a61146ccd855bea828aade6a720">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const ShardedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeviceAddr&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated sharded DRAM or L1 buffer with the global allocator on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">ShardedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">address   </td><td class="markdownTableBodyNone">Device address of the buffer   </td><td class="markdownTableBodyNone">DeviceAddr   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="ac9b0f4582de81688db0f46ab932f74f8" name="ac9b0f4582de81688db0f46ab932f74f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b0f4582de81688db0f46ab932f74f8">&#9670;&#160;</a></span>CreateBuffer() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; Buffer &gt; tt::tt_metal::v0::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">const ShardedBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubDeviceId&#160;</td>
          <td class="paramname"><em>sub_device_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pre-allocated sharded DRAM or L1 buffer on device</p>
<p>Return value: std::shared_ptr&lt;Buffer&gt;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for the buffer   </td><td class="markdownTableBodyNone">ShardedBufferConfig   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sub_device_id   </td><td class="markdownTableBodyNone">The sub-device id to allocate on   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a4b1e837406fd39ad2b671b7836ce3e4c" name="a4b1e837406fd39ad2b671b7836ce3e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1e837406fd39ad2b671b7836ce3e4c">&#9670;&#160;</a></span>CreateCircularBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CBHandle tt::tt_metal::v0::CreateCircularBuffer </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CircularBufferConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a Circular Buffer (CB) in L1 memory of all cores within core ranges (inclusive) and adds it to the program. There can be a total of NUM_CIRCULAR_BUFFERS (32) circular buffers per core. Circular buffers hold data and have an associated config which indicates usage of the address space. If the config is specified for multiple buffer indices, the circular buffer address space is shared and each buffer index can potentially have a unique view of the shared space.</p>
<p>Circular buffers can be dynamically allocated or program-local allocated. If the config is created with an L1 buffer or sets a globally allocated address it is dynamic and shares the same address space as the L1 buffer. Otherwise, the circular buffer address space is managed by the program. Address space for program-local circular buffers does not persist across programs.</p>
<p>Return value: Circular Buffer ID (uintptr_t)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program to which buffer will be added to   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Either a single logical core, a range of logical cores or a set of logical core ranges that indicate where the circular buffer will be configured   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreCoord, CoreRange, CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for circular buffer   </td><td class="markdownTableBodyNone">const CircularBufferConfig &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="abe3488f7ac4863b7b372f344f863bc84" name="abe3488f7ac4863b7b372f344f863bc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3488f7ac4863b7b372f344f863bc84">&#9670;&#160;</a></span>CreateDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Device * tt::tt_metal::v0::CreateDevice </td>
          <td>(</td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_hw_cqs</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l1_small_size</em> = <code>DEFAULT_L1_SMALL_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>trace_region_size</em> = <code>DEFAULT_TRACE_REGION_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DispatchCoreType&#160;</td>
          <td class="paramname"><em>dispatch_core_type</em> = <code>DispatchCoreType::WORKER</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>l1_bank_remap</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiates a device object.</p>
<p>Return value: Device *</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device_id   </td><td class="markdownTableBodyNone">ID of the device to target   </td><td class="markdownTableBodyNone">chip_id_t (int)   </td><td class="markdownTableBodyNone">0 to (GetNumAvailableDevices - 1)   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a1690575bfc5a81f0a7bc44b0a1f4780b" name="a1690575bfc5a81f0a7bc44b0a1f4780b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1690575bfc5a81f0a7bc44b0a1f4780b">&#9670;&#160;</a></span>CreateDeviceMinimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Device * tt::tt_metal::v0::CreateDeviceMinimal </td>
          <td>(</td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>device_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_hw_cqs</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DispatchCoreType&#160;</td>
          <td class="paramname"><em>dispatch_core_type</em> = <code>DispatchCoreType::WORKER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instantiates a device with minimal setup, used to attach to a device in a bad state.</p>
<p>Return value: Device *</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device_id   </td><td class="markdownTableBodyNone">ID of the device to target   </td><td class="markdownTableBodyNone">chip_id_t (int)   </td><td class="markdownTableBodyNone">0 to (GetNumAvailableDevices - 1)   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a087c394c5ec94274c150ee18ef88ef78" name="a087c394c5ec94274c150ee18ef88ef78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087c394c5ec94274c150ee18ef88ef78">&#9670;&#160;</a></span>CreateGlobalSemaphore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; GlobalSemaphore &gt; tt::tt_metal::v0::CreateGlobalSemaphore </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreRangeSet &amp;&#160;</td>
          <td class="paramname"><em>cores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType&#160;</td>
          <td class="paramname"><em>buffer_type</em> = <code>BufferType::L1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a global semaphore on all cores within the specified CoreRangeSet. This only supports tensix cores, and can only use L1 buffer types like BufferType::L1 and BufferType::L1_SMALL.</p>
<p>Return value: std::unique_ptr&lt;GlobalSemaphore&gt;.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device to create the semaphore on   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cores   </td><td class="markdownTableBodyNone">Range of the Tensix co-ordinates using the semaphore   </td><td class="markdownTableBodyNone">const CoreRangeSet &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_value   </td><td class="markdownTableBodyNone">Initial value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer_type   </td><td class="markdownTableBodyNone">Buffer type to store the semaphore   </td><td class="markdownTableBodyNone">BufferType   </td><td class="markdownTableBodyNone">L1 types   </td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="acd4672dc795d11eeac8c1c45bfed6a87" name="acd4672dc795d11eeac8c1c45bfed6a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4672dc795d11eeac8c1c45bfed6a87">&#9670;&#160;</a></span>CreateGlobalSemaphore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; GlobalSemaphore &gt; tt::tt_metal::v0::CreateGlobalSemaphore </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreRangeSet &amp;&amp;&#160;</td>
          <td class="paramname"><em>cores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferType&#160;</td>
          <td class="paramname"><em>buffer_type</em> = <code>BufferType::L1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a global semaphore on all cores within the specified CoreRangeSet. This only supports tensix cores, and can only use L1 buffer types like BufferType::L1 and BufferType::L1_SMALL.</p>
<p>Return value: std::unique_ptr&lt;GlobalSemaphore&gt;.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device to create the semaphore on   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cores   </td><td class="markdownTableBodyNone">Range of the Tensix co-ordinates using the semaphore   </td><td class="markdownTableBodyNone">CoreRangeSet &amp;&amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_value   </td><td class="markdownTableBodyNone">Initial value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer_type   </td><td class="markdownTableBodyNone">Buffer type to store the semaphore   </td><td class="markdownTableBodyNone">BufferType   </td><td class="markdownTableBodyNone">L1 types   </td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a0e68e0e2cb813bf5814ddb02d82cd1d0" name="a0e68e0e2cb813bf5814ddb02d82cd1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e68e0e2cb813bf5814ddb02d82cd1d0">&#9670;&#160;</a></span>CreateKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KernelHandle tt::tt_metal::v0::CreateKernel </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; DataMovementConfig, ComputeConfig, EthernetConfig &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a data movement kernel with no compile time arguments and adds it to the program.</p>
<p>Return value: Kernel ID (uintptr_t)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program to which this kernel will be added to   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">file_name   </td><td class="markdownTableBodyNone">Path to kernel src. Assumed to be absolute/relative to CWD, but will fall back to relative path from TT_METAL_HOME/TT_METAL_KERNEL_PATH.   </td><td class="markdownTableBodyNone">const std::string &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Either a single logical core, a range of logical cores or a set of logical core ranges that indicate which cores kernel is placed on   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreCoord, CoreRange, CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for data movement or compute kernel   </td><td class="markdownTableBodyNone">const std::variant&lt;DataMovementConfig,ComputeConfig,EthernetConfig&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a63aefd0f3f82e3dd0d66ff2ca72453c8" name="a63aefd0f3f82e3dd0d66ff2ca72453c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63aefd0f3f82e3dd0d66ff2ca72453c8">&#9670;&#160;</a></span>CreateKernelFromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KernelHandle tt::tt_metal::v0::CreateKernelFromString </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>kernel_src_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; DataMovementConfig, ComputeConfig, EthernetConfig &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a compute or data movement kernel with the given compile time arguments and adds it to the program.</p>
<p>Return value: Kernel ID (uintptr_t)</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program to which this kernel will be added to   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_src_code   </td><td class="markdownTableBodyNone">Source code for kernel   </td><td class="markdownTableBodyNone">const std::string &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Either a single logical core, a range of logical cores or a set of logical core ranges that indicate which cores kernel is placed on   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreCoord, CoreRange, CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">config   </td><td class="markdownTableBodyNone">Config for data movement or compute kernel   </td><td class="markdownTableBodyNone">const std::variant&lt;DataMovementConfig,ComputeConfig,EthernetConfig&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a826db8a9c40c91034bc2a5f0f6e9b75e" name="a826db8a9c40c91034bc2a5f0f6e9b75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826db8a9c40c91034bc2a5f0f6e9b75e">&#9670;&#160;</a></span>CreateProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Program tt::tt_metal::v0::CreateProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a Program object which is the main container that bundles kernels, circular buffers, and/or semaphores for execution on device</p>
<p>Return value: Program </p>

</div>
</div>
<a id="ad7ce765d28d851983f910495c44411cd" name="ad7ce765d28d851983f910495c44411cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ce765d28d851983f910495c44411cd">&#9670;&#160;</a></span>CreateSemaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tt::tt_metal::v0::CreateSemaphore </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoreType&#160;</td>
          <td class="paramname"><em>core_type</em> = <code>CoreType::WORKER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes semaphore on all cores within core range (inclusive). Each core can have up to eight 4B semaphores aligned to L1_ALIGNMENT.</p>
<p>Return value: Semaphore id (uint32_t). This can be used inside a kernel to extract the address using get_semaphore</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program to which semaphore will be added to   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Range of the Tensix co-ordinates using the semaphore   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreRange,CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_value   </td><td class="markdownTableBodyNone">Initial value of the semaphore   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">core_type   </td><td class="markdownTableBodyNone">Tensix or Ethernet core to create semaphore on.   </td><td class="markdownTableBodyNone">CoreType   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="abce385d98e86cf18acb680f183039cb5" name="abce385d98e86cf18acb680f183039cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce385d98e86cf18acb680f183039cb5">&#9670;&#160;</a></span>DeallocateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::DeallocateBuffer </td>
          <td>(</td>
          <td class="paramtype">Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates buffer from device by marking its memory as free.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The buffer to deallocate from device   </td><td class="markdownTableBodyNone">Buffer &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a617bb9ae1b430271808f81999a4ef53e" name="a617bb9ae1b430271808f81999a4ef53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617bb9ae1b430271808f81999a4ef53e">&#9670;&#160;</a></span>DumpDeviceProfileResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::DumpDeviceProfileResults </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read device side profiler data and dump results into device side CSV log</p>
<p>This function only works in PROFILER builds. Please refer to the "Device Program Profiler" section for more information.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device holding the program being profiled.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program being profiled.   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">True   </td></tr>
</table>

</div>
</div>
<a id="a868dff83af5a6f69735afddfb8123016" name="a868dff83af5a6f69735afddfb8123016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868dff83af5a6f69735afddfb8123016">&#9670;&#160;</a></span>EndTraceCapture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EndTraceCapture </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes capture on a trace, if captured commands do not conform to the rules of the trace, the trace will be invalidated. This trace can be enqueued for execution via ReplayTrace on the same device command queue. After ending a trace capture, buffer allocations on device are disabled until either a new trace begins capture, or all traces on the device are released</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device holding being traced.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cq_id   </td><td class="markdownTableBodyNone">The command queue id associated with the trace.   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">tid   </td><td class="markdownTableBodyNone">A unique id from BeginTraceCapture for the trace being captured   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="ab74d31b79ae9a8fe25468bc95b13ee2a" name="ab74d31b79ae9a8fe25468bc95b13ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74d31b79ae9a8fe25468bc95b13ee2a">&#9670;&#160;</a></span>EnqueueProgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueProgram </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a program to the device and launches it</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program that will be executed on the device that cq is bound to   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="aed6950194c0970fe3d6f35657524e44b" name="aed6950194c0970fe3d6f35657524e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6950194c0970fe3d6f35657524e44b">&#9670;&#160;</a></span>EnqueueReadBuffer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a buffer from the device</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The device buffer we are reading from   </td><td class="markdownTableBodyNone">Buffer &amp; or std::shared_ptr&lt;Buffer&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst   </td><td class="markdownTableBodyNone">The vector where the results that are read will be stored   </td><td class="markdownTableBodyNone">vector&lt;DType&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Only blocking mode supported currently   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="adfbc3816d634690201a2864b0e6ea1d8" name="adfbc3816d634690201a2864b0e6ea1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbc3816d634690201a2864b0e6ea1d8">&#9670;&#160;</a></span>EnqueueReadBuffer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; Buffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76bb833452d2265a33a294eef1140782" name="a76bb833452d2265a33a294eef1140782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bb833452d2265a33a294eef1140782">&#9670;&#160;</a></span>EnqueueReadBuffer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueReadBuffer </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a buffer from the device</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The device buffer we are reading from   </td><td class="markdownTableBodyNone">Buffer &amp; or std::shared_ptr&lt;Buffer&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">dst   </td><td class="markdownTableBodyNone">The memory where the result will be stored   </td><td class="markdownTableBodyNone">void*   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone">Only blocking mode supported currently   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a57cb44e976abef6030c7dbb73970d800" name="a57cb44e976abef6030c7dbb73970d800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cb44e976abef6030c7dbb73970d800">&#9670;&#160;</a></span>EnqueueRecordEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueRecordEvent </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueues a command to record an Event on the device for a given CQ, and updates the Event object for the user. Return value: void </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">event   </td><td class="markdownTableBodyNone">An event that will be populated by this function, and inserted in CQ   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Event&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a35c2d778c2f00844d1113c0e011522f2" name="a35c2d778c2f00844d1113c0e011522f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c2d778c2f00844d1113c0e011522f2">&#9670;&#160;</a></span>EnqueueTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueTrace </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>trace_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueues a trace of previously generated commands and data.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">trace_id   </td><td class="markdownTableBodyNone">A unique id representing an existing on-device trace, which has been   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">instantiated via InstantiateTrace where the trace_id is returned   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a0348eff37a292f881b5b88193d8196f6" name="a0348eff37a292f881b5b88193d8196f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0348eff37a292f881b5b88193d8196f6">&#9670;&#160;</a></span>EnqueueWaitForEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueWaitForEvent </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueues a command on the device for a given CQ (non-blocking). The command on device will block and wait for completion of the specified event (which may be in another CQ). Return value: void </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">and waits for the event to complete.   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">event   </td><td class="markdownTableBodyNone">The event object that this CQ will wait on for completion.   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Event&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a634370b608fd0b78795ab3d7b128c9f0" name="a634370b608fd0b78795ab3d7b128c9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634370b608fd0b78795ab3d7b128c9f0">&#9670;&#160;</a></span>EnqueueWriteBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HostDataType&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a buffer to the device</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The device buffer we are writing to   </td><td class="markdownTableBodyNone">Buffer &amp; or std::shared_ptr&lt;Buffer&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src   </td><td class="markdownTableBodyNone">The memory we are writing to the device   </td><td class="markdownTableBodyNone">HostDataType   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a7c3bea917e3563c642147c3f34911270" name="a7c3bea917e3563c642147c3f34911270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3bea917e3563c642147c3f34911270">&#9670;&#160;</a></span>EnqueueWriteBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EnqueueWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; std::reference_wrapper&lt; Buffer &gt;, std::shared_ptr&lt; Buffer &gt; &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a buffer to the device</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">buffer   </td><td class="markdownTableBodyNone">The device buffer we are writing to   </td><td class="markdownTableBodyNone">Buffer &amp; or std::shared_ptr&lt;Buffer&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">src   </td><td class="markdownTableBodyNone">The vector we are writing to the device   </td><td class="markdownTableBodyNone">vector&lt;DType&gt; &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a51fd82461b3734afccb8f11427564181" name="a51fd82461b3734afccb8f11427564181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fd82461b3734afccb8f11427564181">&#9670;&#160;</a></span>EventQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tt::tt_metal::v0::EventQuery </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host will query an event for completion status on device. Return value: bool. True if event is completed, false otherwise. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">event   </td><td class="markdownTableBodyNone">The event object that host will query for completion.   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Event&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a7965734b9b4f42fd7b96da7cdcc45927" name="a7965734b9b4f42fd7b96da7cdcc45927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7965734b9b4f42fd7b96da7cdcc45927">&#9670;&#160;</a></span>EventSynchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::EventSynchronize </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Event &gt; &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocking function for host to synchronize (wait) on an event completion on device. Return value: void </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">event   </td><td class="markdownTableBodyNone">The event object that host will wait on for completion.   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Event&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a41ad47ba118422cf5d162a24289f53cb" name="a41ad47ba118422cf5d162a24289f53cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ad47ba118422cf5d162a24289f53cb">&#9670;&#160;</a></span>Finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::Finish </td>
          <td>(</td>
          <td class="paramtype">CommandQueue &amp;&#160;</td>
          <td class="paramname"><em>cq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks until all previously dispatched commands on the device have completed</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cq   </td><td class="markdownTableBodyNone">The command queue object which dispatches the command to the hardware   </td><td class="markdownTableBodyNone">CommandQueue &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="ac4b1a13298da52770f32ddeeabd2c65a" name="ac4b1a13298da52770f32ddeeabd2c65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b1a13298da52770f32ddeeabd2c65a">&#9670;&#160;</a></span>GetCircularBufferConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CircularBufferConfig &amp; tt::tt_metal::v0::GetCircularBufferConfig </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CBHandle&#160;</td>
          <td class="paramname"><em>cb_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a reference to the config owned by circular buffer at the given circular buffer ID.</p>
<p>Return value: const CircularBufferConfig &amp;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing the circular buffer   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cb_handle   </td><td class="markdownTableBodyNone">ID of the circular buffer, returned by <code>CreateCircularBuffers</code>   </td><td class="markdownTableBodyNone">CBHandle (uintptr_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a9117d8f938e3b0c3e6b146f960eafa2f" name="a9117d8f938e3b0c3e6b146f960eafa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9117d8f938e3b0c3e6b146f960eafa2f">&#9670;&#160;</a></span>GetCommonRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuntimeArgsData &amp; tt::tt_metal::v0::GetCommonRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the common runtime args for a kernel.</p>
<p>Return value: RuntimeArgsData &amp;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a1e4322b747fd7823e878c3e2ae729e27" name="a1e4322b747fd7823e878c3e2ae729e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4322b747fd7823e878c3e2ae729e27">&#9670;&#160;</a></span>GetNumAvailableDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tt::tt_metal::v0::GetNumAvailableDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of Tenstorrent devices that can be targeted</p>
<p>Return value: size_t </p>

</div>
</div>
<a id="a4f05b332fd6f861bb3540dbe2af433be" name="a4f05b332fd6f861bb3540dbe2af433be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f05b332fd6f861bb3540dbe2af433be">&#9670;&#160;</a></span>GetNumPCIeDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tt::tt_metal::v0::GetNumPCIeDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of Tenstorrent devices that are connected to host via PCIe and can be targeted</p>
<p>Return value: size_t </p>

</div>
</div>
<a id="af46d5827805ba92482cddb5591c69a45" name="af46d5827805ba92482cddb5591c69a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46d5827805ba92482cddb5591c69a45">&#9670;&#160;</a></span>GetPCIeDeviceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chip_id_t tt::tt_metal::v0::GetPCIeDeviceID </td>
          <td>(</td>
          <td class="paramtype">chip_id_t&#160;</td>
          <td class="paramname"><em>device_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65abc534c2bbbe36d118c3b844350a72" name="a65abc534c2bbbe36d118c3b844350a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65abc534c2bbbe36d118c3b844350a72">&#9670;&#160;</a></span>GetRuntimeArgs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; RuntimeArgsData &gt; &gt; &amp; tt::tt_metal::v0::GetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the runtime args for a kernel.</p>
<p>Return value: std::vector&lt; std::vector&lt; RuntimeArgsData &gt; &gt; &amp;</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a609d42acfdab49842d577aae66de2e67" name="a609d42acfdab49842d577aae66de2e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609d42acfdab49842d577aae66de2e67">&#9670;&#160;</a></span>GetRuntimeArgs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RuntimeArgsData &amp; tt::tt_metal::v0::GetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoreCoord &amp;&#160;</td>
          <td class="paramname"><em>logical_core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the runtime args for a kernel.</p>
<p>Return value: uint32_t *</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">logical_core   </td><td class="markdownTableBodyNone">The location of the Tensix core where the runtime args will be written   </td><td class="markdownTableBodyNone">const CoreCoord &amp;   </td><td class="markdownTableBodyNone">Any logical Tensix core coordinate   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a63ede0a0180762c7d1f091176738237c" name="a63ede0a0180762c7d1f091176738237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ede0a0180762c7d1f091176738237c">&#9670;&#160;</a></span>IsGalaxyCluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tt::tt_metal::v0::IsGalaxyCluster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether Tenstorrent devices are in a Galaxy cluster</p>
<p>Return value: bool </p>

</div>
</div>
<a id="ad8540d48e27a58a9519483782991eba0" name="ad8540d48e27a58a9519483782991eba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8540d48e27a58a9519483782991eba0">&#9670;&#160;</a></span>ReleaseTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::ReleaseTrace </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release a previously instantiated trace, deallocating the associated trace buffers on device This operation is not thread-safe, user must ensure that the trace being released is no longer needed by device threads If this releases the last trace on a device, then buffer allocations are re-enabled</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device holding the trace.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">trace_id   </td><td class="markdownTableBodyNone">A unique id representing an existing captured trace.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="aaf7e23130adb368821457f261e37cd9b" name="aaf7e23130adb368821457f261e37cd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7e23130adb368821457f261e37cd9b">&#9670;&#160;</a></span>ReplayTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::ReplayTrace </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>cq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replay a trace of previously generated commands and data.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device holding the trace.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cq_id   </td><td class="markdownTableBodyNone">The command queue id associated with the trace.   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">trace_id   </td><td class="markdownTableBodyNone">A unique id representing an existing captured trace.   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">blocking   </td><td class="markdownTableBodyNone">Whether or not this is a blocking operation   </td><td class="markdownTableBodyNone">bool   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a8263eba8cd8279b6c1e6db233ec5f133" name="a8263eba8cd8279b6c1e6db233ec5f133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8263eba8cd8279b6c1e6db233ec5f133">&#9670;&#160;</a></span>SetCommonRuntimeArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::SetCommonRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::Span&lt; const uint32_t &gt;&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set common (shared by all cores) runtime args for a kernel that are sent to all cores during runtime. This API needs to be called to update the common runtime args for the kernel. Maximum of 255 allowed runtime args per core (unique and common runtime args count toward same limit).</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">runtime_args   </td><td class="markdownTableBodyNone">The runtime args to be written   </td><td class="markdownTableBodyNone">stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="afb2ca08d5f123ed98b99498324061ba4" name="afb2ca08d5f123ed98b99498324061ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2ca08d5f123ed98b99498324061ba4">&#9670;&#160;</a></span>SetRuntimeArgs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::SetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stl::Span&lt; const uint32_t &gt;&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set runtime args for a kernel that are sent to the core during runtime. This API needs to be called to update the runtime args for the kernel. Maximum of 255 allowed runtime args per core (unique and common runtime args count toward same limit).</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Location of Tensix core(s) where the runtime args will be written   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreCoord,CoreRange,CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone">Any logical Tensix core coordinate(s) on which the kernel is placed   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">runtime_args   </td><td class="markdownTableBodyNone">The runtime args to be written   </td><td class="markdownTableBodyNone">stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a74ca7c2b7c798d3c16af2dc931d68df0" name="a74ca7c2b7c798d3c16af2dc931d68df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ca7c2b7c798d3c16af2dc931d68df0">&#9670;&#160;</a></span>SetRuntimeArgs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::SetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">const Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelHandle&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoreCoord &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set multiple runtime arguments of a kernel at once during runtime, each mapping to a specific core. The runtime args for each core may be unique. Maximum of 255 allowed runtime args per core (unique and common runtime args count toward same limit).</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing kernels, circular buffers, semaphores   </td><td class="markdownTableBodyNone">const Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel_id   </td><td class="markdownTableBodyNone">ID of the kernel that will receive the runtime args   </td><td class="markdownTableBodyNone">KernelHandle (uint64_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Location of Tensix core(s) where the runtime args will be written   </td><td class="markdownTableBodyNone">const std::vector&lt;CoreCoord&gt; &amp;   </td><td class="markdownTableBodyNone">Any set of logical Tensix core coordinates on which the kernel is placed   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">runtime_args   </td><td class="markdownTableBodyNone">The runtime args to be written   </td><td class="markdownTableBodyNone">const std::vector&lt; vector&lt;uint32_t&gt; &gt; &amp;   </td><td class="markdownTableBodyNone">Outer vector size must be equal to size of core_spec vector   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="afdb3df50326c491a4612d21ce45a518a" name="afdb3df50326c491a4612d21ce45a518a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb3df50326c491a4612d21ce45a518a">&#9670;&#160;</a></span>SetRuntimeArgs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::SetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Kernel &gt;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::variant&lt; CoreCoord, CoreRange, CoreRangeSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">RuntimeArgs</a> &gt;&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set runtime args for a kernel that are sent to the specified cores using the command queue. This API must be used when Asynchronous Command Queue Mode is enabled. Maximum of 255 allowed runtime args per core (unique and common runtime args count toward same limit).</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device that runtime args are being written to.   </td><td class="markdownTableBodyNone">Device*   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel   </td><td class="markdownTableBodyNone">The kernel that will recieve these runtime args.   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Kernel&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Location of Tensix core(s) where the runtime args will be written   </td><td class="markdownTableBodyNone">const std::variant&lt;CoreCoord,CoreRange,CoreRangeSet&gt; &amp;   </td><td class="markdownTableBodyNone">Any set of logical Tensix core coordinates on which the kernel is placed   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">runtime_args   </td><td class="markdownTableBodyNone">The runtime args to be written   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;RuntimeArgs&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a774adf0f130e4a8f75007cca0a33fcb6" name="a774adf0f130e4a8f75007cca0a33fcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774adf0f130e4a8f75007cca0a33fcb6">&#9670;&#160;</a></span>SetRuntimeArgs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::SetRuntimeArgs </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; Kernel &gt;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoreCoord &gt; &amp;&#160;</td>
          <td class="paramname"><em>core_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="namespacett_1_1tt__metal_1_1v0.html#a5d1cfea010cb740e7307b18b4a7ec9e8">RuntimeArgs</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>runtime_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set multiple runtime arguments of a kernel using the command queue. Each core can have distinct arguments. This API must be used when Asynchronous Command Queue Mode is enabled. Maximum of 255 allowed runtime args per core (unique and common runtime args count toward same limit).</p>
<p>Return value: void </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device that runtime args are being written to.   </td><td class="markdownTableBodyNone">Device*   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kernel   </td><td class="markdownTableBodyNone">The kernel that will recieve these runtime args.   </td><td class="markdownTableBodyNone">std::shared_ptr&lt;Kernel&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">core_spec   </td><td class="markdownTableBodyNone">Location of Tensix core(s) where the runtime args will be written   </td><td class="markdownTableBodyNone">const std::vector&lt; CoreCoord &gt; &amp;   </td><td class="markdownTableBodyNone">Any set of logical Tensix core coordinates on which the kernel is placed   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">runtime_args   </td><td class="markdownTableBodyNone">The runtime args to be written   </td><td class="markdownTableBodyNone">const std::vector&lt;std::shared_ptr&lt;RuntimeArgs&gt;&gt;   </td><td class="markdownTableBodyNone">Outer vector size must be equal to size of core_spec vector   </td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="abbef214f3ba879469488d367053046cb" name="abbef214f3ba879469488d367053046cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbef214f3ba879469488d367053046cb">&#9670;&#160;</a></span>Synchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::Synchronize </td>
          <td>(</td>
          <td class="paramtype">Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>cq_id</em> = <code>std::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::stl::Span&lt; const SubDeviceId &gt;&#160;</td>
          <td class="paramname"><em>sub_device_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize the device with host by waiting for all operations to complete. If cq_id is provided then only the operations associated with that cq_id are waited for, otherwise operations for all command queues are waited on.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">device   </td><td class="markdownTableBodyNone">The device to synchronize.   </td><td class="markdownTableBodyNone">Device *   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cq_id   </td><td class="markdownTableBodyNone">The specific command queue id to synchronize .   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">sub_device_ids   </td><td class="markdownTableBodyNone">The sub-device ids to wait for completion on. If empty, waits for all sub-devices   </td><td class="markdownTableBodyNone">tt::stl::Span&lt;const uint32_t&gt;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">No   </td></tr>
</table>

</div>
</div>
<a id="a3831e993c64a578637c9fc73b059412d" name="a3831e993c64a578637c9fc73b059412d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3831e993c64a578637c9fc73b059412d">&#9670;&#160;</a></span>UpdateCircularBufferPageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::UpdateCircularBufferPageSize </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CBHandle&#160;</td>
          <td class="paramname"><em>cb_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the page size at specified <code>buffer_index</code> of the circular buffer at the given circular buffer handle.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing the circular buffer   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cb_handle   </td><td class="markdownTableBodyNone">ID of the circular buffer, returned by <code>CreateCircularBuffers</code>   </td><td class="markdownTableBodyNone">CBHandle (uintptr_t)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">buffer_index   </td><td class="markdownTableBodyNone">Circular buffer index to update page size. <code>cb_handle</code> must be a circular buffer that had previously programmed this index   </td><td class="markdownTableBodyNone">uint8_t   </td><td class="markdownTableBodyNone">0 to NUM_CIRCULAR_BUFFERS - 1   </td><td class="markdownTableBodyNone">Yes    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">page_size   </td><td class="markdownTableBodyNone">Updated page size in bytes   </td><td class="markdownTableBodyNone">uint32_t   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>

</div>
</div>
<a id="a220dc8a16809c1c12a44348b9a76ab08" name="a220dc8a16809c1c12a44348b9a76ab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220dc8a16809c1c12a44348b9a76ab08">&#9670;&#160;</a></span>UpdateCircularBufferTotalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::UpdateCircularBufferTotalSize </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CBHandle&#160;</td>
          <td class="paramname"><em>cb_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the total size of the circular buffer at the given circular buffer handle. Updating a program-local circular buffer requires all circular buffers in the program to be reallocated.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing the circular buffer   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<p>| cb_handle | ID of the circular buffer, returned by <code>CreateCircularBuffers</code> | CBHandle (uintptr_t) | | Yes | | | total_size | New size of the circular buffer in bytes | uint32_t | | Yes | </p>

</div>
</div>
<a id="a0cf0d51e979e755908ee29c30401ee53" name="a0cf0d51e979e755908ee29c30401ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf0d51e979e755908ee29c30401ee53">&#9670;&#160;</a></span>UpdateDynamicCircularBufferAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tt::tt_metal::v0::UpdateDynamicCircularBufferAddress </td>
          <td>(</td>
          <td class="paramtype">Program &amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CBHandle&#160;</td>
          <td class="paramname"><em>cb_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the address of a dynamic circular buffer. Dynamic circular buffers share the same address space as L1 buffers.</p>
<p>Return value: void</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Argument   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Valid Range   </th><th class="markdownTableHeadNone">Required    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">program   </td><td class="markdownTableBodyNone">The program containing the circular buffer   </td><td class="markdownTableBodyNone">Program &amp;   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Yes   </td></tr>
</table>
<p>| cb_handle | ID of the circular buffer, returned by <code>CreateCircularBuffers</code> | CBHandle (uintptr_t) | | Yes | | | buffer | Dynamically allocated L1 buffer that shares address space of circular buffer <code>cb_handle</code> | const Buffer &amp; | L1 buffer | Yes | </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
